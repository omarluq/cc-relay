---
phase: 02.2-subscription-token-relay
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/proxy/handler.go
  - internal/proxy/handler_test.go
  - docs-site/content/en/docs/configuration.md
autonomous: true

must_haves:
  truths:
    - "Client Authorization header forwarded unchanged when present"
    - "Client x-api-key header forwarded unchanged when present"
    - "Fallback to configured provider keys when client has no auth"
    - "KeyPool/rate limiting only applies when using proxy's own keys"
    - "Works with existing ANTHROPIC_AUTH_TOKEN - user just changes URL"
  artifacts:
    - path: "internal/proxy/handler.go"
      provides: "Conditional auth forwarding in Rewrite and ServeHTTP"
      contains: "clientAuth := r.In.Header.Get"
    - path: "internal/proxy/handler_test.go"
      provides: "Tests for transparent forwarding and fallback paths"
      contains: "TestHandler_ForwardsClientAuthWhenPresent"
    - path: "docs-site/content/en/docs/configuration.md"
      provides: "Documentation of transparent auth behavior"
      contains: "Transparent Authentication"
  key_links:
    - from: "internal/proxy/handler.go"
      to: "Provider.Authenticate"
      via: "conditional call only when no client auth"
      pattern: "if clientAuth == \"\" && clientAPIKey == \"\""
---

<objective>
Implement transparent proxy authentication that forwards client Authorization headers unchanged when present, falling back to configured provider keys when client has no auth.

Purpose: Enable Claude Code subscription users to use cc-relay as a transparent proxy - they just set `ANTHROPIC_BASE_URL` and their `ANTHROPIC_AUTH_TOKEN` flows through unchanged. No new config fields needed.

Output: Modified handler.go with conditional auth forwarding, comprehensive tests, and documentation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02.2-subscription-token-relay/02.2-RESEARCH.md

# Key files to modify
@internal/proxy/handler.go
@internal/proxy/handler_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement conditional auth forwarding in handler.go</name>
  <files>internal/proxy/handler.go</files>
  <action>
Modify the Rewrite function (around line 57) to conditionally forward or strip auth headers:

```go
Rewrite: func(r *httputil.ProxyRequest) {
    // Set backend URL
    r.SetURL(targetURL)
    r.SetXForwarded()

    // Check if client provided auth headers
    clientAuth := r.In.Header.Get("Authorization")
    clientAPIKey := r.In.Header.Get("x-api-key")

    if clientAuth != "" || clientAPIKey != "" {
        // TRANSPARENT MODE: Client has auth - forward it unchanged
        // Do NOT strip Authorization, do NOT add our key
        // Just forward anthropic-* headers alongside client auth

        // Forward anthropic-* headers (version, beta flags)
        for key, values := range r.In.Header {
            canonicalKey := http.CanonicalHeaderKey(key)
            if len(canonicalKey) >= 10 && canonicalKey[:10] == "Anthropic-" {
                r.Out.Header[canonicalKey] = values
            }
        }
        r.Out.Header.Set("Content-Type", "application/json")

        // Log that we're forwarding client auth (debug level)
        // Note: Get logger from context if available, or use zerolog.Ctx
    } else {
        // FALLBACK MODE: Client has NO auth - use our configured keys
        // Strip any stale headers and authenticate with our key
        r.Out.Header.Del("Authorization")
        r.Out.Header.Del("x-api-key")

        // Get the selected API key from context (set in ServeHTTP)
        selectedKey := r.In.Header.Get("X-Selected-Key")
        if selectedKey == "" {
            selectedKey = h.apiKey // Fallback to single-key mode
        }

        // Only authenticate if we have a key to use
        if selectedKey != "" {
            //nolint:errcheck // Provider.Authenticate error handling deferred to ErrorHandler
            h.provider.Authenticate(r.Out, selectedKey)
        }
        // If no key available, let backend return 401 (transparent error)

        // Forward anthropic-* headers
        forwardHeaders := h.provider.ForwardHeaders(r.In.Header)
        for key, values := range forwardHeaders {
            r.Out.Header[key] = values
        }
    }
},
```

Also modify ServeHTTP to skip KeyPool when client auth is present:

In ServeHTTP (around line 146), after the logger setup and before key selection:

```go
// Check if client provided auth - skip key pool if so
clientAuth := r.Header.Get("Authorization")
clientAPIKey := r.Header.Get("x-api-key")
hasClientAuth := clientAuth != "" || clientAPIKey != ""

if hasClientAuth {
    // Transparent mode: client auth will be forwarded, skip key pool
    logger.Debug().
        Bool("has_authorization", clientAuth != "").
        Bool("has_x_api_key", clientAPIKey != "").
        Msg("transparent mode: forwarding client auth")
} else if h.keyPool != nil {
    // Existing key pool logic...
    var err error
    keyID, selectedKey, err = h.keyPool.GetKey(r.Context())
    // ... rest of key pool handling
} else {
    // Single key mode - set header directly
    r.Header.Set("X-Selected-Key", h.apiKey)
}
```

Also modify modifyResponse to skip rate limit tracking when client auth was used:

```go
func (h *Handler) modifyResponse(resp *http.Response) error {
    // Add SSE headers if streaming response
    if resp.Header.Get("Content-Type") == "text/event-stream" {
        SetSSEHeaders(resp.Header)
    }

    // Skip rate limit tracking if client provided their own auth
    // (KeyPool only tracks OUR keys, not client's subscription)
    keyID, hasKeyID := resp.Request.Context().Value(keyIDContextKey).(string)
    if !hasKeyID || keyID == "" {
        // No keyID in context = transparent mode or no pool, skip tracking
        return nil
    }

    // Update key pool from rate limit headers (our keys only)
    if h.keyPool != nil {
        // ... existing logic
    }

    return nil
}
```
  </action>
  <verify>
Run `go build ./...` to ensure code compiles.
Run `go test ./internal/proxy/... -run TestHandler -v` to verify existing tests still pass.
  </verify>
  <done>
Handler conditionally forwards client auth when present, falls back to configured keys when absent.
KeyPool rate limiting only applies when using proxy's own keys.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive tests for transparent auth</name>
  <files>internal/proxy/handler_test.go</files>
  <action>
Add the following test functions to handler_test.go:

```go
// TestHandler_ForwardsClientAuthWhenPresent tests that client Authorization header
// is forwarded unchanged when present (transparent proxy mode).
func TestHandler_ForwardsClientAuthWhenPresent(t *testing.T) {
    t.Parallel()

    var receivedAuthHeader string
    var receivedAPIKeyHeader string

    // Create mock backend that captures headers
    backend := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        receivedAuthHeader = r.Header.Get("Authorization")
        receivedAPIKeyHeader = r.Header.Get("x-api-key")

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        _, _ = w.Write([]byte(`{"id":"test"}`))
    }))
    defer backend.Close()

    // Create handler with a configured fallback key
    provider := providers.NewAnthropicProvider("test", backend.URL)
    handler, err := NewHandler(provider, "fallback-key", nil, config.DebugOptions{})
    require.NoError(t, err)

    // Create request WITH client Authorization header
    req := httptest.NewRequest("POST", "/v1/messages", bytes.NewReader([]byte("{}")))
    req.Header.Set("Authorization", "Bearer sub_12345")
    req.Header.Set("Anthropic-Version", "2024-01-01")

    w := httptest.NewRecorder()
    handler.ServeHTTP(w, req)

    // Verify response OK
    assert.Equal(t, http.StatusOK, w.Code)

    // CRITICAL: Client Authorization header should be forwarded UNCHANGED
    assert.Equal(t, "Bearer sub_12345", receivedAuthHeader)

    // Our fallback key should NOT be added
    assert.Empty(t, receivedAPIKeyHeader, "fallback key should not be added when client has auth")
}

// TestHandler_ForwardsClientAPIKeyWhenPresent tests that client x-api-key header
// is forwarded unchanged when present (transparent proxy mode).
func TestHandler_ForwardsClientAPIKeyWhenPresent(t *testing.T) {
    t.Parallel()

    var receivedAuthHeader string
    var receivedAPIKeyHeader string

    backend := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        receivedAuthHeader = r.Header.Get("Authorization")
        receivedAPIKeyHeader = r.Header.Get("x-api-key")

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        _, _ = w.Write([]byte(`{"id":"test"}`))
    }))
    defer backend.Close()

    provider := providers.NewAnthropicProvider("test", backend.URL)
    handler, err := NewHandler(provider, "fallback-key", nil, config.DebugOptions{})
    require.NoError(t, err)

    // Create request WITH client x-api-key header
    req := httptest.NewRequest("POST", "/v1/messages", bytes.NewReader([]byte("{}")))
    req.Header.Set("x-api-key", "sk-ant-client-key")
    req.Header.Set("Anthropic-Version", "2024-01-01")

    w := httptest.NewRecorder()
    handler.ServeHTTP(w, req)

    assert.Equal(t, http.StatusOK, w.Code)

    // Client x-api-key should be forwarded UNCHANGED
    assert.Equal(t, "sk-ant-client-key", receivedAPIKeyHeader)

    // No Authorization header should be added
    assert.Empty(t, receivedAuthHeader)
}

// TestHandler_UsesFallbackKeyWhenNoClientAuth tests that configured provider keys
// are used when client provides no auth headers.
func TestHandler_UsesFallbackKeyWhenNoClientAuth(t *testing.T) {
    t.Parallel()

    var receivedAuthHeader string
    var receivedAPIKeyHeader string

    backend := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        receivedAuthHeader = r.Header.Get("Authorization")
        receivedAPIKeyHeader = r.Header.Get("x-api-key")

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        _, _ = w.Write([]byte(`{"id":"test"}`))
    }))
    defer backend.Close()

    provider := providers.NewAnthropicProvider("test", backend.URL)
    handler, err := NewHandler(provider, "our-fallback-key", nil, config.DebugOptions{})
    require.NoError(t, err)

    // Create request WITHOUT any auth headers
    req := httptest.NewRequest("POST", "/v1/messages", bytes.NewReader([]byte("{}")))
    req.Header.Set("Anthropic-Version", "2024-01-01")
    // NO Authorization, NO x-api-key

    w := httptest.NewRecorder()
    handler.ServeHTTP(w, req)

    assert.Equal(t, http.StatusOK, w.Code)

    // Client Authorization should be empty (none provided)
    assert.Empty(t, receivedAuthHeader)

    // Our fallback key should be used
    assert.Equal(t, "our-fallback-key", receivedAPIKeyHeader)
}

// TestHandler_TransparentModeSkipsKeyPool tests that key pool is skipped
// when client provides auth (rate limiting is their problem).
func TestHandler_TransparentModeSkipsKeyPool(t *testing.T) {
    t.Parallel()

    backend := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        _, _ = w.Write([]byte(`{"id":"test"}`))
    }))
    defer backend.Close()

    // Create key pool with test keys
    pool, err := keypool.NewKeyPool("test-provider", keypool.PoolConfig{
        Strategy: "least_loaded",
        Keys: []keypool.KeyConfig{
            {APIKey: "pool-key-1", RPMLimit: 50, ITPMLimit: 10000, OTPMLimit: 5000},
        },
    })
    require.NoError(t, err)

    provider := providers.NewAnthropicProvider("test", backend.URL)
    handler, err := NewHandler(provider, "", pool, config.DebugOptions{})
    require.NoError(t, err)

    // Create request WITH client auth
    req := httptest.NewRequest("POST", "/v1/messages", bytes.NewReader([]byte("{}")))
    req.Header.Set("Authorization", "Bearer client-token")

    w := httptest.NewRecorder()
    handler.ServeHTTP(w, req)

    assert.Equal(t, http.StatusOK, w.Code)

    // x-cc-relay-* headers should NOT be set (key pool was skipped)
    assert.Empty(t, w.Header().Get(HeaderRelayKeyID), "key pool should be skipped in transparent mode")
    assert.Empty(t, w.Header().Get(HeaderRelayKeysTotal))
}

// TestHandler_FallbackModeUsesKeyPool tests that key pool is used
// when client provides no auth.
func TestHandler_FallbackModeUsesKeyPool(t *testing.T) {
    t.Parallel()

    backend := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        _, _ = w.Write([]byte(`{"id":"test"}`))
    }))
    defer backend.Close()

    pool, err := keypool.NewKeyPool("test-provider", keypool.PoolConfig{
        Strategy: "least_loaded",
        Keys: []keypool.KeyConfig{
            {APIKey: "pool-key-1", RPMLimit: 50, ITPMLimit: 10000, OTPMLimit: 5000},
        },
    })
    require.NoError(t, err)

    provider := providers.NewAnthropicProvider("test", backend.URL)
    handler, err := NewHandler(provider, "", pool, config.DebugOptions{})
    require.NoError(t, err)

    // Create request WITHOUT client auth
    req := httptest.NewRequest("POST", "/v1/messages", bytes.NewReader([]byte("{}")))
    // NO Authorization, NO x-api-key

    w := httptest.NewRecorder()
    handler.ServeHTTP(w, req)

    assert.Equal(t, http.StatusOK, w.Code)

    // x-cc-relay-* headers SHOULD be set (key pool was used)
    assert.NotEmpty(t, w.Header().Get(HeaderRelayKeyID), "key pool should be used in fallback mode")
    assert.Equal(t, "1", w.Header().Get(HeaderRelayKeysTotal))
}

// TestHandler_TransparentModeForwardsAnthropicHeaders tests that anthropic-* headers
// are forwarded in transparent mode.
func TestHandler_TransparentModeForwardsAnthropicHeaders(t *testing.T) {
    t.Parallel()

    var receivedVersion string
    var receivedBeta string

    backend := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        receivedVersion = r.Header.Get("Anthropic-Version")
        receivedBeta = r.Header.Get("Anthropic-Beta")

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        _, _ = w.Write([]byte(`{"id":"test"}`))
    }))
    defer backend.Close()

    provider := providers.NewAnthropicProvider("test", backend.URL)
    handler, err := NewHandler(provider, "fallback-key", nil, config.DebugOptions{})
    require.NoError(t, err)

    req := httptest.NewRequest("POST", "/v1/messages", bytes.NewReader([]byte("{}")))
    req.Header.Set("Authorization", "Bearer client-token")
    req.Header.Set("Anthropic-Version", "2024-01-01")
    req.Header.Set("Anthropic-Beta", "extended-thinking-2024-01-01")

    w := httptest.NewRecorder()
    handler.ServeHTTP(w, req)

    assert.Equal(t, http.StatusOK, w.Code)
    assert.Equal(t, "2024-01-01", receivedVersion)
    assert.Equal(t, "extended-thinking-2024-01-01", receivedBeta)
}
```

Update the existing test TestHandler_StripsClientAuthHeaders to reflect the NEW behavior:
- Rename it to TestHandler_StripsClientAuthWhenNoClientAuth or delete it
- The old test verified stripping always happens - now stripping only happens when client has NO auth

Actually, keep the existing test but update its documentation to clarify it tests fallback mode:
```go
// TestHandler_StripsClientAuthHeaders tests that client Authorization headers are NOT forwarded
// when the client provides NO auth and we use fallback keys.
// Note: When client DOES provide auth, it IS forwarded (see TestHandler_ForwardsClientAuthWhenPresent).
```

Wait, the existing test TestHandler_StripsClientAuthHeaders sends client auth headers and expects them to be stripped. This test will FAIL after our changes because now we forward client auth. We need to:
1. Update the test to reflect new behavior OR
2. Delete it and rely on the new tests

The cleanest approach: Delete TestHandler_StripsClientAuthHeaders since TestHandler_UsesFallbackKeyWhenNoClientAuth tests the same scenario better.
  </action>
  <verify>
Run `go test ./internal/proxy/... -v` to verify all tests pass.
Run `go test ./internal/proxy/... -race` to check for race conditions.
  </verify>
  <done>
All new tests pass. Tests cover: transparent forwarding (Authorization), transparent forwarding (x-api-key), fallback to configured keys, key pool skipped in transparent mode, key pool used in fallback mode, anthropic-* headers forwarded in both modes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Document transparent authentication behavior</name>
  <files>docs-site/content/en/docs/configuration.md</files>
  <action>
Add a new section "Transparent Authentication" to the English configuration.md documentation.

Find the Authentication section and add this new subsection:

```markdown
## Transparent Authentication

cc-relay automatically detects how to handle authentication based on what the client sends:

### How It Works

| Client Sends | cc-relay Behavior | Use Case |
|--------------|-------------------|----------|
| `Authorization: Bearer <token>` | Forward unchanged | Claude Code subscription users |
| `x-api-key: <key>` | Forward unchanged | Direct API key users |
| No auth headers | Use configured provider keys | Enterprise/team deployments |

### Claude Code Subscription Users

If you have a Claude Code subscription (Max/Team/Enterprise plan), you can use cc-relay as a transparent proxy:

```bash
# Set cc-relay as your API endpoint
export ANTHROPIC_BASE_URL="http://localhost:8787"

# Your subscription token flows through unchanged
# ANTHROPIC_AUTH_TOKEN is already set by Claude Code
claude
```

**No API key required** - cc-relay forwards your subscription token to Anthropic.

### Enterprise/Team Deployments

For centralized API key management, don't provide client auth - cc-relay uses configured keys:

```yaml
# config.yaml
providers:
  - name: anthropic
    type: anthropic
    base_url: https://api.anthropic.com
    enabled: true
    keys:
      - key: ${ANTHROPIC_API_KEY}
        rpm_limit: 50
```

```bash
# Client has no auth - uses configured keys
export ANTHROPIC_BASE_URL="http://localhost:8787"
unset ANTHROPIC_AUTH_TOKEN
unset ANTHROPIC_API_KEY
claude
```

### Mixed Mode

You can run both modes simultaneously:
- Subscription users: Their auth flows through (no key pool overhead)
- Team users: Use configured keys with rate limit pooling

Rate limiting and key pooling only apply when using configured keys, not client-provided auth.

### Key Points

1. **Auto-detection**: No configuration needed - behavior determined by client headers
2. **Subscription passthrough**: `Authorization: Bearer` forwarded unchanged
3. **Fallback keys**: Used only when client has no auth
4. **Key pool efficiency**: Only tracks usage of YOUR keys, not client subscriptions
```
  </action>
  <verify>
Run `cd docs-site && hugo --minify` to verify the site builds.
Check the configuration.md file is properly formatted.
  </verify>
  <done>
Documentation updated with transparent authentication section explaining auto-detection behavior, subscription passthrough, and mixed mode usage.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` - Code compiles
2. `go test ./internal/proxy/... -v` - All handler tests pass
3. `go test ./internal/proxy/... -race` - No race conditions
4. `task lint` - Linter passes
5. `cd docs-site && hugo --minify` - Documentation builds

Manual verification:
1. Start cc-relay with a configured API key
2. Test with `Authorization: Bearer test` header - should forward unchanged
3. Test without any auth - should use configured key
</verification>

<success_criteria>
1. Client `Authorization` header forwarded unchanged when present
2. Client `x-api-key` header forwarded unchanged when present
3. Configured provider keys used as fallback when client has no auth
4. KeyPool rate limiting only applies when using proxy's own keys
5. All existing tests pass
6. New tests cover transparent and fallback modes
7. Documentation explains the auto-detection behavior
</success_criteria>

<output>
After completion, create `.planning/phases/02.2-subscription-token-relay/02.2-01-SUMMARY.md`
</output>
