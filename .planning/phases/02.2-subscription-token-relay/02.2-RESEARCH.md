# Phase 2.2: Subscription Token Relay - Research (REVISED + IMPLEMENTATION)

**Researched:** 2026-01-22 (enhanced from 2026-01-21)
**Domain:** Transparent proxy authentication forwarding for Claude Code
**Confidence:** HIGH (verified with official docs + concrete implementation analysis)

## Summary

This research investigates how to implement **transparent proxy mode** in cc-relay, enabling forwarding of Claude Code subscription tokens (Authorization: Bearer) to Anthropic. The key insight: cc-relay is NOT a third-party tool trying to spoof Claude Code. It is a **transparent proxy** that Claude Code uses as its backend.

**User requirements (from discussion):**
- Use Claude Code subscription (NO API key) for Anthropic
- Use Z.AI API key for Z.AI provider
- BOTH modes working together: transparent for Anthropic, proxy_auth for Z.AI
- Transparent to user with sensible defaults (minimal config)

**Primary recommendation:** Implement `auth_mode` with smart defaults - transparent when no keys configured, proxy_auth when keys exist. This makes the common case (subscription passthrough) require zero extra config.

## Critical Clarification: What Anthropic Actually Blocked

### January 2026 Crackdown Target

Anthropic blocked **client identity spoofing**, not transparent proxies:

| What Was Blocked | What Was NOT Blocked |
|------------------|----------------------|
| Third-party tools (OpenCode, Cursor) sending Claude Code-specific headers to masquerade as the official client | Legitimate HTTP proxies forwarding client requests unchanged |
| OAuth tokens used directly in non-Claude-Code applications | Claude Code sending requests through a proxy (`ANTHROPIC_BASE_URL`) |
| Applications calling Anthropic API while pretending to be Claude Code | Enterprise LLM gateways (explicitly documented by Anthropic) |

### Evidence: Official LLM Gateway Documentation

From [Claude Code LLM Gateway Docs](https://code.claude.com/docs/en/llm-gateway):

> "LLM gateways provide a centralized proxy layer between Claude Code and model providers, offering centralized authentication, usage tracking, cost controls, audit logging, and model routing."

The documentation provides explicit configuration for this:

```bash
# Claude Code talks to proxy
export ANTHROPIC_BASE_URL=https://your-proxy:8787

# Proxy forwards auth to Anthropic
export ANTHROPIC_AUTH_TOKEN=sk-your-token
```

**Key point:** `ANTHROPIC_AUTH_TOKEN` is sent as the `Authorization` header. This is the subscription token. Anthropic's own documentation shows this being forwarded through proxies.

---

## IMPLEMENTATION DETAILS

### Current Code Analysis (THE BUG)

**File:** `internal/proxy/handler.go` (lines 59-67)

```go
// CURRENT: Always strips - this is the bug!
// CRITICAL: Strip client authentication headers before forwarding to backend
// The incoming request may have Authorization: Bearer <subscription-token>
// from Claude Code's subscription auth. We must not forward this to the
// backend provider - we use our own configured API keys instead.
r.Out.Header.Del("Authorization")
r.Out.Header.Del("x-api-key")
```

**Problem:** This unconditionally strips the client's Authorization header, preventing transparent mode.

### Change 1: Add AuthMode to ProviderConfig

**File:** `internal/config/config.go`

Add to `ProviderConfig` struct (around line 102):

```go
// ProviderConfig defines configuration for a backend LLM provider.
type ProviderConfig struct {
    ModelMapping map[string]string `yaml:"model_mapping"`
    Name         string            `yaml:"name"`
    Type         string            `yaml:"type"`
    BaseURL      string            `yaml:"base_url"`
    Keys         []KeyConfig       `yaml:"keys"`
    Models       []string          `yaml:"models"`
    Pooling      PoolingConfig     `yaml:"pooling"`
    Enabled      bool              `yaml:"enabled"`

    // NEW: AuthMode determines how authentication is handled:
    // - "transparent": Forward client Authorization header unchanged (subscription passthrough)
    // - "proxy_auth": Strip client auth, use configured keys (default when keys exist)
    // If empty, auto-determined: transparent if no keys, proxy_auth if keys exist
    AuthMode     string            `yaml:"auth_mode"`
}

// GetEffectiveAuthMode returns the auth mode with smart defaults.
// - Explicit auth_mode takes precedence
// - If no auth_mode and no keys: transparent (subscription passthrough)
// - If no auth_mode and keys exist: proxy_auth (use pooled keys)
func (p *ProviderConfig) GetEffectiveAuthMode() string {
    // Explicit setting takes precedence
    if p.AuthMode == "transparent" {
        return "transparent"
    }
    if p.AuthMode == "proxy_auth" {
        return "proxy_auth"
    }

    // Smart default: no keys = transparent, keys = proxy_auth
    if len(p.Keys) == 0 {
        return "transparent"
    }
    return "proxy_auth"
}

// IsTransparent returns true if this provider uses transparent auth mode.
func (p *ProviderConfig) IsTransparent() bool {
    return p.GetEffectiveAuthMode() == "transparent"
}
```

### Change 2: Add AuthMode to Provider Interface

**File:** `internal/providers/provider.go`

Add method to Provider interface:

```go
// Provider defines the interface for LLM backend providers.
type Provider interface {
    // ... existing methods ...

    // AuthMode returns the authentication mode for this provider.
    // Returns "transparent" or "proxy_auth".
    AuthMode() string
}
```

### Change 3: Update BaseProvider

**File:** `internal/providers/base.go`

Add authMode field and method:

```go
// BaseProvider provides common functionality for Anthropic-compatible providers.
type BaseProvider struct {
    name     string
    baseURL  string
    owner    string
    models   []string
    authMode string  // NEW: "transparent" or "proxy_auth"
}

// NewBaseProvider creates a new base provider with the given parameters.
func NewBaseProvider(name, baseURL, owner string, models []string) BaseProvider {
    return BaseProvider{
        name:     name,
        baseURL:  baseURL,
        models:   models,
        owner:    owner,
        authMode: "proxy_auth", // Default
    }
}

// NewBaseProviderWithAuthMode creates a provider with explicit auth mode.
func NewBaseProviderWithAuthMode(name, baseURL, owner string, models []string, authMode string) BaseProvider {
    return BaseProvider{
        name:     name,
        baseURL:  baseURL,
        models:   models,
        owner:    owner,
        authMode: authMode,
    }
}

// AuthMode returns the authentication mode.
func (p *BaseProvider) AuthMode() string {
    if p.authMode == "" {
        return "proxy_auth"
    }
    return p.authMode
}
```

### Change 4: Update Provider Factory

Wherever providers are instantiated from config, pass the auth mode:

```go
// Example in provider factory
func NewProviderFromConfig(cfg *config.ProviderConfig) (providers.Provider, error) {
    authMode := cfg.GetEffectiveAuthMode()

    switch cfg.Type {
    case "anthropic":
        return providers.NewAnthropicProviderWithAuthMode(
            cfg.Name,
            cfg.BaseURL,
            cfg.Models,
            authMode,
        ), nil
    case "zai":
        return providers.NewZAIProviderWithAuthMode(
            cfg.Name,
            cfg.BaseURL,
            cfg.Models,
            authMode,
        ), nil
    // ... etc
    }
}
```

### Change 5: Conditional Auth in Handler (THE FIX)

**File:** `internal/proxy/handler.go`

Replace the Rewrite function (lines 54-82):

```go
h.proxy = &httputil.ReverseProxy{
    Rewrite: func(r *httputil.ProxyRequest) {
        // Set backend URL
        r.SetURL(targetURL)
        r.SetXForwarded()

        // Check auth mode
        if h.provider.AuthMode() == "transparent" {
            // TRANSPARENT MODE: Forward client auth unchanged
            // Authorization header already present from client request
            // Do NOT strip it, do NOT add x-api-key

            // Only strip x-api-key to prevent conflicts
            // (Authorization: Bearer takes precedence anyway, but be clean)
            r.Out.Header.Del("x-api-key")

            // Forward anthropic-* headers (version, beta flags)
            // These are critical for features like extended thinking
            for key, values := range r.In.Header {
                canonicalKey := http.CanonicalHeaderKey(key)
                if len(canonicalKey) >= 10 && canonicalKey[:10] == "Anthropic-" {
                    r.Out.Header[canonicalKey] = values
                }
            }

            // Set Content-Type
            r.Out.Header.Set("Content-Type", "application/json")

        } else {
            // PROXY_AUTH MODE: Strip client auth, use proxy's keys (current behavior)
            r.Out.Header.Del("Authorization")
            r.Out.Header.Del("x-api-key")

            // Get the selected API key from context (set in ServeHTTP)
            selectedKey := r.In.Header.Get("X-Selected-Key")
            if selectedKey == "" {
                selectedKey = h.apiKey // Fallback to single-key mode
            }

            // Authenticate with provider using our configured API key
            //nolint:errcheck // Provider.Authenticate error handling deferred to ErrorHandler
            h.provider.Authenticate(r.Out, selectedKey)

            // Forward anthropic-* headers
            forwardHeaders := h.provider.ForwardHeaders(r.In.Header)
            for key, values := range forwardHeaders {
                r.Out.Header[key] = values
            }
        }
    },
    // ... rest unchanged
}
```

### Change 6: Skip KeyPool for Transparent Mode

**File:** `internal/proxy/handler.go` in `ServeHTTP`

Modify key selection logic:

```go
func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    // ... existing setup ...

    // Select API key - SKIP for transparent mode
    var selectedKey string
    var keyID string

    if h.provider.AuthMode() == "transparent" {
        // Transparent mode: no key selection, client auth forwarded
        logger.Debug().Msg("transparent mode: forwarding client auth")

        // Validate client has auth (optional, can remove if too strict)
        if r.Header.Get("Authorization") == "" {
            WriteError(w, http.StatusUnauthorized, "authentication_error",
                "transparent mode requires client Authorization header")
            return
        }

    } else if h.keyPool != nil {
        // ... existing key pool logic ...
    } else {
        // Single key mode
        r.Header.Set("X-Selected-Key", h.apiKey)
    }

    // ... rest unchanged ...
}
```

### Change 7: Skip Rate Limit Tracking for Transparent Mode

In `modifyResponse`:

```go
func (h *Handler) modifyResponse(resp *http.Response) error {
    // Add SSE headers if streaming response
    if resp.Header.Get("Content-Type") == "text/event-stream" {
        SetSSEHeaders(resp.Header)
    }

    // Skip rate limit tracking for transparent mode - Anthropic enforces
    if h.provider.AuthMode() == "transparent" {
        return nil
    }

    // Update key pool from rate limit headers (proxy_auth mode only)
    if h.keyPool != nil {
        // ... existing logic ...
    }

    return nil
}
```

---

## Smart Defaults Configuration

### User Requirement: Minimal Config

The user wants:
1. Anthropic with subscription (no API key) = transparent mode
2. Z.AI with API key = proxy_auth mode

**With smart defaults, this is the config:**

```yaml
# config.yaml - Minimal config for dual-mode
server:
  listen: ":8787"
  auth:
    allow_subscription: true  # Accept Claude Code's Bearer token

providers:
  # Anthropic: NO keys = transparent mode (auto-detected)
  - name: anthropic
    type: anthropic
    base_url: https://api.anthropic.com
    enabled: true
    # auth_mode: transparent  # IMPLIED because no keys!
    # NO keys section = use client's subscription

  # Z.AI: HAS keys = proxy_auth mode (auto-detected)
  - name: zai
    type: zai
    base_url: https://open.bigmodel.cn/api/paas
    enabled: true
    # auth_mode: proxy_auth  # IMPLIED because keys exist!
    keys:
      - key: ${ZAI_API_KEY}
```

**How it works:**
- Anthropic provider: no `keys` configured -> `GetEffectiveAuthMode()` returns `"transparent"`
- Z.AI provider: has `keys` configured -> `GetEffectiveAuthMode()` returns `"proxy_auth"`

### Explicit Override

If user wants to be explicit:

```yaml
providers:
  - name: anthropic
    type: anthropic
    auth_mode: transparent  # Explicit
    enabled: true

  - name: zai
    type: zai
    auth_mode: proxy_auth   # Explicit
    enabled: true
    keys:
      - key: ${ZAI_API_KEY}
```

---

## Test Scenarios

### Test 1: Transparent Mode - Authorization Forwarded

```go
func TestTransparentMode_ForwardsAuthorization(t *testing.T) {
    // Setup: Provider with auth_mode: transparent
    cfg := &config.ProviderConfig{
        Name:     "anthropic-transparent",
        Type:     "anthropic",
        AuthMode: "transparent",
        // NO keys
    }

    // Create handler
    provider := providers.NewAnthropicProviderWithAuthMode(
        cfg.Name, cfg.BaseURL, nil, "transparent")
    handler, _ := proxy.NewHandler(provider, "", nil, config.DebugOptions{})

    // Mock backend that captures headers
    var capturedHeaders http.Header
    backend := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        capturedHeaders = r.Header.Clone()
        w.WriteHeader(http.StatusOK)
    }))

    // Send request with Authorization
    req := httptest.NewRequest("POST", "/v1/messages", nil)
    req.Header.Set("Authorization", "Bearer sub_token_12345")
    req.Header.Set("Anthropic-Version", "2024-01-01")

    recorder := httptest.NewRecorder()
    handler.ServeHTTP(recorder, req)

    // ASSERT: Authorization forwarded, NO x-api-key added
    assert.Equal(t, "Bearer sub_token_12345", capturedHeaders.Get("Authorization"))
    assert.Empty(t, capturedHeaders.Get("x-api-key"))
    assert.Equal(t, "2024-01-01", capturedHeaders.Get("Anthropic-Version"))
}
```

### Test 2: Proxy Auth Mode - Authorization Stripped, API Key Added

```go
func TestProxyAuthMode_StripsAuthorizationAddsAPIKey(t *testing.T) {
    // Setup: Provider with keys (proxy_auth mode)
    cfg := &config.ProviderConfig{
        Name: "zai-pooled",
        Type: "zai",
        Keys: []config.KeyConfig{
            {Key: "sk-zai-12345"},
        },
    }

    provider := providers.NewZAIProviderWithAuthMode(
        cfg.Name, cfg.BaseURL, nil, "proxy_auth")
    handler, _ := proxy.NewHandler(provider, "sk-zai-12345", nil, config.DebugOptions{})

    // Mock backend
    var capturedHeaders http.Header
    backend := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        capturedHeaders = r.Header.Clone()
        w.WriteHeader(http.StatusOK)
    }))

    // Send request with Authorization (should be stripped)
    req := httptest.NewRequest("POST", "/v1/messages", nil)
    req.Header.Set("Authorization", "Bearer sub_token_12345")

    recorder := httptest.NewRecorder()
    handler.ServeHTTP(recorder, req)

    // ASSERT: Authorization stripped, x-api-key added
    assert.Empty(t, capturedHeaders.Get("Authorization"))
    assert.Equal(t, "sk-zai-12345", capturedHeaders.Get("x-api-key"))
}
```

### Test 3: Smart Defaults - No Keys = Transparent

```go
func TestGetEffectiveAuthMode_NoKeys_ReturnsTransparent(t *testing.T) {
    cfg := &config.ProviderConfig{
        Name:    "anthropic",
        Type:    "anthropic",
        // NO auth_mode set
        // NO keys
    }

    assert.Equal(t, "transparent", cfg.GetEffectiveAuthMode())
}
```

### Test 4: Smart Defaults - Has Keys = ProxyAuth

```go
func TestGetEffectiveAuthMode_HasKeys_ReturnsProxyAuth(t *testing.T) {
    cfg := &config.ProviderConfig{
        Name: "zai",
        Type: "zai",
        // NO auth_mode set
        Keys: []config.KeyConfig{
            {Key: "sk-12345"},
        },
    }

    assert.Equal(t, "proxy_auth", cfg.GetEffectiveAuthMode())
}
```

### Test 5: Explicit Override - Transparent with Keys (Fallback)

```go
func TestExplicitTransparent_WithFallbackKeys(t *testing.T) {
    cfg := &config.ProviderConfig{
        Name:     "anthropic",
        Type:     "anthropic",
        AuthMode: "transparent",  // Explicit
        Keys: []config.KeyConfig{
            {Key: "sk-fallback"},  // Optional fallback
        },
    }

    // Explicit takes precedence
    assert.Equal(t, "transparent", cfg.GetEffectiveAuthMode())
}
```

### Test 6: Dual-Mode Integration

```go
func TestDualMode_AnthropicTransparent_ZAIProxyAuth(t *testing.T) {
    cfg := &config.Config{
        Providers: []config.ProviderConfig{
            {
                Name:    "anthropic",
                Type:    "anthropic",
                Enabled: true,
                // NO keys = transparent
            },
            {
                Name:    "zai",
                Type:    "zai",
                Enabled: true,
                Keys: []config.KeyConfig{
                    {Key: "sk-zai-key"},
                },
                // HAS keys = proxy_auth
            },
        },
    }

    assert.Equal(t, "transparent", cfg.Providers[0].GetEffectiveAuthMode())
    assert.Equal(t, "proxy_auth", cfg.Providers[1].GetEffectiveAuthMode())
}
```

---

## Standard Stack

### Authentication Flow: Transparent Mode

```
Claude Code                      cc-relay (transparent)              Anthropic API
     |                                    |                                |
     |--Authorization: Bearer <sub-token>->|                                |
     |                                    |                                |
     |                              [NO STRIPPING]                         |
     |                              [Forward as-is]                        |
     |                                    |                                |
     |                                    |--Authorization: Bearer <sub-token>->|
     |                                    |                                |
     |<-----------Response----------------|<---------Response--------------|
```

### Authentication Flow: Proxy Auth Mode (Current)

```
Claude Code                      cc-relay (proxy auth)               Anthropic API
     |                                    |                                |
     |--Authorization: Bearer <sub-token>->|                                |
     |                                    |                                |
     |                              [STRIP client auth]                    |
     |                              [Use proxy's API key]                  |
     |                                    |                                |
     |                                    |--x-api-key: <proxy-api-key>--->|
     |                                    |                                |
     |<-----------Response----------------|<---------Response--------------|
```

### Dual-Mode Architecture

| Mode | Use Case | Client Auth | Backend Auth | Who Pays |
|------|----------|-------------|--------------|----------|
| **transparent** | Personal use, subscription passthrough | Forward as-is | Client's token | Client |
| **proxy_auth** | Enterprise, multi-user, cost control | Validate/strip | Proxy's API key | Proxy owner |

---

## Architecture Patterns

### Headers to Forward in Transparent Mode

| Header | Required | Purpose |
|--------|----------|---------|
| `Authorization` | YES | Client's subscription token (Bearer) |
| `anthropic-version` | YES | API version compatibility |
| `anthropic-beta` | YES | Beta feature flags |
| `Content-Type` | YES | application/json |
| `User-Agent` | NO | Can be preserved or modified |

**Must forward:** `Authorization`, `anthropic-version`, `anthropic-beta`
**Must NOT add:** `x-api-key` (would conflict with Authorization)

### Anti-Patterns to Avoid

**Anti-pattern 1: Adding x-api-key when Authorization is present**
```go
// WRONG: Both headers causes undefined behavior
r.Out.Header.Set("x-api-key", apiKey)
// Authorization header already present from client
```

Anthropic accepts either `x-api-key` OR `Authorization: Bearer`, not both. If both are sent, `x-api-key` takes precedence, defeating transparent mode.

**Anti-pattern 2: Validating subscription tokens server-side**
```go
// WRONG: Don't try to validate subscription tokens
if !isValidAnthropicToken(token) {
    return error
}
```

The proxy should not validate subscription token content - just forward it. Anthropic's servers validate.

**Anti-pattern 3: Per-request auth mode decisions**
```go
// WRONG: Inconsistent auth mode decisions
if hasClientAuth && hasPooledKeys {
    // Which to use? Ambiguous!
}
```

Auth mode is determined at provider level by config, not per-request.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Subscription token validation | JWT parser, Anthropic token checker | Forward unchanged | Anthropic validates; we can't |
| OAuth refresh flow | Token refresh logic | Rely on Claude Code | Claude Code handles its own auth |
| Client identity tracking | Session management | Just log request metadata | Not our concern in transparent mode |
| Rate limit per-subscription | Custom tracking per client token | Return upstream 429s | Anthropic enforces subscription limits |

**Key insight:** In transparent mode, cc-relay is a dumb pipe for authentication. All auth intelligence stays with the client (Claude Code) and the backend (Anthropic).

---

## Common Pitfalls

### Pitfall 1: Confusing Spoofing with Proxying

**What goes wrong:** Developers think Anthropic blocks ALL proxy use of subscription tokens
**Why it happens:** January 2026 news coverage focused on OpenCode/Cursor being blocked
**How to avoid:** Understand the distinction:
  - Blocked: Third-party apps using OAuth tokens directly
  - Allowed: Claude Code using proxies via `ANTHROPIC_BASE_URL`
**Warning signs:** Assuming "subscription tokens can't be forwarded" without testing

### Pitfall 2: Stripping Headers When Transparent

**What goes wrong:** Proxy strips `Authorization` header even in transparent mode
**Why it happens:** Copy-paste from proxy_auth mode, or defensive "security" coding
**How to avoid:** Explicit `if authMode == "transparent"` branches
**Warning signs:** 401 errors from Anthropic when client has valid subscription

### Pitfall 3: Adding x-api-key Alongside Authorization

**What goes wrong:** Both headers sent, `x-api-key` takes precedence, wrong auth used
**Why it happens:** Provider.Authenticate() called unconditionally
**How to avoid:** Skip Authenticate() entirely in transparent mode
**Warning signs:** Requests billed to proxy's key instead of client's subscription

### Pitfall 4: Not Forwarding anthropic-beta Headers

**What goes wrong:** Claude Code features fail (extended thinking, tool use)
**Why it happens:** Only `Authorization` forwarded, other headers stripped
**How to avoid:** Forward ALL `anthropic-*` headers in transparent mode
**Warning signs:** "beta feature not enabled" errors, missing capabilities

---

## Implementation Requirements

Based on this research, Phase 2.2 should implement:

### AUTH-SUB-01: Add AuthMode to ProviderConfig
- Add `auth_mode` field to ProviderConfig struct
- Add `GetEffectiveAuthMode()` with smart defaults
- Add `IsTransparent()` helper method

### AUTH-SUB-02: Add AuthMode to Provider Interface
- Add `AuthMode() string` to Provider interface
- Update BaseProvider with authMode field
- Add constructors with auth mode parameter

### AUTH-SUB-03: Conditional header handling in handler
- Modify handler.go Rewrite function
- Check `h.provider.AuthMode()` before stripping headers
- Forward Authorization unchanged in transparent mode
- Skip Provider.Authenticate() in transparent mode

### AUTH-SUB-04: Skip KeyPool for transparent mode
- Skip key selection in ServeHTTP for transparent providers
- Skip rate limit tracking in modifyResponse for transparent
- Add validation for client Authorization header (optional)

### AUTH-SUB-05: Update provider factories
- Pass auth mode from config to provider constructors
- Ensure all provider types support auth mode

### DOC-AUTH-01: Documentation updates
- Document smart defaults behavior
- Show minimal config example
- Explain dual-mode setup

---

## Sources

### Primary (HIGH confidence)

- [Claude Code LLM Gateway Docs](https://code.claude.com/docs/en/llm-gateway) - Official proxy/gateway configuration
- [Claude Code Corporate Proxy Docs](https://code.claude.com/docs/en/corporate-proxy) - Enterprise network configuration
- Current codebase: `internal/proxy/handler.go`, `internal/config/config.go`, `internal/providers/`

### Secondary (MEDIUM confidence)

- [LiteLLM Forward Client Headers](https://docs.litellm.ai/docs/proxy/forward_client_headers) - Header forwarding patterns
- [LiteLLM Anthropic Passthrough](https://docs.litellm.ai/docs/pass_through/anthropic_completion) - Transparent proxy implementation

---

## Metadata

**Confidence breakdown:**
- Transparent proxy possibility: HIGH - Verified with official Anthropic LLM Gateway docs
- Header forwarding requirements: HIGH - Documented in official Claude Code docs
- auth_mode implementation: HIGH - Clear architectural pattern, verified against codebase
- Smart defaults: HIGH - Logic is simple and testable
- Dual-mode routing: HIGH - Per-provider config is clean

**Research date:** 2026-01-22
**Valid until:** 2026-02-22 (30 days - monitor for Anthropic policy changes)

## Files to Modify

| File | Change |
|------|--------|
| `internal/config/config.go` | Add AuthMode field, GetEffectiveAuthMode(), IsTransparent() |
| `internal/providers/provider.go` | Add AuthMode() to interface |
| `internal/providers/base.go` | Add authMode field, AuthMode() method, new constructor |
| `internal/providers/anthropic.go` | Add constructor with auth mode |
| `internal/providers/zai.go` | Add constructor with auth mode |
| `internal/proxy/handler.go` | Conditional auth handling in Rewrite and ServeHTTP |
| Provider factory (location TBD) | Pass auth mode from config to providers |
