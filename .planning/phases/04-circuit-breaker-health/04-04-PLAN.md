---
phase: 04-circuit-breaker-health
plan: 04
type: execute
wave: 3
depends_on: ["04-03"]
files_modified:
  - cmd/cc-relay/di/providers.go
  - cmd/cc-relay/di/providers_test.go
  - internal/proxy/handler.go
  - internal/proxy/handler_test.go
autonomous: true

must_haves:
  truths:
    - "HealthTracker is created and registered in DI container"
    - "ProviderInfo.IsHealthy closures are wired from HealthTracker"
    - "Handler reports success/failure to circuit breaker after responses"
    - "X-CC-Relay-Health debug header shows circuit state"
    - "Unhealthy providers are bypassed in routing decisions"
  artifacts:
    - path: "cmd/cc-relay/di/providers.go"
      provides: "HealthTrackerService and HealthCheckerService in DI"
      exports: ["HealthTrackerService", "HealthCheckerService"]
    - path: "internal/proxy/handler.go"
      provides: "Circuit breaker integration in request handling"
      contains: "RecordSuccess|RecordFailure|X-CC-Relay-Health"
  key_links:
    - from: "cmd/cc-relay/di/providers.go"
      to: "internal/health/tracker.go"
      via: "creates HealthTracker"
      pattern: "health\\.NewHealthTracker"
    - from: "cmd/cc-relay/di/providers.go"
      to: "internal/router/router.go"
      via: "wires IsHealthyFunc to ProviderInfo"
      pattern: "tracker\\.IsHealthyFunc"
    - from: "internal/proxy/handler.go"
      to: "internal/health/tracker.go"
      via: "reports success/failure"
      pattern: "tracker\\.RecordSuccess|tracker\\.RecordFailure"
---

<objective>
Integrate the health tracking system with the DI container and proxy handler. Wire HealthTracker into provider setup, report request outcomes to circuit breakers, and add debug headers for visibility.

Purpose: This is the final wiring that makes health tracking operational. After this plan, unhealthy providers will be automatically bypassed and will recover after successful health checks.

Output: Fully integrated health tracking with DI, handler circuit breaker reporting, and debug headers.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-circuit-breaker-health/04-RESEARCH.md
@.planning/phases/04-circuit-breaker-health/04-CONTEXT.md
@.planning/phases/04-circuit-breaker-health/04-01-SUMMARY.md
@.planning/phases/04-circuit-breaker-health/04-02-SUMMARY.md
@.planning/phases/04-circuit-breaker-health/04-03-SUMMARY.md
@cmd/cc-relay/di/providers.go
@internal/proxy/handler.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add HealthTracker and HealthChecker to DI container</name>
  <files>
    cmd/cc-relay/di/providers.go
  </files>
  <action>
Update cmd/cc-relay/di/providers.go:

1. Add imports:
   ```go
   "github.com/omarluq/cc-relay/internal/health"
   ```

2. Add service wrapper types after existing service types:
   ```go
   // HealthTrackerService wraps the health tracker for DI.
   type HealthTrackerService struct {
       Tracker *health.HealthTracker
   }

   // HealthCheckerService wraps the health checker for DI.
   type HealthCheckerService struct {
       Checker *health.HealthChecker
   }
   ```

3. Add NewHealthTracker provider function:
   ```go
   // NewHealthTracker creates the health tracker from configuration.
   func NewHealthTracker(i do.Injector) (*HealthTrackerService, error) {
       cfg := do.MustInvoke[*ConfigService](i).Config
       loggerSvc := do.MustInvoke[*LoggerService](i)

       tracker := health.NewHealthTracker(
           cfg.Health.CircuitBreaker,
           loggerSvc.Logger,
       )
       return &HealthTrackerService{Tracker: tracker}, nil
   }
   ```

4. Add NewHealthChecker provider function:
   ```go
   // NewHealthChecker creates the health checker from configuration.
   func NewHealthChecker(i do.Injector) (*HealthCheckerService, error) {
       cfg := do.MustInvoke[*ConfigService](i).Config
       trackerSvc := do.MustInvoke[*HealthTrackerService](i)
       loggerSvc := do.MustInvoke[*LoggerService](i)

       checker := health.NewHealthChecker(
           trackerSvc.Tracker,
           cfg.Health.HealthCheck,
           loggerSvc.Logger,
       )
       return &HealthCheckerService{Checker: checker}, nil
   }
   ```

5. Update RegisterSingletons to include health services:
   ```go
   do.Provide(i, NewHealthTracker)
   do.Provide(i, NewHealthChecker)
   ```

6. Update NewProxyHandler to wire IsHealthy closures:
   - Get HealthTrackerService from injector
   - Update ProviderInfo creation loop to use tracker.IsHealthyFunc:
   ```go
   trackerSvc := do.MustInvoke[*HealthTrackerService](i)

   // In the provider loop:
   providerInfos = append(providerInfos, router.ProviderInfo{
       Provider:  prov,
       Weight:    provCfg.Pooling.Weight,
       Priority:  provCfg.Pooling.Priority,
       IsHealthy: trackerSvc.Tracker.IsHealthyFunc(provCfg.Name), // Was: func() bool { return true }
   })
   ```

7. Add HealthCheckerService to NewProxyHandler signature if needed for handler integration,
   or create a separate registration step for health checks.

8. Implement ShutdownerWithError for HealthCheckerService:
   ```go
   func (h *HealthCheckerService) Shutdown() error {
       h.Checker.Stop()
       return nil
   }
   ```
  </action>
  <verify>
    - `go build ./cmd/cc-relay/...` passes
    - DI container creates health services without error
  </verify>
  <done>
    - HealthTrackerService registered in DI
    - HealthCheckerService registered in DI with shutdown support
    - ProviderInfo.IsHealthy wired from HealthTracker
    - Stub "return true" replaced with actual circuit breaker closure
  </done>
</task>

<task type="auto">
  <name>Task 2: Update proxy handler to report to circuit breaker</name>
  <files>
    internal/proxy/handler.go
  </files>
  <action>
Update internal/proxy/handler.go:

1. Add import:
   ```go
   "github.com/omarluq/cc-relay/internal/health"
   ```

2. Add healthTracker field to Handler struct:
   ```go
   type Handler struct {
       // ... existing fields ...
       healthTracker *health.HealthTracker  // NEW
   }
   ```

3. Update NewHandler signature to accept HealthTracker:
   ```go
   func NewHandler(
       provider providers.Provider,
       keyPool *keypool.Pool,
       providerInfos []router.ProviderInfo,
       providerRouter router.ProviderRouter,
       routingDebug bool,
       healthTracker *health.HealthTracker,  // NEW
   ) *Handler {
       return &Handler{
           // ... existing fields ...
           healthTracker: healthTracker,
       }
   }
   ```

4. Create helper method to report request outcome:
   ```go
   // reportOutcome records success or failure to the circuit breaker.
   func (h *Handler) reportOutcome(providerName string, statusCode int, err error) {
       if h.healthTracker == nil {
           return // No health tracking configured
       }

       if health.ShouldCountAsFailure(statusCode, err) {
           h.healthTracker.RecordFailure(providerName, err)
       } else {
           h.healthTracker.RecordSuccess(providerName)
       }
   }
   ```

5. In the Rewrite function's modifyResponse callback, report outcome after reading response:
   - After getting response status code, call reportOutcome
   - Find the section where response is processed and add:
   ```go
   // Report to circuit breaker (after response is received)
   h.reportOutcome(selectedProvider.Provider.Name(), resp.StatusCode, nil)
   ```

6. In error handler (if there's one for network errors), report failure:
   ```go
   // In error handling path
   h.reportOutcome(providerName, 0, err)
   ```

7. Add X-CC-Relay-Health debug header:
   - In the section where other debug headers are added (X-CC-Relay-Strategy, X-CC-Relay-Provider)
   - Add after selecting provider:
   ```go
   if h.routingDebug && h.healthTracker != nil {
       state := h.healthTracker.GetState(selectedProviderInfo.Provider.Name())
       w.Header().Set("X-CC-Relay-Health", state.String())
   }
   ```

Note: The state.String() method from gobreaker returns "closed", "open", or "half-open".
  </action>
  <verify>
    - `go build ./internal/proxy/...` passes
    - Handler compiles with health tracker integration
  </verify>
  <done>
    - Handler accepts HealthTracker in constructor
    - reportOutcome helper reports success/failure based on status code
    - X-CC-Relay-Health header added when routing.debug=true
    - Error paths report failures to circuit breaker
  </done>
</task>

<task type="auto">
  <name>Task 3: Update DI and add integration tests</name>
  <files>
    cmd/cc-relay/di/providers.go
    cmd/cc-relay/di/providers_test.go
    internal/proxy/handler_test.go
  </files>
  <action>
1. Update NewProxyHandler in providers.go to pass HealthTracker to handler:
   ```go
   func NewProxyHandler(i do.Injector) (*HandlerService, error) {
       // ... existing code to get config, router, providers ...
       trackerSvc := do.MustInvoke[*HealthTrackerService](i)

       // ... existing code to build providerInfos ...

       handler := proxy.NewHandler(
           defaultProvider,
           pool,
           providerInfos,
           routerSvc.Router,
           cfg.Routing.IsDebugEnabled(),
           trackerSvc.Tracker,  // NEW parameter
       )
       return &HandlerService{Handler: handler}, nil
   }
   ```

2. Update providers_test.go with tests:
   - TestHealthTrackerService_Creation
   - TestHealthCheckerService_Creation
   - TestHealthCheckerService_Shutdown
   - TestNewProxyHandler_WithHealthTracker

3. Update handler_test.go with tests:
   - TestHandler_ReportOutcome_Success
   - TestHandler_ReportOutcome_Failure_5xx
   - TestHandler_ReportOutcome_Failure_429
   - TestHandler_ReportOutcome_4xx_NotFailure
   - TestHandler_DebugHeader_Health

4. Add integration test verifying full flow:
   - Create handler with health tracker
   - Simulate provider returning 500 multiple times
   - Verify circuit opens (provider becomes unhealthy)
   - Verify subsequent requests skip unhealthy provider
  </action>
  <verify>
    - `go build ./...` passes
    - `go test -v -race ./cmd/cc-relay/di/...` passes
    - `go test -v -race ./internal/proxy/...` passes
    - `task ci` passes
  </verify>
  <done>
    - NewProxyHandler passes HealthTracker to handler
    - All existing tests updated and passing
    - New tests verify health integration
    - Full CI passes
  </done>
</task>

</tasks>

<verification>
```bash
# All must pass
go build ./...
go test -v -race ./cmd/cc-relay/di/...
go test -v -race ./internal/proxy/...
go test -v -race ./internal/health/...
task ci

# Verify wiring
grep -E "HealthTrackerService|NewHealthTracker|healthTracker" cmd/cc-relay/di/providers.go
grep -E "X-CC-Relay-Health|reportOutcome" internal/proxy/handler.go
```
</verification>

<success_criteria>
1. HealthTrackerService and HealthCheckerService in DI container
2. ProviderInfo.IsHealthy wired from HealthTracker (not stub)
3. Handler reports success/failure to circuit breaker after each request
4. 5xx and 429 responses count as failures; 4xx (except 429) do not
5. X-CC-Relay-Health debug header shows circuit state
6. HealthChecker has graceful shutdown via DI
7. All tests pass including new integration tests
8. Full CI passes (task ci)
</success_criteria>

<output>
After completion, create `.planning/phases/04-circuit-breaker-health/04-04-SUMMARY.md`
</output>
