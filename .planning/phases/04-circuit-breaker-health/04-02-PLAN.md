---
phase: 04-circuit-breaker-health
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/health/circuit.go
  - internal/health/circuit_test.go
  - internal/health/tracker.go
  - internal/health/tracker_test.go
autonomous: true

must_haves:
  truths:
    - "Circuit breaker transitions from CLOSED to OPEN after consecutive failures"
    - "Circuit breaker transitions from OPEN to HALF-OPEN after cooldown"
    - "Circuit breaker transitions from HALF-OPEN to CLOSED after successful probes"
    - "IsHealthyFunc returns closure that reflects circuit state"
    - "4xx errors (except 429) do not count as failures"
    - "Context cancellation does not count as failure"
  artifacts:
    - path: "internal/health/circuit.go"
      provides: "CircuitBreaker wrapper around gobreaker"
      exports: ["CircuitBreaker", "NewCircuitBreaker"]
    - path: "internal/health/tracker.go"
      provides: "HealthTracker managing per-provider circuits"
      exports: ["HealthTracker", "NewHealthTracker", "IsHealthyFunc"]
  key_links:
    - from: "internal/health/tracker.go"
      to: "internal/health/circuit.go"
      via: "uses CircuitBreaker"
      pattern: "NewCircuitBreaker"
    - from: "internal/health/tracker.go"
      to: "gobreaker.TwoStepCircuitBreaker"
      via: "wraps gobreaker"
      pattern: "gobreaker\\.TwoStepCircuitBreaker"
---

<objective>
Implement the circuit breaker state machine using sony/gobreaker TwoStepCircuitBreaker and create the HealthTracker that manages per-provider circuit breakers.

Purpose: The circuit breaker prevents cascading failures by tracking provider health. The HealthTracker provides the IsHealthyFunc closure that integrates with the router's FilterHealthy function.

Output: Fully functional circuit breaker implementation with state transitions (CLOSED/OPEN/HALF-OPEN) and per-provider tracking.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-circuit-breaker-health/04-RESEARCH.md
@.planning/phases/04-circuit-breaker-health/04-CONTEXT.md
@internal/router/router.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CircuitBreaker wrapper using gobreaker TwoStepCircuitBreaker</name>
  <files>
    internal/health/circuit.go
    internal/health/circuit_test.go
  </files>
  <action>
Create internal/health/circuit.go:

1. Package doc explaining circuit breaker purpose and states (CLOSED/OPEN/HALF-OPEN)

2. State type aliases from gobreaker for external use:
   ```go
   type State = gobreaker.State
   const (
       StateClosed   = gobreaker.StateClosed
       StateOpen     = gobreaker.StateOpen
       StateHalfOpen = gobreaker.StateHalfOpen
   )
   ```

3. CircuitBreaker struct wrapping TwoStepCircuitBreaker:
   ```go
   type CircuitBreaker struct {
       cb   *gobreaker.TwoStepCircuitBreaker[struct{}]
       name string
   }
   ```

4. NewCircuitBreaker constructor:
   - Parameters: name string, cfg CircuitBreakerConfig, logger *zerolog.Logger
   - Creates gobreaker.Settings with:
     - Name: name
     - MaxRequests: uint32(cfg.GetHalfOpenProbes())
     - Timeout: cfg.GetOpenDuration()
     - ReadyToTrip: consecutive failures >= threshold
     - OnStateChange: log state transitions (WARN for opening, INFO for closing)
     - IsSuccessful: returns true for nil error OR context.Canceled (per RESEARCH.md pitfall 1)
   - Returns *CircuitBreaker

5. CircuitBreaker methods:
   - Allow() (done func(err error), err error) - wraps cb.Allow(), returns ErrCircuitOpen if open
   - State() State - returns current state
   - Name() string - returns breaker name
   - ReportSuccess() - shorthand for Allow() then done(nil)
   - ReportFailure(err error) - shorthand for Allow() then done(err)

6. Helper for evaluating HTTP response (will be used by handler):
   ```go
   // ShouldCountAsFailure returns true if the status code should count as a circuit breaker failure.
   // Per CONTEXT.md: 5xx + 429 + timeouts + connection errors count as failures.
   // 4xx (except 429) are client errors and do NOT count as provider health problems.
   func ShouldCountAsFailure(statusCode int, err error) bool {
       if err != nil {
           // Network/timeout errors are failures (unless context canceled)
           return !errors.Is(err, context.Canceled)
       }
       // 5xx server errors and 429 rate limits indicate provider issues
       return statusCode >= 500 || statusCode == 429
   }
   ```

Create internal/health/circuit_test.go with tests:
- TestNewCircuitBreaker_DefaultSettings
- TestCircuitBreaker_AllowWhenClosed
- TestCircuitBreaker_OpensAfterThresholdFailures
- TestCircuitBreaker_TransitionsToHalfOpenAfterTimeout (may need time manipulation or short timeout)
- TestCircuitBreaker_ClosesAfterSuccessfulProbes
- TestCircuitBreaker_ContextCanceledNotFailure
- TestShouldCountAsFailure (table-driven for various status codes and errors)
  </action>
  <verify>
    - `go build ./internal/health/...` passes
    - `go test -v ./internal/health/...` passes all circuit tests
  </verify>
  <done>
    - internal/health/circuit.go exists with CircuitBreaker and all methods
    - ShouldCountAsFailure helper exists
    - Tests verify state transitions work correctly
    - Context cancellation does not open circuit
  </done>
</task>

<task type="auto">
  <name>Task 2: Create HealthTracker managing per-provider circuit breakers</name>
  <files>
    internal/health/tracker.go
    internal/health/tracker_test.go
  </files>
  <action>
Create internal/health/tracker.go:

1. HealthTracker struct:
   ```go
   type HealthTracker struct {
       circuits map[string]*CircuitBreaker
       config   CircuitBreakerConfig
       logger   *zerolog.Logger
       mu       sync.RWMutex
   }
   ```

2. NewHealthTracker constructor:
   - Parameters: cfg CircuitBreakerConfig, logger *zerolog.Logger
   - Initializes empty circuits map
   - Stores config and logger

3. HealthTracker methods:
   - GetOrCreateCircuit(providerName string) *CircuitBreaker:
     - Uses RWMutex for thread-safe access
     - Creates circuit on first access (lazy initialization)
     - Returns existing circuit if already created

   - IsHealthyFunc(providerName string) func() bool:
     - Returns a closure that checks if provider is healthy
     - Provider is healthy if circuit is CLOSED or HALF-OPEN (allow probes)
     - Provider is unhealthy only if circuit is OPEN
     - This closure is what gets wired into ProviderInfo.IsHealthy

   - GetState(providerName string) State:
     - Returns current state of provider's circuit
     - Returns StateClosed if no circuit exists (healthy by default)

   - RecordSuccess(providerName string):
     - Gets circuit and reports success
     - Logs at DEBUG level

   - RecordFailure(providerName string, err error):
     - Gets circuit and reports failure
     - Logs at DEBUG level with error

   - AllStates() map[string]State:
     - Returns snapshot of all provider states
     - Useful for debugging/monitoring

4. Thread-safety considerations:
   - Use sync.RWMutex (mu field)
   - Read lock for GetState, IsHealthyFunc closures
   - Write lock for GetOrCreateCircuit (only when creating)

Create internal/health/tracker_test.go with tests:
- TestNewHealthTracker
- TestHealthTracker_GetOrCreateCircuit_CreatesOnDemand
- TestHealthTracker_GetOrCreateCircuit_ReturnsSame
- TestHealthTracker_IsHealthyFunc_ReturnsTrueWhenClosed
- TestHealthTracker_IsHealthyFunc_ReturnsFalseWhenOpen
- TestHealthTracker_IsHealthyFunc_ReturnsTrueWhenHalfOpen (allows probes)
- TestHealthTracker_RecordSuccess
- TestHealthTracker_RecordFailure
- TestHealthTracker_AllStates
- TestHealthTracker_ConcurrentAccess (parallel goroutines with -race flag)
  </action>
  <verify>
    - `go build ./internal/health/...` passes
    - `go test -v -race ./internal/health/...` passes all tests
    - `go test -cover ./internal/health/...` shows >80% coverage
  </verify>
  <done>
    - internal/health/tracker.go exists with HealthTracker
    - IsHealthyFunc returns closure suitable for ProviderInfo.IsHealthy
    - Thread-safe operations verified with -race flag
    - Coverage >80%
  </done>
</task>

</tasks>

<verification>
```bash
# All must pass
go build ./internal/health/...
go test -v -race ./internal/health/...
go test -cover ./internal/health/...

# Verify key exports exist
grep -E "func NewCircuitBreaker|func NewHealthTracker|func.*IsHealthyFunc" internal/health/*.go
```
</verification>

<success_criteria>
1. CircuitBreaker wraps gobreaker.TwoStepCircuitBreaker with proper settings
2. State transitions work: CLOSED -> OPEN after failures, OPEN -> HALF-OPEN after timeout
3. Context cancellation does NOT count as failure (per IsSuccessful callback)
4. ShouldCountAsFailure correctly identifies 5xx/429 as failures, 4xx as non-failures
5. HealthTracker manages per-provider circuits with lazy initialization
6. IsHealthyFunc returns closure matching ProviderInfo.IsHealthy signature
7. Thread-safe operations verified with -race flag
8. Test coverage >80%
</success_criteria>

<output>
After completion, create `.planning/phases/04-circuit-breaker-health/04-02-SUMMARY.md`
</output>
