---
phase: 04-circuit-breaker-health
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - internal/health/checker.go
  - internal/health/checker_test.go
autonomous: true

must_haves:
  truths:
    - "Health checker performs periodic checks during OPEN state"
    - "Successful health check accelerates recovery to HALF-OPEN"
    - "Health checks use lightweight provider validation (not user traffic)"
    - "Health check interval is configurable with jitter to prevent thundering herd"
  artifacts:
    - path: "internal/health/checker.go"
      provides: "HealthChecker with periodic synthetic health checks"
      exports: ["HealthChecker", "NewHealthChecker", "ProviderHealthCheck"]
  key_links:
    - from: "internal/health/checker.go"
      to: "internal/health/tracker.go"
      via: "uses HealthTracker for circuit state"
      pattern: "tracker\\.GetState|tracker\\.RecordSuccess"
---

<objective>
Implement periodic health checking that runs synthetic health checks during OPEN state to detect provider recovery faster than waiting for full cooldown.

Purpose: When a provider's circuit is OPEN, we want to detect recovery quickly rather than waiting the full 30s cooldown. Periodic health checks (every 10s) probe the provider and accelerate recovery.

Output: HealthChecker that monitors OPEN circuits and runs provider-specific health checks, enabling faster recovery for transient failures.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-circuit-breaker-health/04-RESEARCH.md
@.planning/phases/04-circuit-breaker-health/04-CONTEXT.md
@internal/providers/base.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProviderHealthCheck interface and implementations</name>
  <files>
    internal/health/checker.go
  </files>
  <action>
Create internal/health/checker.go:

1. Package doc explaining health checking purpose:
   - Synthetic health checks during OPEN state
   - Faster recovery than waiting for full cooldown
   - Provider-specific implementations

2. ProviderHealthCheck interface:
   ```go
   // ProviderHealthCheck defines how to check if a provider is healthy.
   // Implementations should be lightweight and fast (not full API calls).
   type ProviderHealthCheck interface {
       // Check performs a health check against the provider.
       // Returns nil if healthy, error if unhealthy.
       Check(ctx context.Context) error

       // ProviderName returns the name of the provider being checked.
       ProviderName() string
   }
   ```

3. HTTPHealthCheck - generic HTTP-based health check:
   ```go
   // HTTPHealthCheck performs health checks via HTTP request.
   // Used for providers with health endpoints or simple API validation.
   type HTTPHealthCheck struct {
       name      string
       url       string        // Health check URL
       client    *http.Client  // HTTP client with timeout
       method    string        // GET, POST, HEAD
       expectOK  bool          // If true, expects 2xx response
   }

   func NewHTTPHealthCheck(name, url string, client *http.Client) *HTTPHealthCheck {
       return &HTTPHealthCheck{
           name:     name,
           url:      url,
           client:   client,
           method:   http.MethodGet,
           expectOK: true,
       }
   }

   func (h *HTTPHealthCheck) Check(ctx context.Context) error {
       req, err := http.NewRequestWithContext(ctx, h.method, h.url, nil)
       if err != nil {
           return fmt.Errorf("create request: %w", err)
       }
       resp, err := h.client.Do(req)
       if err != nil {
           return fmt.Errorf("health check request: %w", err)
       }
       defer resp.Body.Close()

       if h.expectOK && (resp.StatusCode < 200 || resp.StatusCode >= 300) {
           return fmt.Errorf("unhealthy status: %d", resp.StatusCode)
       }
       return nil
   }

   func (h *HTTPHealthCheck) ProviderName() string {
       return h.name
   }
   ```

4. NoOpHealthCheck - for providers without health endpoints:
   ```go
   // NoOpHealthCheck always returns healthy.
   // Used when no health check endpoint is available.
   type NoOpHealthCheck struct {
       name string
   }

   func NewNoOpHealthCheck(name string) *NoOpHealthCheck {
       return &NoOpHealthCheck{name: name}
   }

   func (n *NoOpHealthCheck) Check(ctx context.Context) error {
       return nil // Always healthy
   }

   func (n *NoOpHealthCheck) ProviderName() string {
       return n.name
   }
   ```

5. Helper to create appropriate health check for provider type:
   ```go
   // NewProviderHealthCheck creates a health check appropriate for the provider.
   // Uses provider's base URL to construct health check endpoint.
   func NewProviderHealthCheck(name, baseURL string, client *http.Client) ProviderHealthCheck {
       // For now, use simple GET to base URL as connectivity check
       // Future: Provider-specific endpoints (e.g., /api/tags for Ollama)
       return NewHTTPHealthCheck(name, baseURL, client)
   }
   ```
  </action>
  <verify>
    - `go build ./internal/health/...` passes
    - Interfaces and structs compile correctly
  </verify>
  <done>
    - ProviderHealthCheck interface defined
    - HTTPHealthCheck implementation exists
    - NoOpHealthCheck implementation exists
    - NewProviderHealthCheck factory exists
  </done>
</task>

<task type="auto">
  <name>Task 2: Create HealthChecker with periodic monitoring</name>
  <files>
    internal/health/checker.go
  </files>
  <action>
Add to internal/health/checker.go:

1. HealthChecker struct:
   ```go
   // HealthChecker monitors provider health and triggers recovery checks.
   type HealthChecker struct {
       tracker  *HealthTracker
       config   HealthCheckConfig
       checks   map[string]ProviderHealthCheck
       logger   *zerolog.Logger
       mu       sync.RWMutex
       ctx      context.Context
       cancel   context.CancelFunc
       wg       sync.WaitGroup
   }
   ```

2. NewHealthChecker constructor:
   ```go
   func NewHealthChecker(tracker *HealthTracker, cfg HealthCheckConfig, logger *zerolog.Logger) *HealthChecker {
       ctx, cancel := context.WithCancel(context.Background())
       return &HealthChecker{
           tracker: tracker,
           config:  cfg,
           checks:  make(map[string]ProviderHealthCheck),
           logger:  logger,
           ctx:     ctx,
           cancel:  cancel,
       }
   }
   ```

3. RegisterProvider method:
   ```go
   // RegisterProvider adds a health check for a provider.
   func (h *HealthChecker) RegisterProvider(check ProviderHealthCheck) {
       h.mu.Lock()
       defer h.mu.Unlock()
       h.checks[check.ProviderName()] = check
   }
   ```

4. Start method - begins periodic health checking:
   ```go
   // Start begins periodic health checking for all registered providers.
   // Should be called once after all providers are registered.
   func (h *HealthChecker) Start() {
       if !h.config.IsEnabled() {
           h.logger.Info().Msg("health checker disabled")
           return
       }

       interval := h.config.GetInterval()
       // Add jitter (0-2s) to prevent thundering herd (per RESEARCH.md pitfall 6)
       jitter := time.Duration(rand.Int63n(int64(2 * time.Second)))
       ticker := time.NewTicker(interval + jitter)

       h.wg.Add(1)
       go func() {
           defer h.wg.Done()
           defer ticker.Stop()

           h.logger.Info().
               Dur("interval", interval).
               Msg("health checker started")

           for {
               select {
               case <-h.ctx.Done():
                   h.logger.Info().Msg("health checker stopped")
                   return
               case <-ticker.C:
                   h.checkAllProviders()
               }
           }
       }()
   }
   ```

5. Stop method - graceful shutdown:
   ```go
   // Stop stops the health checker and waits for goroutine to finish.
   func (h *HealthChecker) Stop() {
       h.cancel()
       h.wg.Wait()
   }
   ```

6. Internal method to check all providers:
   ```go
   func (h *HealthChecker) checkAllProviders() {
       h.mu.RLock()
       checks := make([]ProviderHealthCheck, 0, len(h.checks))
       for _, check := range h.checks {
           checks = append(checks, check)
       }
       h.mu.RUnlock()

       for _, check := range checks {
           name := check.ProviderName()
           state := h.tracker.GetState(name)

           // Only check providers with OPEN circuits
           if state != StateOpen {
               continue
           }

           // Run health check with timeout
           ctx, cancel := context.WithTimeout(h.ctx, 5*time.Second)
           err := check.Check(ctx)
           cancel()

           if err != nil {
               h.logger.Debug().
                   Str("provider", name).
                   Err(err).
                   Msg("health check failed")
               continue
           }

           // Successful health check - record success to help circuit transition
           h.logger.Info().
               Str("provider", name).
               Msg("health check succeeded, recording success")
           h.tracker.RecordSuccess(name)
       }
   }
   ```
  </action>
  <verify>
    - `go build ./internal/health/...` passes
    - HealthChecker compiles with all methods
  </verify>
  <done>
    - HealthChecker struct with Start/Stop lifecycle
    - Periodic checking with configurable interval
    - Jitter added to prevent thundering herd
    - Only checks providers with OPEN circuits
  </done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive tests for health checker</name>
  <files>
    internal/health/checker_test.go
  </files>
  <action>
Create internal/health/checker_test.go:

1. TestHTTPHealthCheck_Success:
   - Use httptest.Server returning 200
   - Verify Check returns nil

2. TestHTTPHealthCheck_Failure:
   - Use httptest.Server returning 500
   - Verify Check returns error

3. TestHTTPHealthCheck_Timeout:
   - Use httptest.Server with delay
   - Use context with short timeout
   - Verify Check returns error

4. TestNoOpHealthCheck_AlwaysHealthy:
   - Verify Check always returns nil

5. TestNewProviderHealthCheck:
   - Verify returns HTTPHealthCheck

6. TestHealthChecker_RegisterProvider:
   - Register multiple providers
   - Verify all registered

7. TestHealthChecker_ChecksOnlyOpenCircuits:
   - Create tracker with one CLOSED and one OPEN circuit
   - Use mock health checks that record calls
   - Run checkAllProviders()
   - Verify only OPEN circuit was checked

8. TestHealthChecker_RecordsSuccessOnHealthyCheck:
   - Create tracker with OPEN circuit
   - Use mock health check returning nil
   - Run checkAllProviders()
   - Verify tracker.RecordSuccess was called

9. TestHealthChecker_StartStop:
   - Start checker with short interval (100ms)
   - Wait for at least one check cycle
   - Stop checker
   - Verify goroutine exits cleanly

10. TestHealthChecker_DisabledDoesNotStart:
    - Create checker with Enabled: false
    - Call Start()
    - Verify no goroutine started

Use testify/assert for assertions if available, or standard testing.
  </action>
  <verify>
    - `go test -v -race ./internal/health/...` passes all tests
    - `go test -cover ./internal/health/...` shows >80% coverage
  </verify>
  <done>
    - All health checker tests pass
    - Tests verify OPEN-only checking behavior
    - Tests verify Start/Stop lifecycle
    - Coverage >80%
  </done>
</task>

</tasks>

<verification>
```bash
# All must pass
go build ./internal/health/...
go test -v -race ./internal/health/...
go test -cover ./internal/health/...

# Verify key exports
grep -E "type HealthChecker|func NewHealthChecker|type ProviderHealthCheck" internal/health/checker.go
```
</verification>

<success_criteria>
1. ProviderHealthCheck interface defined for pluggable health checks
2. HTTPHealthCheck performs HTTP-based health verification
3. NoOpHealthCheck available for providers without health endpoints
4. HealthChecker runs periodic checks with configurable interval
5. Jitter prevents thundering herd across instances
6. Only OPEN circuits are checked (not CLOSED or HALF-OPEN)
7. Successful health check records success to accelerate recovery
8. Start/Stop lifecycle with graceful shutdown
9. All tests pass with -race flag
10. Coverage >80%
</success_criteria>

<output>
After completion, create `.planning/phases/04-circuit-breaker-health/04-03-SUMMARY.md`
</output>
