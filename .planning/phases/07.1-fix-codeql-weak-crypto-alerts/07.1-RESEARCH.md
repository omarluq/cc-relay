# Phase 07.1: Fix CodeQL Weak Crypto Alerts - Research

**Researched:** 2026-01-26
**Domain:** Cryptographic hashing for API keys in Go
**Confidence:** HIGH

## Summary

CodeQL is flagging 3 alerts for `go/weak-sensitive-data-hashing` (CWE-327, CWE-328, CWE-916) in the cc-relay codebase. The alerts flag SHA-256 usage as "insecure for password hashing" because SHA-256 is not computationally expensive. However, this is a nuanced issue:

1. **The code already uses SHA-256** - not MD5 or SHA1 as the phase description implied
2. **API keys are NOT passwords** - they are high-entropy random secrets, not user-memorized strings
3. **The alerts are technically correct but may be false positives** for this use case

The research reveals two valid resolution approaches:
- **Option A (Recommended):** Add HMAC-SHA256 with application-level secret (maintains performance, satisfies CodeQL)
- **Option B:** Use bcrypt/argon2 (cryptographically stronger but impacts performance for high-throughput API key validation)

**Primary recommendation:** Use HMAC-SHA256 for API key comparison (alerts 1 & 3) and keep SHA-256 for key ID generation (alert 2) - the key ID is for logging/tracking, not security comparison.

## Alert Analysis

### CodeQL Alerts (from GitHub API)

| Alert # | File | Line | Use Case | Real Risk |
|---------|------|------|----------|-----------|
| 1 | `internal/auth/apikey.go` | 22 | API key hash for comparison | LOW - high-entropy input |
| 2 | `internal/keypool/key.go` | 71 | Key ID generation for logging | NONE - not security critical |
| 3 | `internal/proxy/middleware.go` | 23 | API key hash for middleware auth | LOW - high-entropy input |

### Why SHA-256 Triggers the Alert

CodeQL classifies API keys as "passwords" and flags fast hashes. From the alert:
> "Sensitive data (password) is used in a hashing algorithm (SHA256) that is insecure for password hashing, since it is not a computationally expensive hash function."

### Why API Keys Differ from Passwords

| Property | Passwords | API Keys |
|----------|-----------|----------|
| Entropy | Low (human-memorable) | High (randomly generated) |
| Length | 8-20 characters typically | 32-64+ characters |
| Brute-force risk | HIGH (limited keyspace) | MINIMAL (2^256 combinations) |
| Performance needs | 1-10 hashes/sec acceptable | 1000+ hashes/sec required |

**Industry consensus:** For high-entropy API keys, salted SHA-256 or HMAC-SHA256 is appropriate. The security comes from key entropy, not hash slowness.

## Standard Stack

### Core

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| `crypto/sha256` | stdlib | Fast hashing for high-entropy secrets | Already in use, adequate for API keys |
| `crypto/hmac` | stdlib | HMAC construction for keyed hashing | Provides additional protection via app secret |
| `crypto/subtle` | stdlib | Constant-time comparison | Prevents timing attacks (already used) |

### Supporting (If bcrypt/argon2 chosen)

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| `golang.org/x/crypto/bcrypt` | v0.47.0 | Password hashing | If treating API keys as passwords |
| `golang.org/x/crypto/argon2` | v0.47.0 | Modern password hashing | If maximum security needed |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| HMAC-SHA256 | bcrypt | 1000x slower but CodeQL-safe |
| HMAC-SHA256 | argon2 | Memory-hard, even slower, most secure |
| SHA-256 | BLAKE2b | Faster, but no CodeQL benefit |

**Already available:** `golang.org/x/crypto v0.47.0` is in go.mod (indirect dependency)

## Architecture Patterns

### Current Implementation (Lines from codebase)

```go
// internal/auth/apikey.go:20-24
func NewAPIKeyAuthenticator(expectedKey string) *APIKeyAuthenticator {
    return &APIKeyAuthenticator{
        expectedHash: sha256.Sum256([]byte(expectedKey)),
    }
}

// internal/keypool/key.go:69-72
func NewKeyMetadata(apiKey string, rpm, itpm, otpm int) *KeyMetadata {
    hash := sha256.Sum256([]byte(apiKey))
    id := hex.EncodeToString(hash[:])[:8]
    // ...
}

// internal/proxy/middleware.go:21-23
func AuthMiddleware(expectedAPIKey string) func(http.Handler) http.Handler {
    expectedHash := sha256.Sum256([]byte(expectedAPIKey))
    // ...
}
```

### Pattern 1: HMAC-SHA256 for API Key Comparison (Recommended)

**What:** Use HMAC with an application-level secret key instead of plain SHA-256
**When to use:** API key validation where performance matters
**Why it satisfies CodeQL:** HMAC is a keyed hash, not classified as "weak"

```go
// Source: Go standard library best practices
import (
    "crypto/hmac"
    "crypto/sha256"
    "crypto/subtle"
)

// Application-level secret (from config or environment)
var appSecret = []byte(os.Getenv("CC_RELAY_AUTH_SECRET"))

func computeKeyMAC(apiKey string, secret []byte) []byte {
    mac := hmac.New(sha256.New, secret)
    mac.Write([]byte(apiKey))
    return mac.Sum(nil)
}

func validateAPIKey(provided, expected string, secret []byte) bool {
    providedMAC := computeKeyMAC(provided, secret)
    expectedMAC := computeKeyMAC(expected, secret)
    return hmac.Equal(providedMAC, expectedMAC) // Constant-time comparison built-in
}
```

### Pattern 2: bcrypt for Maximum Security (Alternative)

**What:** Use bcrypt for password-style hashing
**When to use:** When CodeQL compliance is paramount regardless of performance
**Trade-off:** ~1000x slower than SHA-256

```go
// Source: golang.org/x/crypto/bcrypt package
import "golang.org/x/crypto/bcrypt"

func hashAPIKey(key string) ([]byte, error) {
    return bcrypt.GenerateFromPassword([]byte(key), bcrypt.DefaultCost)
}

func validateAPIKey(provided string, hash []byte) bool {
    return bcrypt.CompareHashAndPassword(hash, []byte(provided)) == nil
}
```

### Pattern 3: Keep SHA-256 for Key ID (Non-Security Use)

**What:** Continue using SHA-256 for generating logging/tracking IDs
**When to use:** The key ID is NOT for security comparison, just identification
**Resolution:** Add CodeQL suppression annotation or restructure to avoid alert

```go
// internal/keypool/key.go - Key ID is for logging, not security
// The first 8 chars of SHA-256 hash is adequate for non-sensitive identification
func generateKeyID(apiKey string) string {
    // This is NOT a security comparison - just a stable identifier for logs
    hash := sha256.Sum256([]byte(apiKey))
    return hex.EncodeToString(hash[:])[:8]
}
```

### Anti-Patterns to Avoid

- **Using bcrypt for every request:** Performance disaster (10-100ms per hash vs <1us for SHA-256)
- **Removing constant-time comparison:** Opens timing attack vector
- **Sharing the HMAC secret across deployments:** Defeats the purpose of keyed hashing

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Constant-time comparison | Custom loop | `subtle.ConstantTimeCompare` or `hmac.Equal` | Timing attacks are subtle |
| HMAC construction | Manual concat+hash | `crypto/hmac.New(sha256.New, key)` | RFC 2104 compliance |
| bcrypt salt/cost | Manual salting | `bcrypt.GenerateFromPassword` | Salt management is error-prone |

**Key insight:** The stdlib `crypto/hmac` and `crypto/subtle` packages handle timing-safe operations correctly. Never implement custom comparison logic.

## Common Pitfalls

### Pitfall 1: Treating API Keys Like Passwords

**What goes wrong:** Using bcrypt/argon2 with high cost factors for API key validation
**Why it happens:** CodeQL alert sounds scary, developers over-correct
**How to avoid:** Understand the threat model - API keys have high entropy, not low
**Warning signs:** Authentication latency > 10ms, CPU-bound auth

### Pitfall 2: Losing Constant-Time Comparison

**What goes wrong:** Switching to `==` or `bytes.Equal` which are not timing-safe
**Why it happens:** Refactoring without understanding security requirements
**How to avoid:** Always use `subtle.ConstantTimeCompare` or `hmac.Equal`
**Warning signs:** Grep for `==` with hash comparisons

### Pitfall 3: Empty or Weak HMAC Secret

**What goes wrong:** Using empty string or predictable value as HMAC secret
**Why it happens:** Rushed implementation, hardcoded for testing
**How to avoid:** Generate cryptographically random secret at deployment
**Warning signs:** HMAC secret in source code, empty environment variable

### Pitfall 4: Breaking Existing Tests

**What goes wrong:** Tests fail after hash algorithm change
**Why it happens:** Tests may use hardcoded expected values
**How to avoid:** Review all tests, update test helpers
**Warning signs:** Test files with hardcoded hashes or expected values

## Code Examples

### HMAC-SHA256 API Key Authenticator

```go
// Source: Standard library pattern
package auth

import (
    "crypto/hmac"
    "crypto/sha256"
    "net/http"
)

type HMACAPIKeyAuthenticator struct {
    expectedMAC []byte
    secret      []byte
}

func NewHMACAPIKeyAuthenticator(expectedKey string, secret []byte) *HMACAPIKeyAuthenticator {
    return &HMACAPIKeyAuthenticator{
        expectedMAC: computeMAC(expectedKey, secret),
        secret:      secret,
    }
}

func computeMAC(data string, secret []byte) []byte {
    mac := hmac.New(sha256.New, secret)
    mac.Write([]byte(data))
    return mac.Sum(nil)
}

func (a *HMACAPIKeyAuthenticator) Validate(r *http.Request) Result {
    providedKey := r.Header.Get("x-api-key")
    if providedKey == "" {
        return Result{Valid: false, Type: TypeAPIKey, Error: "missing x-api-key header"}
    }

    providedMAC := computeMAC(providedKey, a.secret)

    // hmac.Equal is constant-time
    if !hmac.Equal(providedMAC, a.expectedMAC) {
        return Result{Valid: false, Type: TypeAPIKey, Error: "invalid x-api-key"}
    }

    return Result{Valid: true, Type: TypeAPIKey}
}
```

### Configuration for HMAC Secret

```go
// Source: Standard Go config pattern
type AuthConfig struct {
    APIKey     string `yaml:"api_key"`
    HMACSecret string `yaml:"hmac_secret"` // New: application-level secret
}

// Generate secret if not provided
func (c *AuthConfig) GetHMACSecret() []byte {
    if c.HMACSecret == "" {
        // Fall back to a stable derivative (not ideal, but functional)
        return []byte("cc-relay-default-hmac-key")
    }
    return []byte(c.HMACSecret)
}
```

## Resolution Options Analysis

### Option A: HMAC-SHA256 (Recommended)

| Aspect | Assessment |
|--------|------------|
| Performance | Near-identical to current SHA-256 |
| CodeQL | Should satisfy alert (HMAC is keyed) |
| Complexity | Low - minimal code changes |
| Breaking changes | Config may need `hmac_secret` field |
| Test changes | Minimal - update to pass secret |

### Option B: bcrypt

| Aspect | Assessment |
|--------|------------|
| Performance | 1000x slower per validation |
| CodeQL | Definitely satisfies alert |
| Complexity | Medium - hash storage changes |
| Breaking changes | API key storage format changes |
| Test changes | Significant - timing-dependent tests |

### Option C: Dismiss Alerts in GitHub UI

| Aspect | Assessment |
|--------|------------|
| Performance | No change |
| CodeQL | Alerts dismissed, not fixed |
| Complexity | None |
| Breaking changes | None |
| Risk | Audit trail shows dismissed security alerts |

## Recommendation

**Primary:** Use HMAC-SHA256 for alerts 1 and 3 (API key comparison)
- Add `hmac_secret` to config
- Convert `APIKeyAuthenticator` and `AuthMiddleware` to use HMAC
- Maintain `hmac.Equal` for constant-time comparison

**For alert 2 (key ID generation):**
- This is NOT a security comparison - it's for logging/identification
- Options:
  1. Restructure code to make non-security purpose clear (may not help CodeQL)
  2. Add a comment and dismiss in GitHub UI
  3. Use HMAC here too (overkill but consistent)

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| MD5/SHA1 for auth | SHA-256 minimum | 2015+ | MD5/SHA1 deprecated for security |
| Plain SHA-256 | HMAC-SHA256 or slow hashes | 2020+ | CodeQL now flags plain SHA-256 |
| Manual salt | Built-in (bcrypt/argon2) | 2012+ | Salt management errors eliminated |

**Deprecated/outdated:**
- MD5, SHA1 for any security purpose (collision attacks proven)
- Manual salt generation (use library-managed salts)

## Open Questions

1. **CodeQL HMAC recognition**
   - What we know: HMAC is a keyed MAC, not classified as weak hash
   - What's unclear: Will CodeQL specifically recognize HMAC-SHA256 as acceptable?
   - Recommendation: Implement HMAC pattern and re-run CodeQL scan to verify

2. **Performance impact validation**
   - What we know: HMAC adds minimal overhead vs SHA-256
   - What's unclear: Exact latency impact under load
   - Recommendation: Add benchmark tests before/after

3. **Key ID alert resolution**
   - What we know: Key ID is for logging, not security
   - What's unclear: Whether CodeQL tracks data flow accurately enough to dismiss
   - Recommendation: Try HMAC first; if not resolved, dismiss in UI with explanation

## Sources

### Primary (HIGH confidence)

- Go stdlib documentation: `crypto/sha256`, `crypto/hmac`, `crypto/subtle`
- CodeQL alert details from GitHub API (fetched 2026-01-26)
- Codebase inspection: `internal/auth/apikey.go`, `internal/keypool/key.go`, `internal/proxy/middleware.go`

### Secondary (MEDIUM confidence)

- [OWASP Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html) - Confirms API keys differ from passwords
- [Why bcrypt Will Kill Your API Performance](https://cybersierra.co/blog/bcrypt-performance-issues-api/) - Performance analysis of slow hashes for API keys
- [CodeQL 2.23.7 Release Notes](https://github.blog/changelog/2025-12-18-codeql-2-23-7-and-2-23-8-add-security-queries-for-go-and-rust/) - Query origin

### Tertiary (LOW confidence)

- [GitHub CodeQL Issues](https://github.com/github/codeql/issues/16486) - False positive discussion
- [StackShare bcrypt vs sha256](https://stackshare.io/stackups/go-packages-bcrypt-vs-go-packages-sha256) - Community comparison

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - stdlib packages well-documented
- Architecture: HIGH - patterns from Go security best practices
- Pitfalls: HIGH - based on codebase inspection and industry knowledge
- CodeQL behavior: MEDIUM - need to verify HMAC resolves alerts

**Research date:** 2026-01-26
**Valid until:** 2026-02-26 (30 days - stable domain)
