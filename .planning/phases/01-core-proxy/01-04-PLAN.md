---
phase: 01-core-proxy
plan: 04
type: execute
wave: 3
depends_on: ["01-01", "01-02", "01-03"]
files_modified:
  - cmd/cc-relay/main.go
  - internal/proxy/routes.go
autonomous: true

must_haves:
  truths:
    - "CLI serve command starts the proxy server"
    - "Server loads config from default or specified path"
    - "Route /v1/messages is registered and proxies to Anthropic"
    - "Auth middleware is applied to /v1/messages route"
    - "Server shuts down gracefully on SIGINT/SIGTERM"
    - "Missing config file produces clear error message"
    - "Missing provider produces clear error message"
  artifacts:
    - path: "cmd/cc-relay/main.go"
      provides: "CLI entry point with serve command"
      exports: []
    - path: "internal/proxy/routes.go"
      provides: "Route setup for /v1/messages"
      exports: ["SetupRoutes"]
  key_links:
    - from: "cmd/cc-relay/main.go"
      to: "internal/config/loader.go"
      via: "loads configuration"
      pattern: "config\\.Load"
    - from: "cmd/cc-relay/main.go"
      to: "internal/proxy/server.go"
      via: "creates and starts server"
      pattern: "proxy\\.NewServer"
    - from: "internal/proxy/routes.go"
      to: "internal/proxy/handler.go"
      via: "registers handler for /v1/messages"
      pattern: "NewHandler.*v1/messages"
---

<objective>
Wire all components together into a working CLI application that can proxy requests.

Purpose: Create the final integration that connects config loading, provider setup, authentication middleware, and proxy handler into a running server that Claude Code can connect to.

Output: Running `./cc-relay serve` starts a proxy that accepts requests from Claude Code and forwards them to Anthropic with proper SSE streaming.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-proxy/01-RESEARCH.md
@.planning/phases/01-core-proxy/01-01-SUMMARY.md
@.planning/phases/01-core-proxy/01-02-SUMMARY.md
@.planning/phases/01-core-proxy/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Route setup function</name>
  <files>internal/proxy/routes.go</files>
  <action>
Create route setup that wires auth middleware and handler:

**routes.go:**
```go
// SetupRoutes creates the HTTP handler with all routes configured
func SetupRoutes(cfg *config.Config, provider providers.Provider, providerKey string) (http.Handler, error) {
    mux := http.NewServeMux()

    // Create proxy handler
    handler, err := NewHandler(provider, providerKey)
    if err != nil {
        return nil, fmt.Errorf("failed to create handler: %w", err)
    }

    // Apply auth middleware if proxy API key is configured
    // (cfg.Server.APIKey is the key clients must use to access proxy)
    var messagesHandler http.Handler = handler
    if cfg.Server.APIKey != "" {
        messagesHandler = AuthMiddleware(cfg.Server.APIKey)(handler)
    }

    // Register routes
    mux.Handle("POST /v1/messages", messagesHandler)

    // Health check endpoint (no auth required)
    mux.HandleFunc("GET /health", func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
        w.Write([]byte(`{"status":"ok"}`))
    })

    return mux, nil
}
```

Notes:
- Use Go 1.22+ method routing syntax: `"POST /v1/messages"`
- Auth middleware wraps the handler
- Add /health endpoint for health checks (no auth)
- Return error if handler creation fails

Update config structs if needed to include Server.APIKey field for the proxy's incoming auth.
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go build ./internal/proxy/...
```
  </verify>
  <done>SetupRoutes compiles, registers POST /v1/messages with auth middleware, GET /health without auth</done>
</task>

<task type="auto">
  <name>Task 2: CLI main.go with config loading and provider setup</name>
  <files>cmd/cc-relay/main.go</files>
  <action>
Implement the main entry point that loads config and sets up the provider:

**main.go (partial - config and provider setup):**
```go
package main

import (
    "flag"
    "log/slog"
    "os"
    "path/filepath"

    "github.com/omarluq/cc-relay/internal/config"
    "github.com/omarluq/cc-relay/internal/providers"
    "github.com/omarluq/cc-relay/internal/proxy"
)

func main() {
    // Parse flags
    configPath := flag.String("config", "", "path to config file")
    flag.Parse()

    // Setup logging
    logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
    slog.SetDefault(logger)

    // Determine config path
    if *configPath == "" {
        *configPath = findConfigFile()
    }

    // Load config
    cfg, err := config.Load(*configPath)
    if err != nil {
        slog.Error("failed to load config", "error", err, "path", *configPath)
        os.Exit(1)
    }

    // Find first enabled Anthropic provider
    var provider providers.Provider
    var providerKey string
    for _, p := range cfg.Providers {
        if p.Enabled && p.Type == "anthropic" {
            provider = providers.NewAnthropicProvider(p.Name, p.BaseURL)
            if len(p.Keys) > 0 {
                providerKey = p.Keys[0].Key
            }
            break
        }
    }
    if provider == nil {
        slog.Error("no enabled anthropic provider found in config")
        os.Exit(1)
    }

    // Setup routes
    handler, err := proxy.SetupRoutes(cfg, provider, providerKey)
    if err != nil {
        slog.Error("failed to setup routes", "error", err)
        os.Exit(1)
    }

    // Create server (Task 3 will add startup and shutdown)
    server := proxy.NewServer(cfg.Server.Listen, handler)
    _ = server // Used in Task 3
}

func findConfigFile() string {
    // Check current directory
    if _, err := os.Stat("config.yaml"); err == nil {
        return "config.yaml"
    }
    // Check ~/.config/cc-relay/
    home, _ := os.UserHomeDir()
    if home != "" {
        p := filepath.Join(home, ".config", "cc-relay", "config.yaml")
        if _, err := os.Stat(p); err == nil {
            return p
        }
    }
    return "config.yaml" // Default, will error if not found
}
```

Requirements:
- Parse --config flag for custom config path
- Default config locations: ./config.yaml, ~/.config/cc-relay/config.yaml
- Load config and find first enabled anthropic provider
- Clear error messages for: missing config file, missing provider
- Use slog for structured logging
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go build -o cc-relay ./cmd/cc-relay/...
# Test config loading failure (should show clear error)
cd /home/omarluq/sandbox/go/cc-relay && ./cc-relay --config /nonexistent/path.yaml 2>&1 | grep -i "failed to load config"
```
  </verify>
  <done>CLI compiles, config loading works, missing config shows clear error, missing provider shows clear error</done>
</task>

<task type="auto">
  <name>Task 3: Graceful shutdown on SIGINT/SIGTERM</name>
  <files>cmd/cc-relay/main.go</files>
  <action>
Add server startup and graceful shutdown to main.go:

**Add to main.go (after server creation):**
```go
import (
    "context"
    "net/http"
    "os/signal"
    "syscall"
    "time"
)

// ... after server := proxy.NewServer(cfg.Server.Listen, handler)

    // Graceful shutdown on SIGINT/SIGTERM
    done := make(chan struct{})
    go func() {
        sigint := make(chan os.Signal, 1)
        signal.Notify(sigint, os.Interrupt, syscall.SIGTERM)
        <-sigint

        slog.Info("shutting down...")
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()
        server.Shutdown(ctx)
        close(done)
    }()

    // Start server
    slog.Info("starting cc-relay", "listen", cfg.Server.Listen)
    if err := server.ListenAndServe(); err != http.ErrServerClosed {
        slog.Error("server error", "error", err)
        os.Exit(1)
    }

    <-done
    slog.Info("server stopped")
```

Requirements:
- Handle both SIGINT (Ctrl+C) and SIGTERM
- 30 second timeout for graceful shutdown
- Log "shutting down..." when signal received
- Log "server stopped" after clean shutdown
- Exit with code 1 on server error (but not on ErrServerClosed)
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go build -o cc-relay ./cmd/cc-relay/...
# Verify signal handling code exists
grep -n "SIGTERM\|SIGINT\|signal.Notify" /home/omarluq/sandbox/go/cc-relay/cmd/cc-relay/main.go
# Verify shutdown timeout exists
grep -n "WithTimeout.*30" /home/omarluq/sandbox/go/cc-relay/cmd/cc-relay/main.go
```
  </verify>
  <done>Server starts and shuts down gracefully on SIGINT/SIGTERM with 30s timeout</done>
</task>

<task type="auto">
  <name>Task 4: Route tests and yaml dependency</name>
  <files>internal/proxy/routes_test.go</files>
  <action>
Create tests that verify the full startup flow:

**routes_test.go:**
```go
func TestSetupRoutes_CreatesHandler(t *testing.T) {
    cfg := &config.Config{
        Server: config.ServerConfig{
            Listen: "127.0.0.1:0",
            APIKey: "test-key",
        },
    }
    provider := providers.NewAnthropicProvider("test", "https://api.anthropic.com")

    handler, err := SetupRoutes(cfg, provider, "backend-key")
    if err != nil {
        t.Fatalf("SetupRoutes failed: %v", err)
    }
    if handler == nil {
        t.Fatal("handler is nil")
    }
}

func TestSetupRoutes_AuthMiddlewareApplied(t *testing.T) {
    cfg := &config.Config{
        Server: config.ServerConfig{
            APIKey: "test-key",
        },
    }
    provider := providers.NewAnthropicProvider("test", "https://api.anthropic.com")
    handler, _ := SetupRoutes(cfg, provider, "backend-key")

    // Request without API key should return 401
    req := httptest.NewRequest("POST", "/v1/messages", nil)
    rec := httptest.NewRecorder()
    handler.ServeHTTP(rec, req)

    if rec.Code != http.StatusUnauthorized {
        t.Errorf("expected 401, got %d", rec.Code)
    }
}

func TestSetupRoutes_HealthEndpoint(t *testing.T) {
    cfg := &config.Config{}
    provider := providers.NewAnthropicProvider("test", "https://api.anthropic.com")
    handler, _ := SetupRoutes(cfg, provider, "backend-key")

    req := httptest.NewRequest("GET", "/health", nil)
    rec := httptest.NewRecorder()
    handler.ServeHTTP(rec, req)

    if rec.Code != http.StatusOK {
        t.Errorf("expected 200, got %d", rec.Code)
    }
}
```

Also update go.mod to add yaml dependency:
```bash
go get gopkg.in/yaml.v3
```
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go test -v ./internal/proxy/... && go build ./...
```
  </verify>
  <done>Route tests pass, binary builds, server can start with minimal config</done>
</task>

</tasks>

<verification>
```bash
# Build binary
cd /home/omarluq/sandbox/go/cc-relay && go build -o cc-relay ./cmd/cc-relay/...

# Run all tests
cd /home/omarluq/sandbox/go/cc-relay && go test ./...

# Verify binary runs (will fail without config, but should show usage)
cd /home/omarluq/sandbox/go/cc-relay && ./cc-relay --help || true

# Verify config loading error is clear
cd /home/omarluq/sandbox/go/cc-relay && ./cc-relay --config /nonexistent.yaml 2>&1 | grep -i "failed to load"

# Verify signal handling is implemented
grep -c "SIGTERM\|signal.Notify" /home/omarluq/sandbox/go/cc-relay/cmd/cc-relay/main.go
```
</verification>

<success_criteria>
- [ ] SetupRoutes creates handler with POST /v1/messages route
- [ ] SetupRoutes applies AuthMiddleware when Server.APIKey is set
- [ ] GET /health returns 200 without auth
- [ ] main.go parses --config flag
- [ ] main.go finds config in default locations
- [ ] main.go loads config and creates provider
- [ ] Missing config file shows clear error message
- [ ] Missing provider shows clear error message
- [ ] main.go handles SIGINT and SIGTERM signals
- [ ] Graceful shutdown has 30 second timeout
- [ ] `go build ./cmd/cc-relay/...` produces working binary
- [ ] All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-proxy/01-04-SUMMARY.md`
</output>
