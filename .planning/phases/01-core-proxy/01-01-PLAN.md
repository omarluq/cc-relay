---
phase: 01-core-proxy
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/config/config.go
  - internal/config/loader.go
  - internal/providers/provider.go
  - internal/providers/anthropic.go
autonomous: true

must_haves:
  truths:
    - "Config can be loaded from YAML file"
    - "Provider interface defines required methods"
    - "Anthropic provider can authenticate requests"
    - "Anthropic provider can be instantiated from config"
  artifacts:
    - path: "internal/config/config.go"
      provides: "Config structs for server, providers, auth"
      exports: ["Config", "ServerConfig", "ProviderConfig"]
    - path: "internal/config/loader.go"
      provides: "YAML config file loading"
      exports: ["Load", "LoadFromFile"]
    - path: "internal/providers/provider.go"
      provides: "Provider interface definition"
      exports: ["Provider"]
    - path: "internal/providers/anthropic.go"
      provides: "Anthropic provider implementation"
      exports: ["AnthropicProvider", "NewAnthropicProvider"]
  key_links:
    - from: "internal/config/loader.go"
      to: "internal/config/config.go"
      via: "returns Config struct"
      pattern: "func Load.*Config"
    - from: "internal/providers/anthropic.go"
      to: "internal/providers/provider.go"
      via: "implements Provider interface"
      pattern: "type AnthropicProvider.*Provider"
---

<objective>
Create the foundational config loading and provider abstraction layer for cc-relay.

Purpose: Establish the configuration system that loads provider settings from YAML and the provider interface that all backend providers will implement. This is the foundation that the HTTP proxy layer will use.

Output: Working config loader that parses example.yaml format, provider interface, and Anthropic provider that can authenticate and forward requests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-proxy/01-RESEARCH.md
@example.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Config structs and loader</name>
  <files>internal/config/config.go, internal/config/loader.go</files>
  <action>
Create config package with structs matching example.yaml structure (Phase 1 subset):

**config.go:**
- `Config` struct with Server, Providers, Logging fields
- `ServerConfig` struct: Listen (string), TimeoutMS (int), APIKey (string)
  - CRITICAL: Include `APIKey string `yaml:"api_key"`` field - this is the key clients must provide to access the proxy (AUTH-02 requirement)
- `ProviderConfig` struct: Name, Type, Enabled, BaseURL, Keys (slice of KeyConfig), ModelMapping (map)
- `KeyConfig` struct: Key (string), RPMLimit, TPMLimit (ints)
- `LoggingConfig` struct: Level, Format

**loader.go:**
- `Load(path string) (*Config, error)` - loads YAML from file path
- `LoadFromReader(r io.Reader) (*Config, error)` - for testing
- Use `os.ExpandEnv()` on file content before parsing to support `${VAR}` syntax
- Return descriptive errors on parse failures

Use stdlib only (no viper yet): `gopkg.in/yaml.v3` for YAML parsing.

Do NOT include all config sections from example.yaml - only Server, Providers (subset), and Logging for Phase 1.
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go build ./internal/config/...
# Verify APIKey field exists in ServerConfig
grep -n "APIKey" /home/omarluq/sandbox/go/cc-relay/internal/config/config.go
```
  </verify>
  <done>Config structs compile, ServerConfig includes APIKey field, Load function parses example.yaml server/providers/logging sections</done>
</task>

<task type="auto">
  <name>Task 2: Provider interface and Anthropic implementation</name>
  <files>internal/providers/provider.go, internal/providers/anthropic.go</files>
  <action>
Create provider package with interface and Anthropic implementation:

**provider.go:**
```go
// Provider defines the interface for LLM backend providers
type Provider interface {
    // Name returns the provider identifier
    Name() string

    // BaseURL returns the backend API base URL
    BaseURL() string

    // Authenticate adds provider-specific auth to the request
    Authenticate(req *http.Request, key string) error

    // ForwardHeaders returns headers to add when forwarding (including anthropic-* from original)
    ForwardHeaders(originalHeaders http.Header) http.Header

    // SupportsStreaming indicates if provider supports SSE streaming
    SupportsStreaming() bool
}
```

**anthropic.go:**
- `AnthropicProvider` struct with name, baseURL fields
- `NewAnthropicProvider(name, baseURL string) *AnthropicProvider`
- `Authenticate()` sets `x-api-key` header with provided key
- `ForwardHeaders()` copies all `anthropic-*` headers from original, adds Content-Type
- `SupportsStreaming()` returns true
- Default baseURL: `https://api.anthropic.com`

Use stdlib only. Provider is intentionally simple for Phase 1 - it's a passthrough to Anthropic.
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go build ./internal/providers/...
```
  </verify>
  <done>Provider interface defined, AnthropicProvider implements it, builds without errors</done>
</task>

<task type="auto">
  <name>Task 3: Unit tests for config and provider</name>
  <files>internal/config/loader_test.go, internal/providers/anthropic_test.go</files>
  <action>
Create unit tests:

**loader_test.go:**
- TestLoad_ValidYAML: parse minimal valid config, verify struct fields
- TestLoad_EnvironmentExpansion: test `${VAR}` expansion works
- TestLoad_InvalidYAML: verify descriptive error on malformed YAML
- TestLoad_MissingFile: verify descriptive error for nonexistent file
- TestLoad_ServerAPIKey: verify APIKey field is parsed from yaml `api_key`

**anthropic_test.go:**
- TestNewAnthropicProvider: verify default baseURL
- TestAuthenticate: verify x-api-key header set correctly
- TestForwardHeaders: verify anthropic-* headers forwarded, others ignored
- TestSupportsStreaming: verify returns true

Keep tests simple and focused. Use table-driven tests where appropriate.
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go test -v ./internal/config/... ./internal/providers/...
# Verify test files have actual test functions (not empty stubs)
grep -c "func Test" /home/omarluq/sandbox/go/cc-relay/internal/config/loader_test.go
grep -c "func Test" /home/omarluq/sandbox/go/cc-relay/internal/providers/anthropic_test.go
# Both should return >= 4 (indicating real tests exist)
```
  </verify>
  <done>All unit tests pass, loader_test.go has >= 4 test functions, anthropic_test.go has >= 4 test functions, coverage for config loading and provider authentication</done>
</task>

</tasks>

<verification>
```bash
# All packages build
cd /home/omarluq/sandbox/go/cc-relay && go build ./...

# All tests pass
cd /home/omarluq/sandbox/go/cc-relay && go test ./internal/config/... ./internal/providers/...

# Verify ServerConfig has APIKey field
grep -n "APIKey.*string.*yaml:.*api_key" /home/omarluq/sandbox/go/cc-relay/internal/config/config.go

# Verify test files have real tests (not stubs)
test $(grep -c "func Test" /home/omarluq/sandbox/go/cc-relay/internal/config/loader_test.go) -ge 4
test $(grep -c "func Test" /home/omarluq/sandbox/go/cc-relay/internal/providers/anthropic_test.go) -ge 4
```
</verification>

<success_criteria>
- [ ] Config structs defined matching example.yaml structure (Phase 1 subset)
- [ ] ServerConfig includes APIKey field with yaml tag "api_key"
- [ ] YAML loader parses config with environment variable expansion
- [ ] Provider interface defines Name, BaseURL, Authenticate, ForwardHeaders, SupportsStreaming
- [ ] AnthropicProvider implements Provider interface
- [ ] AnthropicProvider.Authenticate sets x-api-key header
- [ ] AnthropicProvider.ForwardHeaders copies anthropic-* headers
- [ ] Unit tests pass for config loading and provider
- [ ] loader_test.go contains >= 4 named test functions
- [ ] anthropic_test.go contains >= 4 named test functions
- [ ] `go build ./...` succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-proxy/01-01-SUMMARY.md`
</output>
