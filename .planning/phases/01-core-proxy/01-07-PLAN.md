---
phase: 01-core-proxy
plan: 07
type: execute
wave: 5
depends_on: [01-05]
files_modified:
  - cmd/cc-relay/main.go
  - cmd/cc-relay/serve.go
  - cmd/cc-relay/status.go
  - cmd/cc-relay/config.go
  - cmd/cc-relay/version.go
  - internal/version/version.go
  - Taskfile.yml
  - go.mod
  - go.sum
autonomous: true

must_haves:
  truths:
    - "User can run cc-relay serve to start proxy server"
    - "User can run cc-relay status to check if server is running"
    - "User can run cc-relay config validate to validate config file"
    - "User can run cc-relay version to see version information"
    - "User can run cc-relay --help to see all available commands"
    - "Invalid subcommands show helpful error messages"
  artifacts:
    - path: "cmd/cc-relay/main.go"
      provides: "Root command setup with Cobra CLI framework"
      exports: []
      min_lines: 30
    - path: "cmd/cc-relay/serve.go"
      provides: "Serve subcommand implementation"
      exports: []
      min_lines: 50
    - path: "cmd/cc-relay/status.go"
      provides: "Status subcommand implementation"
      exports: []
      min_lines: 40
    - path: "cmd/cc-relay/config.go"
      provides: "Config validate subcommand implementation"
      exports: []
      min_lines: 40
    - path: "cmd/cc-relay/version.go"
      provides: "Version subcommand implementation"
      exports: []
      min_lines: 20
    - path: "internal/version/version.go"
      provides: "Version information with build-time injection support"
      exports: ["Version", "Commit", "BuildDate"]
      min_lines: 20
  key_links:
    - from: "cmd/cc-relay/main.go"
      to: "cmd/cc-relay/serve.go"
      via: "rootCmd.AddCommand(serveCmd)"
      pattern: "AddCommand.*serveCmd"
    - from: "cmd/cc-relay/serve.go"
      to: "internal/proxy/routes.go"
      via: "calls proxy.SetupRoutes"
      pattern: "proxy\\.SetupRoutes"
    - from: "cmd/cc-relay/status.go"
      to: "http.Get"
      via: "queries /health endpoint"
      pattern: "http\\.Get.*\\/health"
    - from: "cmd/cc-relay/config.go"
      to: "internal/config/loader.go"
      via: "calls config.Load"
      pattern: "config\\.Load"
    - from: "cmd/cc-relay/version.go"
      to: "internal/version/version.go"
      via: "calls version functions"
      pattern: "version\\.(Version|Commit|BuildDate)"
---

<objective>
Add structured CLI subcommands to cc-relay using Cobra framework, enabling serve, status, config validate, and version commands.

Purpose: Provide explicit subcommands for different operations instead of single implicit behavior, enabling users to check server status, validate config, and view version information without starting the server.

Output: Well-structured CLI with help text, subcommands in separate files, version information injectable at build time, and comprehensive unit tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@cmd/cc-relay/main.go
@internal/version/version.go
@internal/config/loader.go
@internal/proxy/routes.go
@Taskfile.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Cobra dependency and refactor main.go for root command</name>
  <files>go.mod, go.sum, cmd/cc-relay/main.go</files>
  <action>
**Step 1: Add Cobra dependency**

```bash
cd /home/omarluq/sandbox/go/cc-relay
go get github.com/spf13/cobra@latest
```

This adds the Cobra CLI framework for structured subcommand handling.

**Step 2: Refactor main.go to create root command**

Replace current main.go content with Cobra-based root command structure:

```go
// Package main is the entry point for cc-relay.
package main

import (
	"fmt"
	"os"

	"github.com/spf13/cobra"
)

var (
	cfgFile string
)

var rootCmd = &cobra.Command{
	Use:   "cc-relay",
	Short: "Multi-provider proxy for Claude Code",
	Long: `cc-relay is a multi-provider proxy that sits between Claude Code and multiple
LLM providers (Anthropic, Z.AI, Ollama), enabling seamless model switching,
rate limit pooling, and intelligent routing.`,
}

func init() {
	// Global flags available to all subcommands
	rootCmd.PersistentFlags().StringVar(&cfgFile, "config", "", "config file path (default: ./config.yaml or ~/.config/cc-relay/config.yaml)")
}

func main() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}
```

**Key design decisions:**
- Use `PersistentFlags` for --config flag (available to all subcommands)
- Keep main.go minimal - just root command setup and subcommand registration
- Short and Long descriptions for good help text
- Error handling with stderr output and proper exit codes
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go mod tidy
cd /home/omarluq/sandbox/go/cc-relay && go build -o bin/cc-relay ./cmd/cc-relay
bin/cc-relay --help 2>&1 | grep -q "cc-relay is a multi-provider proxy"
```
  </verify>
  <done>Cobra dependency added, root command compiles, --help shows description</done>
</task>

<task type="auto">
  <name>Task 2: Implement serve subcommand</name>
  <files>cmd/cc-relay/serve.go, cmd/cc-relay/main.go</files>
  <action>
**Step 1: Create serve.go with subcommand implementation**

Create `cmd/cc-relay/serve.go` that moves current server startup logic from old main.go:

```go
package main

import (
	"context"
	"errors"
	"log/slog"
	"net/http"
	"os"
	"os/signal"
	"path/filepath"
	"syscall"
	"time"

	"github.com/spf13/cobra"
	"github.com/omarluq/cc-relay/internal/config"
	"github.com/omarluq/cc-relay/internal/providers"
	"github.com/omarluq/cc-relay/internal/proxy"
)

var serveCmd = &cobra.Command{
	Use:   "serve",
	Short: "Start the cc-relay proxy server",
	Long: `Start the proxy server that accepts Claude Code requests and routes them
to configured backend providers.`,
	RunE: runServe,
}

func init() {
	rootCmd.AddCommand(serveCmd)
}

func runServe(cmd *cobra.Command, args []string) error {
	// Setup logging
	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	slog.SetDefault(logger)

	// Determine config path
	configPath := cfgFile
	if configPath == "" {
		configPath = findConfigFile()
	}

	// Load config
	cfg, err := config.Load(configPath)
	if err != nil {
		slog.Error("failed to load config", "error", err, "path", configPath)
		return err
	}

	// Find first enabled Anthropic provider
	var provider providers.Provider
	var providerKey string

	for _, p := range cfg.Providers {
		if p.Enabled && p.Type == "anthropic" {
			provider = providers.NewAnthropicProvider(p.Name, p.BaseURL)
			if len(p.Keys) > 0 {
				providerKey = p.Keys[0].Key
			}
			break
		}
	}

	if provider == nil {
		slog.Error("no enabled anthropic provider found in config")
		return errors.New("no enabled anthropic provider in config")
	}

	// Setup routes
	handler, err := proxy.SetupRoutes(cfg, provider, providerKey)
	if err != nil {
		slog.Error("failed to setup routes", "error", err)
		return err
	}

	// Create server
	server := proxy.NewServer(cfg.Server.Listen, handler)

	// Graceful shutdown on SIGINT/SIGTERM
	done := make(chan struct{})
	go func() {
		sigint := make(chan os.Signal, 1)
		signal.Notify(sigint, os.Interrupt, syscall.SIGTERM)
		<-sigint

		slog.Info("shutting down...")

		ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
		defer cancel()

		if err := server.Shutdown(ctx); err != nil {
			slog.Error("shutdown error", "error", err)
		}

		close(done)
	}()

	// Start server
	slog.Info("starting cc-relay", "listen", cfg.Server.Listen)

	if err := server.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {
		slog.Error("server error", "error", err)
		return err
	}

	<-done
	slog.Info("server stopped")
	return nil
}

// findConfigFile searches for config.yaml in default locations.
func findConfigFile() string {
	// Check current directory
	if _, err := os.Stat("config.yaml"); err == nil {
		return "config.yaml"
	}
	// Check ~/.config/cc-relay/
	home, err := os.UserHomeDir()
	if err == nil && home != "" {
		p := filepath.Join(home, ".config", "cc-relay", "config.yaml")
		if _, err := os.Stat(p); err == nil {
			return p
		}
	}
	return "config.yaml" // Default, will error if not found
}
```

**Step 2: Update main.go init() to register serve command**

In main.go's init() function (after rootCmd.PersistentFlags line), the serveCmd will auto-register via its own init() function in serve.go.

**Key design decisions:**
- Move all server logic from main.go to serve.go
- Use cobra's RunE (not Run) for proper error handling
- Keep findConfigFile helper in serve.go (only used by serve)
- Use --config flag from parent rootCmd via cfgFile variable
- Return errors instead of os.Exit(1) for cleaner Cobra integration
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go build -o bin/cc-relay ./cmd/cc-relay
bin/cc-relay serve --help 2>&1 | grep -q "Start the cc-relay proxy server"
# Verify serve command exists
bin/cc-relay --help 2>&1 | grep -q "serve"
```
  </verify>
  <done>serve subcommand implemented, compiles successfully, shows in help output</done>
</task>

<task type="auto">
  <name>Task 3: Implement status subcommand</name>
  <files>cmd/cc-relay/status.go</files>
  <action>
Create `cmd/cc-relay/status.go` that checks if server is running by querying health endpoint:

```go
package main

import (
	"fmt"
	"net/http"
	"time"

	"github.com/spf13/cobra"
	"github.com/omarluq/cc-relay/internal/config"
)

var statusCmd = &cobra.Command{
	Use:   "status",
	Short: "Check if cc-relay server is running",
	Long: `Check the health status of a running cc-relay server by querying
its /health endpoint.`,
	RunE: runStatus,
}

func init() {
	rootCmd.AddCommand(statusCmd)
}

func runStatus(cmd *cobra.Command, args []string) error {
	// Load config to get server listen address
	configPath := cfgFile
	if configPath == "" {
		configPath = findConfigFileForStatus()
	}

	cfg, err := config.Load(configPath)
	if err != nil {
		return fmt.Errorf("failed to load config: %w", err)
	}

	// Build health endpoint URL
	healthURL := fmt.Sprintf("http://%s/health", cfg.Server.Listen)

	// Query health endpoint with timeout
	client := &http.Client{
		Timeout: 5 * time.Second,
	}

	resp, err := client.Get(healthURL)
	if err != nil {
		fmt.Printf("✗ cc-relay is not running (%s)\n", cfg.Server.Listen)
		return fmt.Errorf("server not reachable: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusOK {
		fmt.Printf("✓ cc-relay is running (%s)\n", cfg.Server.Listen)
		return nil
	}

	fmt.Printf("✗ cc-relay returned unexpected status: %d\n", resp.StatusCode)
	return fmt.Errorf("health check failed with status %d", resp.StatusCode)
}

// findConfigFileForStatus is a copy of findConfigFile from serve.go.
// Duplicated to avoid shared state between subcommands.
func findConfigFileForStatus() string {
	// Check current directory
	if _, err := os.Stat("config.yaml"); err == nil {
		return "config.yaml"
	}
	// Check ~/.config/cc-relay/
	home, err := os.UserHomeDir()
	if err == nil && home != "" {
		p := filepath.Join(home, ".config", "cc-relay", "config.yaml")
		if _, err := os.Stat(p); err == nil {
			return p
		}
	}
	return "config.yaml"
}
```

**Missing imports:** Add these to the import block:
```go
import (
	"os"
	"path/filepath"
	// ... other imports
)
```

**Key design decisions:**
- Exit code 0 if healthy (status 200), 1 otherwise
- 5 second timeout (don't hang if server is stuck)
- Pretty output with checkmark/X for user-friendliness
- Load config to discover listen address (don't hardcode localhost:8787)
- Query /health endpoint (no auth required per Phase 1 implementation)
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go build -o bin/cc-relay ./cmd/cc-relay
bin/cc-relay status --help 2>&1 | grep -q "Check if cc-relay server is running"
# Verify status command exists
bin/cc-relay --help 2>&1 | grep -q "status"
```
  </verify>
  <done>status subcommand implemented, compiles successfully, shows in help output</done>
</task>

<task type="auto">
  <name>Task 4: Implement config validate subcommand</name>
  <files>cmd/cc-relay/config.go</files>
  <action>
Create `cmd/cc-relay/config.go` with validate subcommand:

```go
package main

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/spf13/cobra"
	"github.com/omarluq/cc-relay/internal/config"
)

var configCmd = &cobra.Command{
	Use:   "config",
	Short: "Configuration management commands",
}

var configValidateCmd = &cobra.Command{
	Use:   "validate",
	Short: "Validate configuration file",
	Long: `Validate the configuration file without starting the server.
Checks YAML syntax, required fields, and provider configurations.`,
	RunE: runConfigValidate,
}

func init() {
	configCmd.AddCommand(configValidateCmd)
	rootCmd.AddCommand(configCmd)
}

func runConfigValidate(cmd *cobra.Command, args []string) error {
	// Determine config path
	configPath := cfgFile
	if configPath == "" {
		configPath = findConfigFileForValidate()
	}

	// Load and validate config
	cfg, err := config.Load(configPath)
	if err != nil {
		fmt.Printf("✗ Config validation failed: %s\n", err)
		return err
	}

	// Additional validation checks
	if err := validateConfig(cfg); err != nil {
		fmt.Printf("✗ Config validation failed: %s\n", err)
		return err
	}

	fmt.Printf("✓ %s is valid\n", configPath)
	return nil
}

// validateConfig performs semantic validation beyond YAML parsing.
func validateConfig(cfg *config.Config) error {
	// Check server config
	if cfg.Server.Listen == "" {
		return fmt.Errorf("server.listen is required")
	}
	if cfg.Server.APIKey == "" {
		return fmt.Errorf("server.api_key is required")
	}

	// Check at least one enabled provider
	hasEnabledProvider := false
	for _, p := range cfg.Providers {
		if p.Enabled {
			hasEnabledProvider = true
			// Check provider has at least one key
			if len(p.Keys) == 0 {
				return fmt.Errorf("provider %s has no API keys configured", p.Name)
			}
		}
	}

	if !hasEnabledProvider {
		return fmt.Errorf("no enabled providers configured")
	}

	return nil
}

// findConfigFileForValidate searches for config file in default locations.
func findConfigFileForValidate() string {
	// Check current directory
	if _, err := os.Stat("config.yaml"); err == nil {
		return "config.yaml"
	}
	// Check ~/.config/cc-relay/
	home, err := os.UserHomeDir()
	if err == nil && home != "" {
		p := filepath.Join(home, ".config", "cc-relay", "config.yaml")
		if _, err := os.Stat(p); err == nil {
			return p
		}
	}
	return "config.yaml"
}
```

**Key design decisions:**
- Nested subcommand structure: `cc-relay config validate`
- Exit 0 if valid, 1 with error message if invalid
- Validate beyond YAML parsing: check required fields, enabled providers, API keys
- Pretty output with checkmark/X
- Load config using same logic as serve command
- Separate function for semantic validation (testable)
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go build -o bin/cc-relay ./cmd/cc-relay
bin/cc-relay config validate --help 2>&1 | grep -q "Validate configuration file"
# Verify config command exists
bin/cc-relay --help 2>&1 | grep -q "config"
```
  </verify>
  <done>config validate subcommand implemented, compiles successfully, shows in help output</done>
</task>

<task type="auto">
  <name>Task 5: Implement version subcommand with build-time injection</name>
  <files>cmd/cc-relay/version.go, internal/version/version.go, Taskfile.yml</files>
  <action>
**Step 1: Enhance internal/version/version.go for build-time injection**

Replace current version.go with:

```go
// Package version provides version information for cc-relay.
package version

var (
	// Version is the semantic version (injected at build time via ldflags).
	Version = "dev"
	// Commit is the git commit hash (injected at build time via ldflags).
	Commit = "none"
	// BuildDate is the build timestamp (injected at build time via ldflags).
	BuildDate = "unknown"
)

// String returns formatted version information.
func String() string {
	return Version + " (commit: " + Commit + ", built: " + BuildDate + ")"
}
```

**Step 2: Create version subcommand**

Create `cmd/cc-relay/version.go`:

```go
package main

import (
	"fmt"

	"github.com/spf13/cobra"
	"github.com/omarluq/cc-relay/internal/version"
)

var versionCmd = &cobra.Command{
	Use:   "version",
	Short: "Show version information",
	Long:  `Display version, git commit, and build date.`,
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Printf("cc-relay %s\n", version.String())
	},
}

func init() {
	rootCmd.AddCommand(versionCmd)
}
```

**Step 3: Update Taskfile.yml build task with ldflags**

Modify the `build:` task in Taskfile.yml:

```yaml
  build:
    desc: Build binary
    vars:
      VERSION:
        sh: git describe --tags --always --dirty 2>/dev/null || echo "dev"
      COMMIT:
        sh: git rev-parse --short HEAD 2>/dev/null || echo "none"
      BUILD_DATE:
        sh: date -u +"%Y-%m-%dT%H:%M:%SZ"
      LDFLAGS: -X github.com/omarluq/cc-relay/internal/version.Version={{.VERSION}} -X github.com/omarluq/cc-relay/internal/version.Commit={{.COMMIT}} -X github.com/omarluq/cc-relay/internal/version.BuildDate={{.BUILD_DATE}}
    cmds:
      - mkdir -p {{.BUILD_DIR}}
      - go build -ldflags "{{.LDFLAGS}}" -o {{.BUILD_DIR}}/{{.BINARY_NAME}} ./cmd/cc-relay
```

**Key design decisions:**
- Use `var` instead of `const` so ldflags can inject values
- Default values ("dev", "none", "unknown") for non-build scenarios
- String() helper for consistent formatting
- Taskfile uses git commands to get version/commit automatically
- Build date in RFC3339 format (UTC)
- ldflags inject at package variable level, not main package
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && task build
bin/cc-relay version 2>&1 | grep -q "cc-relay"
# Verify version shows commit hash (short form)
bin/cc-relay version 2>&1 | grep -E "commit: [a-f0-9]{7}"
```
  </verify>
  <done>version subcommand implemented, build injects version/commit/date via ldflags, compiles successfully</done>
</task>

<task type="auto">
  <name>Task 6: Add unit tests for subcommands</name>
  <files>cmd/cc-relay/serve_test.go, cmd/cc-relay/config_test.go</files>
  <action>
**Step 1: Create serve_test.go**

Create `cmd/cc-relay/serve_test.go`:

```go
package main

import (
	"os"
	"path/filepath"
	"testing"
)

func TestFindConfigFile(t *testing.T) {
	// Save original working directory
	origWd, err := os.Getwd()
	if err != nil {
		t.Fatal(err)
	}
	defer os.Chdir(origWd)

	// Create temp directory with config.yaml
	tmpDir := t.TempDir()
	configPath := filepath.Join(tmpDir, "config.yaml")
	if err := os.WriteFile(configPath, []byte("server:\n  listen: localhost:8787\n"), 0644); err != nil {
		t.Fatal(err)
	}

	// Change to temp directory
	if err := os.Chdir(tmpDir); err != nil {
		t.Fatal(err)
	}

	// Test finding config in current directory
	found := findConfigFile()
	if found != "config.yaml" {
		t.Errorf("Expected 'config.yaml', got %q", found)
	}
}

func TestFindConfigFile_NotFound(t *testing.T) {
	// Save original working directory
	origWd, err := os.Getwd()
	if err != nil {
		t.Fatal(err)
	}
	defer os.Chdir(origWd)

	// Change to temp directory without config.yaml
	tmpDir := t.TempDir()
	if err := os.Chdir(tmpDir); err != nil {
		t.Fatal(err)
	}

	// Should return default even if not found
	found := findConfigFile()
	if found != "config.yaml" {
		t.Errorf("Expected 'config.yaml' default, got %q", found)
	}
}
```

**Step 2: Create config_test.go**

Create `cmd/cc-relay/config_test.go`:

```go
package main

import (
	"testing"

	"github.com/omarluq/cc-relay/internal/config"
)

func TestValidateConfig_Valid(t *testing.T) {
	cfg := &config.Config{
		Server: config.ServerConfig{
			Listen: "localhost:8787",
			APIKey: "test-key",
		},
		Providers: []config.ProviderConfig{
			{
				Name:    "anthropic",
				Type:    "anthropic",
				Enabled: true,
				Keys: []config.KeyConfig{
					{Key: "test-api-key"},
				},
			},
		},
	}

	if err := validateConfig(cfg); err != nil {
		t.Errorf("Expected valid config, got error: %v", err)
	}
}

func TestValidateConfig_NoListen(t *testing.T) {
	cfg := &config.Config{
		Server: config.ServerConfig{
			APIKey: "test-key",
		},
	}

	err := validateConfig(cfg)
	if err == nil {
		t.Error("Expected error for missing listen address")
	}
	if err != nil && err.Error() != "server.listen is required" {
		t.Errorf("Unexpected error: %v", err)
	}
}

func TestValidateConfig_NoAPIKey(t *testing.T) {
	cfg := &config.Config{
		Server: config.ServerConfig{
			Listen: "localhost:8787",
		},
	}

	err := validateConfig(cfg)
	if err == nil {
		t.Error("Expected error for missing API key")
	}
	if err != nil && err.Error() != "server.api_key is required" {
		t.Errorf("Unexpected error: %v", err)
	}
}

func TestValidateConfig_NoEnabledProvider(t *testing.T) {
	cfg := &config.Config{
		Server: config.ServerConfig{
			Listen: "localhost:8787",
			APIKey: "test-key",
		},
		Providers: []config.ProviderConfig{
			{
				Name:    "anthropic",
				Enabled: false,
			},
		},
	}

	err := validateConfig(cfg)
	if err == nil {
		t.Error("Expected error for no enabled providers")
	}
	if err != nil && err.Error() != "no enabled providers configured" {
		t.Errorf("Unexpected error: %v", err)
	}
}

func TestValidateConfig_ProviderNoKeys(t *testing.T) {
	cfg := &config.Config{
		Server: config.ServerConfig{
			Listen: "localhost:8787",
			APIKey: "test-key",
		},
		Providers: []config.ProviderConfig{
			{
				Name:    "anthropic",
				Enabled: true,
				Keys:    []config.KeyConfig{},
			},
		},
	}

	err := validateConfig(cfg)
	if err == nil {
		t.Error("Expected error for provider with no keys")
	}
}
```

**Key design decisions:**
- Test findConfigFile helper for both found and not-found cases
- Use t.TempDir() for isolated test environments
- Test validateConfig with various invalid config scenarios
- Table-driven tests not needed here (simple validation functions)
- Mock/stub not needed (no external dependencies in these functions)
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go test -v ./cmd/cc-relay/... -run TestFindConfigFile
cd /home/omarluq/sandbox/go/cc-relay && go test -v ./cmd/cc-relay/... -run TestValidateConfig
```
  </verify>
  <done>Unit tests added for findConfigFile and validateConfig, all tests pass</done>
</task>

<task type="auto">
  <name>Task 7: Update documentation and commit changes</name>
  <files>.claude/CLAUDE.md, README.md</files>
  <action>
**Step 1: Update .claude/CLAUDE.md usage examples**

Find the "Running" section in `.claude/CLAUDE.md` and update it:

```markdown
### Running

```bash
# Development with live reload (recommended)
task dev

# Production build and run
task build
./bin/cc-relay serve

# Check server status
./bin/cc-relay status

# Validate configuration
./bin/cc-relay config validate

# Show version
./bin/cc-relay version

# Get help
./bin/cc-relay --help
./bin/cc-relay serve --help

# Manual with custom config
./bin/cc-relay serve --config /path/to/config.yaml
```
```

**Step 2: Update README.md if it has usage section**

Search for usage/quickstart sections in README.md and add CLI examples:

```markdown
## Quick Start

```bash
# Build
task build

# Start proxy server
./bin/cc-relay serve --config config.yaml

# Check status
./bin/cc-relay status

# Validate config before running
./bin/cc-relay config validate
```
```

**Key updates:**
- Replace `./cc-relay serve` with explicit serve subcommand
- Add status, config validate, and version commands
- Show --config flag usage
- Update help command examples
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && grep -q "cc-relay serve" .claude/CLAUDE.md
cd /home/omarluq/sandbox/go/cc-relay && grep -q "cc-relay status" .claude/CLAUDE.md
```
  </verify>
  <done>Documentation updated with new CLI subcommands, examples show proper usage</done>
</task>

</tasks>

<verification>
After all tasks complete, verify the complete CLI structure:

```bash
# Build with version injection
cd /home/omarluq/sandbox/go/cc-relay && task build

# Test all subcommands show in help
bin/cc-relay --help 2>&1 | grep -E "(serve|status|config|version)"

# Test version shows build info
bin/cc-relay version 2>&1 | grep "commit:"

# Test config validate (should fail on missing config)
bin/cc-relay config validate --config /nonexistent/config.yaml 2>&1 | grep "failed"

# Test status (should fail when server not running)
bin/cc-relay status 2>&1 | grep "not running"

# Run all unit tests
go test -v ./cmd/cc-relay/...

# Run CI checks
task ci
```

All commands should execute without panic, show proper error messages, and exit with appropriate codes.
</verification>

<success_criteria>
Completion checklist:

1. Cobra dependency added to go.mod
2. Root command setup in main.go with --config flag
3. serve subcommand moves server logic from old main.go
4. status subcommand queries /health endpoint and reports status
5. config validate subcommand loads and validates config file
6. version subcommand shows version, commit, and build date
7. Taskfile.yml build task injects version info via ldflags
8. Unit tests cover findConfigFile and validateConfig functions
9. Documentation updated with new CLI usage
10. All tests pass: `go test ./cmd/cc-relay/...`
11. All subcommands compile and run: `cc-relay --help` shows all commands
12. Version injection works: `cc-relay version` shows git commit

Manual verification:
- `./bin/cc-relay --help` lists serve, status, config, version
- `./bin/cc-relay serve --help` shows serve-specific help
- `./bin/cc-relay status` exits 1 when server not running
- `./bin/cc-relay config validate` exits 1 for invalid config
- `./bin/cc-relay version` shows "cc-relay <version> (commit: <hash>, built: <date>)"
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-proxy/01-07-SUMMARY.md` documenting:

- Files created (5 new cmd files)
- Files modified (main.go, version.go, Taskfile.yml, docs)
- Cobra framework integration
- Subcommand structure and help text
- Version injection mechanism
- Test coverage
- Documentation updates
- Any issues encountered
- Next steps (ready for Phase 2)
</output>
