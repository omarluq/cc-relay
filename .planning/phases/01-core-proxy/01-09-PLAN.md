---
phase: 01-core-proxy
plan: 09
type: execute
wave: 6
depends_on: ["01-06"]
files_modified:
  - internal/config/config.go
  - internal/proxy/middleware.go
  - internal/proxy/handler.go
  - internal/proxy/debug.go
  - internal/proxy/debug_test.go
  - cmd/cc-relay/serve.go
autonomous: true

must_haves:
  truths:
    - "Debug mode logs request body with sensitive data redacted"
    - "Debug mode logs response headers and event counts for SSE"
    - "Debug mode shows TLS metrics (version, connection reuse, timing)"
    - "Debug mode shows proxy metrics (latency, bytes, streaming events)"
    - "User can enable debug mode via --debug flag as shortcut"
    - "Log output respects max_body_log_size config to prevent massive logs"
  artifacts:
    - path: "internal/config/config.go"
      provides: "DebugOptions struct with log_request_body, log_response_headers, log_tls_metrics, max_body_log_size"
      contains: "type DebugOptions struct"
    - path: "internal/proxy/debug.go"
      provides: "Debug logging utilities for request/response/metrics"
      exports: ["LogRequestDetails", "LogResponseDetails", "LogTLSMetrics", "LogProxyMetrics"]
      min_lines: 100
    - path: "internal/proxy/debug_test.go"
      provides: "Unit tests for debug logging functions"
      min_lines: 50
    - path: "internal/proxy/middleware.go"
      provides: "Updated LoggingMiddleware with debug logging integration"
      contains: "LogRequestDetails"
    - path: "internal/proxy/handler.go"
      provides: "Updated ServeHTTP with TLS and proxy metrics logging"
      contains: "LogTLSMetrics"
    - path: "cmd/cc-relay/serve.go"
      provides: "Added --debug flag that sets debug level + all debug options"
      contains: "--debug"
  key_links:
    - from: "internal/proxy/middleware.go"
      to: "internal/proxy/debug.go"
      via: "LogRequestDetails call in LoggingMiddleware"
      pattern: "debug\\.LogRequestDetails"
    - from: "internal/proxy/handler.go"
      to: "internal/proxy/debug.go"
      via: "LogTLSMetrics and LogProxyMetrics calls"
      pattern: "debug\\.(LogTLSMetrics|LogProxyMetrics)"
    - from: "cmd/cc-relay/serve.go"
      to: "internal/config/config.go"
      via: "--debug flag sets DebugOptions fields"
      pattern: "cfg\\.Logging\\.DebugOptions"
---

<objective>
Add comprehensive debug logging for request/response details, TLS metrics, and proxy performance metrics to aid troubleshooting and performance analysis.

Purpose: Enable deep visibility into proxy behavior during development and troubleshooting without overwhelming production logs. Debug mode provides request body inspection, TLS connection details, streaming event counts, and timing breakdowns.

Output: Enhanced debug logging capabilities with sensible defaults, CLI flag shortcut, comprehensive unit tests, and examples.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-proxy/01-RESEARCH.md
@.planning/phases/01-core-proxy/01-06-SUMMARY.md
@internal/config/config.go
@internal/proxy/logger.go
@internal/proxy/middleware.go
@internal/proxy/handler.go
@cmd/cc-relay/serve.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend LoggingConfig with DebugOptions</name>
  <files>internal/config/config.go</files>
  <action>
Add DebugOptions struct and integrate it into LoggingConfig for granular debug logging control.

**Step 1: Add DebugOptions struct in internal/config/config.go**

After the LoggingConfig struct, add:

```go
// DebugOptions defines granular debug logging controls.
type DebugOptions struct {
	// LogRequestBody enables logging of request body in debug mode.
	// Body is truncated to MaxBodyLogSize to prevent massive logs.
	LogRequestBody bool `yaml:"log_request_body"`

	// LogResponseHeaders enables logging of response headers in debug mode.
	LogResponseHeaders bool `yaml:"log_response_headers"`

	// LogTLSMetrics enables logging of TLS connection metrics (version, handshake time, reuse).
	LogTLSMetrics bool `yaml:"log_tls_metrics"`

	// MaxBodyLogSize is the maximum number of bytes to log from request/response bodies.
	// Default: 1000 bytes. Set to 0 for unlimited (not recommended).
	MaxBodyLogSize int `yaml:"max_body_log_size"`
}

// GetMaxBodyLogSize returns the effective max body log size with default fallback.
func (d *DebugOptions) GetMaxBodyLogSize() int {
	if d.MaxBodyLogSize <= 0 {
		return 1000 // Default: 1KB
	}
	return d.MaxBodyLogSize
}

// IsEnabled returns true if any debug option is enabled.
func (d *DebugOptions) IsEnabled() bool {
	return d.LogRequestBody || d.LogResponseHeaders || d.LogTLSMetrics
}
```

**Step 2: Add DebugOptions field to LoggingConfig**

Update the LoggingConfig struct:

```go
// LoggingConfig defines logging behavior.
type LoggingConfig struct {
	Level        string       `yaml:"level"`         // debug, info, warn, error
	Format       string       `yaml:"format"`        // json, console
	Output       string       `yaml:"output"`        // stdout, stderr, or file path
	Pretty       bool         `yaml:"pretty"`        // enable colored console output
	DebugOptions DebugOptions `yaml:"debug_options"` // granular debug logging controls
}

// EnableAllDebugOptions turns on all debug logging features.
// Used by --debug CLI flag shortcut.
func (l *LoggingConfig) EnableAllDebugOptions() {
	l.Level = "debug"
	l.DebugOptions = DebugOptions{
		LogRequestBody:     true,
		LogResponseHeaders: true,
		LogTLSMetrics:      true,
		MaxBodyLogSize:     1000,
	}
}
```

**Why this design:**
- DebugOptions is separate struct for clean YAML structure
- GetMaxBodyLogSize() ensures sensible default (1KB) to prevent accidental massive logs
- IsEnabled() allows checking if debug mode is active without checking each field
- EnableAllDebugOptions() provides one-liner for CLI flag implementation
  </action>
  <verify>
```bash
# Verify code compiles
go build ./internal/config/...

# Test parsing YAML with debug options
cat > /tmp/test-debug-config.yaml << 'EOF'
logging:
  level: debug
  format: json
  debug_options:
    log_request_body: true
    log_response_headers: true
    log_tls_metrics: true
    max_body_log_size: 2000
EOF

# Create simple test to verify parsing
go test ./internal/config/... -v
```
  </verify>
  <done>
- DebugOptions struct exists with 4 fields
- GetMaxBodyLogSize() method returns 1000 default or configured value
- IsEnabled() method checks if any debug option is on
- LoggingConfig has DebugOptions field
- EnableAllDebugOptions() method exists and sets all fields
- Code compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create debug logging utilities</name>
  <files>internal/proxy/debug.go, internal/proxy/debug_test.go</files>
  <action>
Create debug.go with utilities for logging request details, response details, TLS metrics, and proxy metrics.

**internal/proxy/debug.go:**

```go
package proxy

import (
	"bytes"
	"context"
	"crypto/tls"
	"encoding/json"
	"io"
	"net/http"
	"net/http/httptrace"
	"regexp"
	"strings"
	"time"

	"github.com/omarluq/cc-relay/internal/config"
	"github.com/rs/zerolog"
)

// Sensitive patterns to redact from request bodies
var sensitivePatterns = []*regexp.Regexp{
	regexp.MustCompile(`"api_key"\s*:\s*"[^"]+"`),
	regexp.MustCompile(`"x-api-key"\s*:\s*"[^"]+"`),
	regexp.MustCompile(`"bearer"\s*:\s*"[^"]+"`),
	regexp.MustCompile(`"password"\s*:\s*"[^"]+"`),
	regexp.MustCompile(`"token"\s*:\s*"[^"]+"`),
	regexp.MustCompile(`"secret"\s*:\s*"[^"]+"`),
	regexp.MustCompile(`"authorization"\s*:\s*"[^"]+"`),
}

// TLSMetrics holds TLS connection timing and metadata.
type TLSMetrics struct {
	Version      string
	Reused       bool
	DNSTime      time.Duration
	ConnectTime  time.Duration
	TLSTime      time.Duration
	HasMetrics   bool
}

// ProxyMetrics holds proxy-level performance metrics.
type ProxyMetrics struct {
	BackendTime    time.Duration
	TotalTime      time.Duration
	BytesSent      int64
	BytesReceived  int64
	StreamingEvents int
}

// LogRequestDetails logs request body and headers in debug mode.
// Respects DebugOptions.LogRequestBody and MaxBodyLogSize.
func LogRequestDetails(ctx context.Context, r *http.Request, opts config.DebugOptions) {
	if !opts.LogRequestBody {
		return
	}

	logger := zerolog.Ctx(ctx)
	if logger.GetLevel() > zerolog.DebugLevel {
		return
	}

	// Read body
	var bodyBytes []byte
	if r.Body != nil {
		bodyBytes, _ = io.ReadAll(r.Body)
		// Restore body for downstream handlers
		r.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
	}

	// Truncate to max size
	maxSize := opts.GetMaxBodyLogSize()
	if len(bodyBytes) > maxSize {
		bodyBytes = bodyBytes[:maxSize]
	}

	// Parse JSON to extract model and tokens if present
	var bodyMap map[string]interface{}
	model := ""
	maxTokens := 0
	if len(bodyBytes) > 0 && json.Unmarshal(bodyBytes, &bodyMap) == nil {
		if m, ok := bodyMap["model"].(string); ok {
			model = m
		}
		if mt, ok := bodyMap["max_tokens"].(float64); ok {
			maxTokens = int(mt)
		}
	}

	// Redact sensitive fields
	bodyStr := string(bodyBytes)
	for _, pattern := range sensitivePatterns {
		bodyStr = pattern.ReplaceAllString(bodyStr, `"***":"REDACTED"`)
	}

	// Log with context
	logEvent := logger.Debug().
		Str("content_type", r.Header.Get("Content-Type")).
		Int("body_length", len(bodyBytes))

	if model != "" {
		logEvent.Str("model", model)
	}
	if maxTokens > 0 {
		logEvent.Int("max_tokens", maxTokens)
	}
	if len(bodyBytes) > 0 {
		logEvent.Str("body_preview", bodyStr)
	}

	logEvent.Msg("request details")
}

// LogResponseDetails logs response headers and streaming event count in debug mode.
func LogResponseDetails(ctx context.Context, headers http.Header, statusCode int, eventCount int, opts config.DebugOptions) {
	if !opts.LogResponseHeaders {
		return
	}

	logger := zerolog.Ctx(ctx)
	if logger.GetLevel() > zerolog.DebugLevel {
		return
	}

	// Extract usage tokens from headers if present
	usageTokens := headers.Get("X-Anthropic-Usage")
	contentType := headers.Get("Content-Type")

	logEvent := logger.Debug().
		Int("status", statusCode).
		Str("content_type", contentType)

	if usageTokens != "" {
		logEvent.Str("usage_tokens", usageTokens)
	}

	// If SSE streaming, log event count
	if strings.Contains(contentType, "text/event-stream") && eventCount > 0 {
		logEvent.Int("streaming_events", eventCount)
	}

	// Log selected headers (not all - too verbose)
	importantHeaders := []string{
		"X-Anthropic-Model",
		"X-Anthropic-Stop-Reason",
		"X-Request-Id",
		"Cache-Control",
	}
	headerData := make(map[string]string)
	for _, key := range importantHeaders {
		if val := headers.Get(key); val != "" {
			headerData[key] = val
		}
	}
	if len(headerData) > 0 {
		logEvent.Interface("headers", headerData)
	}

	logEvent.Msg("response details")
}

// LogTLSMetrics logs TLS connection metrics in debug mode.
func LogTLSMetrics(ctx context.Context, metrics TLSMetrics, opts config.DebugOptions) {
	if !opts.LogTLSMetrics || !metrics.HasMetrics {
		return
	}

	logger := zerolog.Ctx(ctx)
	if logger.GetLevel() > zerolog.DebugLevel {
		return
	}

	logger.Debug().
		Str("tls_version", metrics.Version).
		Bool("tls_reused", metrics.Reused).
		Dur("dns_time_ms", metrics.DNSTime).
		Dur("connect_time_ms", metrics.ConnectTime).
		Dur("tls_handshake_ms", metrics.TLSTime).
		Msg("tls metrics")
}

// LogProxyMetrics logs proxy-level performance metrics in debug mode.
func LogProxyMetrics(ctx context.Context, metrics ProxyMetrics, opts config.DebugOptions) {
	// Always log proxy metrics if debug level, regardless of specific flag
	logger := zerolog.Ctx(ctx)
	if logger.GetLevel() > zerolog.DebugLevel {
		return
	}

	logEvent := logger.Debug().
		Dur("backend_time_ms", metrics.BackendTime).
		Dur("total_time_ms", metrics.TotalTime)

	if metrics.BytesSent > 0 {
		logEvent.Int64("bytes_sent", metrics.BytesSent)
	}
	if metrics.BytesReceived > 0 {
		logEvent.Int64("bytes_received", metrics.BytesReceived)
	}
	if metrics.StreamingEvents > 0 {
		logEvent.Int("streaming_events", metrics.StreamingEvents)
	}

	logEvent.Msg("proxy metrics")
}

// AttachTLSTrace attaches httptrace to request for TLS metric collection.
// Returns updated context with trace and a function to retrieve metrics.
func AttachTLSTrace(ctx context.Context, r *http.Request) (context.Context, func() TLSMetrics) {
	metrics := &TLSMetrics{}
	var dnsStart, connectStart, tlsStart time.Time

	trace := &httptrace.ClientTrace{
		DNSStart: func(_ httptrace.DNSStartInfo) {
			dnsStart = time.Now()
		},
		DNSDone: func(_ httptrace.DNSDoneInfo) {
			if !dnsStart.IsZero() {
				metrics.DNSTime = time.Since(dnsStart)
			}
		},
		ConnectStart: func(_, _ string) {
			connectStart = time.Now()
		},
		ConnectDone: func(_, _ string, _ error) {
			if !connectStart.IsZero() {
				metrics.ConnectTime = time.Since(connectStart)
			}
		},
		TLSHandshakeStart: func() {
			tlsStart = time.Now()
		},
		TLSHandshakeDone: func(state tls.ConnectionState, _ error) {
			if !tlsStart.IsZero() {
				metrics.TLSTime = time.Since(tlsStart)
			}
			metrics.Version = tlsVersionString(state.Version)
			metrics.Reused = state.DidResume
			metrics.HasMetrics = true
		},
	}

	newCtx := httptrace.WithClientTrace(ctx, trace)
	return newCtx, func() TLSMetrics { return *metrics }
}

// tlsVersionString converts TLS version constant to string.
func tlsVersionString(version uint16) string {
	switch version {
	case tls.VersionTLS10:
		return "TLS 1.0"
	case tls.VersionTLS11:
		return "TLS 1.1"
	case tls.VersionTLS12:
		return "TLS 1.2"
	case tls.VersionTLS13:
		return "TLS 1.3"
	default:
		return "unknown"
	}
}
```

**internal/proxy/debug_test.go:**

```go
package proxy

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"time"

	"github.com/omarluq/cc-relay/internal/config"
	"github.com/rs/zerolog"
)

func TestLogRequestDetails_DisabledByDefault(t *testing.T) {
	var buf bytes.Buffer
	logger := zerolog.New(&buf).Level(zerolog.DebugLevel)
	ctx := logger.WithContext(context.Background())

	req := httptest.NewRequest("POST", "/v1/messages", strings.NewReader(`{"model":"claude-3"}`))
	opts := config.DebugOptions{LogRequestBody: false}

	LogRequestDetails(ctx, req, opts)

	// Should not log anything if disabled
	if buf.Len() > 0 {
		t.Errorf("Expected no log output when LogRequestBody disabled, got: %s", buf.String())
	}
}

func TestLogRequestDetails_RedactsSensitiveData(t *testing.T) {
	var buf bytes.Buffer
	logger := zerolog.New(&buf).Level(zerolog.DebugLevel)
	ctx := logger.WithContext(context.Background())

	body := `{"api_key":"sk-secret-123","model":"claude-3","password":"hunter2"}`
	req := httptest.NewRequest("POST", "/v1/messages", strings.NewReader(body))
	opts := config.DebugOptions{LogRequestBody: true, MaxBodyLogSize: 1000}

	LogRequestDetails(ctx, req, opts)

	output := buf.String()
	if strings.Contains(output, "sk-secret-123") {
		t.Error("Expected api_key to be redacted")
	}
	if strings.Contains(output, "hunter2") {
		t.Error("Expected password to be redacted")
	}
	if !strings.Contains(output, "REDACTED") {
		t.Error("Expected REDACTED placeholder in output")
	}
}

func TestLogRequestDetails_ExtractsModel(t *testing.T) {
	var buf bytes.Buffer
	logger := zerolog.New(&buf).Level(zerolog.DebugLevel)
	ctx := logger.WithContext(context.Background())

	body := `{"model":"claude-3-5-sonnet-20241022","max_tokens":100}`
	req := httptest.NewRequest("POST", "/v1/messages", strings.NewReader(body))
	opts := config.DebugOptions{LogRequestBody: true, MaxBodyLogSize: 1000}

	LogRequestDetails(ctx, req, opts)

	output := buf.String()
	if !strings.Contains(output, "claude-3-5-sonnet-20241022") {
		t.Error("Expected model name in log output")
	}
	if !strings.Contains(output, `"max_tokens":100`) {
		t.Error("Expected max_tokens in log output")
	}
}

func TestLogRequestDetails_TruncatesLargeBody(t *testing.T) {
	var buf bytes.Buffer
	logger := zerolog.New(&buf).Level(zerolog.DebugLevel)
	ctx := logger.WithContext(context.Background())

	largeBody := strings.Repeat("x", 5000)
	req := httptest.NewRequest("POST", "/v1/messages", strings.NewReader(largeBody))
	opts := config.DebugOptions{LogRequestBody: true, MaxBodyLogSize: 100}

	LogRequestDetails(ctx, req, opts)

	output := buf.String()
	// Should contain truncated portion but not full 5000 chars
	if strings.Count(output, "x") > 150 { // Some slack for JSON encoding
		t.Errorf("Expected truncated body, got %d x's", strings.Count(output, "x"))
	}
}

func TestLogResponseDetails_LogsEventCount(t *testing.T) {
	var buf bytes.Buffer
	logger := zerolog.New(&buf).Level(zerolog.DebugLevel)
	ctx := logger.WithContext(context.Background())

	headers := http.Header{}
	headers.Set("Content-Type", "text/event-stream")
	headers.Set("X-Anthropic-Stop-Reason", "end_turn")

	opts := config.DebugOptions{LogResponseHeaders: true}
	LogResponseDetails(ctx, headers, 200, 42, opts)

	output := buf.String()
	if !strings.Contains(output, `"streaming_events":42`) {
		t.Error("Expected streaming_events count in output")
	}
	if !strings.Contains(output, "end_turn") {
		t.Error("Expected X-Anthropic-Stop-Reason in output")
	}
}

func TestLogTLSMetrics(t *testing.T) {
	var buf bytes.Buffer
	logger := zerolog.New(&buf).Level(zerolog.DebugLevel)
	ctx := logger.WithContext(context.Background())

	metrics := TLSMetrics{
		Version:     "TLS 1.3",
		Reused:      true,
		DNSTime:     5 * time.Millisecond,
		ConnectTime: 10 * time.Millisecond,
		TLSTime:     15 * time.Millisecond,
		HasMetrics:  true,
	}

	opts := config.DebugOptions{LogTLSMetrics: true}
	LogTLSMetrics(ctx, metrics, opts)

	output := buf.String()
	if !strings.Contains(output, "TLS 1.3") {
		t.Error("Expected TLS version in output")
	}
	if !strings.Contains(output, `"tls_reused":true`) {
		t.Error("Expected tls_reused in output")
	}
	if !strings.Contains(output, "tls metrics") {
		t.Error("Expected 'tls metrics' message")
	}
}

func TestLogProxyMetrics(t *testing.T) {
	var buf bytes.Buffer
	logger := zerolog.New(&buf).Level(zerolog.DebugLevel)
	ctx := logger.WithContext(context.Background())

	metrics := ProxyMetrics{
		BackendTime:     250 * time.Millisecond,
		TotalTime:       300 * time.Millisecond,
		BytesSent:       1024,
		BytesReceived:   2048,
		StreamingEvents: 10,
	}

	opts := config.DebugOptions{}
	LogProxyMetrics(ctx, metrics, opts)

	output := buf.String()
	if !strings.Contains(output, `"bytes_sent":1024`) {
		t.Error("Expected bytes_sent in output")
	}
	if !strings.Contains(output, `"bytes_received":2048`) {
		t.Error("Expected bytes_received in output")
	}
	if !strings.Contains(output, `"streaming_events":10`) {
		t.Error("Expected streaming_events in output")
	}
}

func TestDebugOptions_GetMaxBodyLogSize(t *testing.T) {
	tests := []struct {
		name     string
		opts     config.DebugOptions
		expected int
	}{
		{"default", config.DebugOptions{}, 1000},
		{"zero", config.DebugOptions{MaxBodyLogSize: 0}, 1000},
		{"negative", config.DebugOptions{MaxBodyLogSize: -1}, 1000},
		{"custom", config.DebugOptions{MaxBodyLogSize: 5000}, 5000},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := tt.opts.GetMaxBodyLogSize()
			if got != tt.expected {
				t.Errorf("Expected %d, got %d", tt.expected, got)
			}
		})
	}
}
```

**Why this design:**
- Separate debug.go file keeps middleware.go focused and readable
- Sensitive pattern redaction prevents accidental credential leaks in logs
- TLSMetrics uses httptrace for accurate connection timing
- ProxyMetrics tracks end-to-end timing breakdown
- All functions check log level before doing work (performance)
- Test coverage for all core functions
  </action>
  <verify>
```bash
# Verify code compiles
go build ./internal/proxy/...

# Run unit tests
go test -v ./internal/proxy/... -run TestDebug
go test -v ./internal/proxy/... -run TestLogRequestDetails
go test -v ./internal/proxy/... -run TestLogResponseDetails
go test -v ./internal/proxy/... -run TestLogTLSMetrics
go test -v ./internal/proxy/... -run TestLogProxyMetrics

# Verify all tests pass
go test ./internal/proxy/...
```
  </verify>
  <done>
- internal/proxy/debug.go exists with LogRequestDetails, LogResponseDetails, LogTLSMetrics, LogProxyMetrics functions
- AttachTLSTrace function creates httptrace for TLS metrics collection
- Sensitive data redaction patterns for api_key, password, token, secret
- internal/proxy/debug_test.go exists with 8+ unit tests
- All tests pass
- Code compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate debug logging into middleware and handler</name>
  <files>internal/proxy/middleware.go, internal/proxy/handler.go, cmd/cc-relay/serve.go</files>
  <action>
Update middleware and handler to call debug logging functions, and add --debug CLI flag.

**Step 1: Update internal/proxy/middleware.go**

Add import for config package if not present:
```go
import (
	// existing imports...
	"github.com/omarluq/cc-relay/internal/config"
)
```

Update LoggingMiddleware to accept DebugOptions and call LogRequestDetails:

```go
// LoggingMiddleware logs each request with method, path, and duration.
// If debugOpts has debug logging enabled, logs additional request/response details.
func LoggingMiddleware(debugOpts config.DebugOptions) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			start := time.Now()

			// Log request details in debug mode
			LogRequestDetails(r.Context(), r, debugOpts)

			// Wrap ResponseWriter to capture status code
			wrapped := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}

			// Log request start
			zerolog.Ctx(r.Context()).Info().
				Str("method", r.Method).
				Str("path", r.URL.Path).
				Str("remote_addr", r.RemoteAddr).
				Msg("request started")

			// Serve request
			next.ServeHTTP(wrapped, r)

			// Log request completion
			duration := time.Since(start)
			logger := zerolog.Ctx(r.Context()).With().
				Str("method", r.Method).
				Str("path", r.URL.Path).
				Int("status", wrapped.statusCode).
				Dur("duration_ms", duration).
				Logger()

			// Log response details in debug mode
			if debugOpts.IsEnabled() {
				LogResponseDetails(r.Context(), wrapped.Header(), wrapped.statusCode, 0, debugOpts)
			}

			if wrapped.statusCode >= 500 {
				logger.Error().Msg("request failed")
			} else if wrapped.statusCode >= 400 {
				logger.Warn().Msg("request error")
			} else {
				logger.Info().Msg("request completed")
			}
		})
	}
}
```

**Step 2: Update internal/proxy/handler.go**

Update Handler struct to include debugOpts:

```go
// Handler proxies requests to a backend provider.
type Handler struct {
	provider  providers.Provider
	proxy     *httputil.ReverseProxy
	apiKey    string
	debugOpts config.DebugOptions
}
```

Update NewHandler signature:

```go
// NewHandler creates a new proxy handler.
func NewHandler(provider providers.Provider, apiKey string, debugOpts config.DebugOptions) (*Handler, error) {
	// existing code...

	h := &Handler{
		provider:  provider,
		apiKey:    apiKey,
		debugOpts: debugOpts,
	}

	// rest of existing code...
}
```

Update ServeHTTP to log TLS and proxy metrics:

```go
// ServeHTTP handles the proxy request.
func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	start := time.Now()

	logger := zerolog.Ctx(r.Context()).With().
		Str("provider", h.provider.Name()).
		Str("backend_url", h.provider.BaseURL()).
		Logger()

	// Update context with provider-aware logger
	r = r.WithContext(logger.WithContext(r.Context()))

	// Attach TLS trace if debug metrics enabled
	var getTLSMetrics func() TLSMetrics
	if h.debugOpts.LogTLSMetrics {
		r = r.Clone(r.Context())
		newCtx, metricsFunc := AttachTLSTrace(r.Context(), r)
		r = r.WithContext(newCtx)
		getTLSMetrics = metricsFunc
	}

	// Log proxy start
	logger.Debug().Msg("proxying request to backend")

	// Proxy request
	backendStart := time.Now()
	h.proxy.ServeHTTP(w, r)
	backendTime := time.Since(backendStart)

	// Log TLS metrics if collected
	if getTLSMetrics != nil {
		tlsMetrics := getTLSMetrics()
		LogTLSMetrics(r.Context(), tlsMetrics, h.debugOpts)
	}

	// Log proxy metrics
	if h.debugOpts.IsEnabled() || logger.GetLevel() <= zerolog.DebugLevel {
		proxyMetrics := ProxyMetrics{
			BackendTime: backendTime,
			TotalTime:   time.Since(start),
			// BytesSent/BytesReceived would require wrapping http.ResponseWriter
			// StreamingEvents would require parsing SSE stream
			// Defer these to future enhancement
		}
		LogProxyMetrics(r.Context(), proxyMetrics, h.debugOpts)
	}
}
```

**Step 3: Update routes.go to pass debugOpts**

Find where NewHandler and LoggingMiddleware are called (likely in internal/proxy/routes.go) and pass cfg.Logging.DebugOptions:

```go
// Example in SetupRoutes or similar:
handler, err := NewHandler(provider, apiKey, cfg.Logging.DebugOptions)
// ...
handler = LoggingMiddleware(cfg.Logging.DebugOptions)(handler)
```

**Step 4: Add --debug flag to cmd/cc-relay/serve.go**

Find the serveCmd definition and add the flag:

```go
func init() {
	// Existing flags...
	serveCmd.Flags().String("config", "", "path to config file")

	// Add --debug flag
	serveCmd.Flags().Bool("debug", false, "enable debug mode (sets log level to debug and enables all debug options)")

	rootCmd.AddCommand(serveCmd)
}
```

In the serve command's Run function, after loading config:

```go
// Check for --debug flag
if debugFlag, _ := cmd.Flags().GetBool("debug"); debugFlag {
	cfg.Logging.EnableAllDebugOptions()
	log.Info().Msg("debug mode enabled via --debug flag")
}
```

**Why this design:**
- LoggingMiddleware accepts DebugOptions for flexible control
- Handler stores debugOpts to avoid passing through every call
- TLS trace only attached when needed (performance)
- --debug flag is convenient shortcut for common development use case
- Proxy metrics logged at debug level or when debug options enabled
  </action>
  <verify>
```bash
# Verify code compiles
go build ./...

# Test with debug config
cat > /tmp/debug-test.yaml << 'EOF'
logging:
  level: debug
  format: json
  debug_options:
    log_request_body: true
    log_response_headers: true
    log_tls_metrics: true
    max_body_log_size: 500

server:
  listen: ":8787"
  auth:
    api_key: test-key

providers:
  - name: anthropic
    type: anthropic
    enabled: true
    keys:
      - key: ${ANTHROPIC_API_KEY}
EOF

# Start server and verify debug logs appear
# go run ./cmd/cc-relay serve --config /tmp/debug-test.yaml

# Test --debug flag overrides config
# go run ./cmd/cc-relay serve --config /tmp/debug-test.yaml --debug

# Send test request and verify debug logs:
# curl -X POST http://localhost:8787/v1/messages \
#   -H "x-api-key: test-key" \
#   -H "Content-Type: application/json" \
#   -d '{"model":"claude-3-5-sonnet-20241022","messages":[{"role":"user","content":"test"}],"max_tokens":10}'

# Expected in logs:
# - "request details" with model and body preview
# - "tls metrics" with TLS version and timing
# - "proxy metrics" with backend time
# - "response details" with status and headers
```
  </verify>
  <done>
- LoggingMiddleware accepts DebugOptions parameter
- LoggingMiddleware calls LogRequestDetails and LogResponseDetails
- Handler struct has debugOpts field
- NewHandler accepts debugOpts parameter
- Handler.ServeHTTP attaches TLS trace when debug enabled
- Handler.ServeHTTP logs TLS metrics and proxy metrics
- routes.go passes cfg.Logging.DebugOptions to NewHandler and LoggingMiddleware
- cmd/cc-relay/serve.go has --debug flag
- --debug flag calls cfg.Logging.EnableAllDebugOptions()
- All code compiles
- Manual testing shows debug logs appear
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Unit tests pass:**
   ```bash
   go test ./internal/config/... -v
   go test ./internal/proxy/... -v -run TestDebug
   go test ./internal/proxy/... -v -run TestLog
   ```

2. **Integration test with debug config:**
   ```bash
   # Create comprehensive debug config
   cat > /tmp/full-debug.yaml << 'EOF'
   logging:
     level: debug
     format: json
     output: stdout
     pretty: false
     debug_options:
       log_request_body: true
       log_response_headers: true
       log_tls_metrics: true
       max_body_log_size: 1000

   server:
     listen: "127.0.0.1:8787"
     auth:
       api_key: debug-test-key

   providers:
     - name: anthropic
       type: anthropic
       enabled: true
       base_url: https://api.anthropic.com
       keys:
         - key: ${ANTHROPIC_API_KEY}
   EOF

   # Start proxy
   go run ./cmd/cc-relay serve --config /tmp/full-debug.yaml &
   PID=$!
   sleep 2

   # Send test request
   curl -X POST http://127.0.0.1:8787/v1/messages \
     -H "x-api-key: debug-test-key" \
     -H "Content-Type: application/json" \
     -d '{"model":"claude-3-5-sonnet-20241022","messages":[{"role":"user","content":"What is 2+2?"}],"max_tokens":50}' \
     2>&1 | tee /tmp/debug-output.log

   # Verify debug logs contain:
   grep -q "request details" /tmp/debug-output.log || echo "FAIL: No request details"
   grep -q "tls metrics" /tmp/debug-output.log || echo "FAIL: No TLS metrics"
   grep -q "proxy metrics" /tmp/debug-output.log || echo "FAIL: No proxy metrics"
   grep -q "response details" /tmp/debug-output.log || echo "FAIL: No response details"
   grep -q "model.*claude-3-5-sonnet" /tmp/debug-output.log || echo "FAIL: No model in logs"
   grep -q "tls_version" /tmp/debug-output.log || echo "FAIL: No TLS version"
   grep -q "backend_time_ms" /tmp/debug-output.log || echo "FAIL: No backend time"

   kill $PID
   ```

3. **Test --debug flag:**
   ```bash
   # Create minimal config (no debug options)
   cat > /tmp/minimal.yaml << 'EOF'
   logging:
     level: info
     format: json

   server:
     listen: "127.0.0.1:8788"
     auth:
       api_key: test-key

   providers:
     - name: anthropic
       type: anthropic
       enabled: true
       keys:
         - key: ${ANTHROPIC_API_KEY}
   EOF

   # Start with --debug flag
   go run ./cmd/cc-relay serve --config /tmp/minimal.yaml --debug 2>&1 | tee /tmp/debug-flag.log &
   PID=$!
   sleep 2

   # Send request
   curl -X POST http://127.0.0.1:8788/v1/messages \
     -H "x-api-key: test-key" \
     -H "Content-Type: application/json" \
     -d '{"model":"claude-3-5-sonnet-20241022","messages":[{"role":"user","content":"test"}],"max_tokens":5}'

   # Verify --debug flag enabled debug logging
   grep -q "debug mode enabled" /tmp/debug-flag.log || echo "FAIL: No debug mode message"
   grep -q "request details" /tmp/debug-flag.log || echo "FAIL: Debug flag didn't enable request details"

   kill $PID
   ```

4. **Test sensitive data redaction:**
   ```bash
   # Create test with sensitive data in body
   curl -X POST http://127.0.0.1:8787/v1/messages \
     -H "x-api-key: test-key" \
     -H "Content-Type: application/json" \
     -d '{"api_key":"sk-should-be-redacted","model":"claude-3-5-sonnet-20241022","password":"secret123","messages":[{"role":"user","content":"test"}],"max_tokens":5}' \
     2>&1 | tee /tmp/redaction-test.log

   # Verify sensitive data is redacted
   if grep -q "sk-should-be-redacted" /tmp/redaction-test.log; then
     echo "FAIL: API key not redacted"
   fi
   if grep -q "secret123" /tmp/redaction-test.log; then
     echo "FAIL: Password not redacted"
   fi
   grep -q "REDACTED" /tmp/redaction-test.log || echo "FAIL: No REDACTED placeholder"
   ```

5. **Test body size truncation:**
   ```bash
   # Create request with large body
   LARGE_BODY=$(python3 -c "import json; print(json.dumps({'model':'claude-3-5-sonnet-20241022','messages':[{'role':'user','content':'x'*10000}],'max_tokens':5}))")

   curl -X POST http://127.0.0.1:8787/v1/messages \
     -H "x-api-key: test-key" \
     -H "Content-Type: application/json" \
     -d "$LARGE_BODY" \
     2>&1 | tee /tmp/truncation-test.log

   # Verify body was truncated (should not contain full 10000 x's)
   X_COUNT=$(grep -o "x" /tmp/truncation-test.log | wc -l)
   if [ "$X_COUNT" -gt 1500 ]; then
     echo "FAIL: Body not truncated (found $X_COUNT x's)"
   fi
   ```
</verification>

<success_criteria>
**Code Quality:**
- [ ] All Go files compile without errors
- [ ] All existing tests pass
- [ ] New unit tests for debug utilities pass (8+ tests)
- [ ] golangci-lint passes (run `task lint`)
- [ ] gofmt compliance (run `task fmt`)

**Functional Requirements:**
- [ ] DebugOptions struct exists with 4 fields
- [ ] GetMaxBodyLogSize() returns 1000 default
- [ ] IsEnabled() checks if any debug option is on
- [ ] EnableAllDebugOptions() sets all fields
- [ ] debug.go exists with LogRequestDetails, LogResponseDetails, LogTLSMetrics, LogProxyMetrics
- [ ] AttachTLSTrace creates httptrace for metrics collection
- [ ] Sensitive patterns redact api_key, password, token, secret, authorization
- [ ] LoggingMiddleware accepts and uses DebugOptions
- [ ] Handler accepts and stores DebugOptions
- [ ] Handler.ServeHTTP attaches TLS trace when enabled
- [ ] Handler.ServeHTTP logs TLS metrics
- [ ] Handler.ServeHTTP logs proxy metrics
- [ ] cmd/cc-relay serve has --debug flag
- [ ] --debug flag calls EnableAllDebugOptions()

**Observable Behaviors:**
- [ ] Debug mode logs request body with model and max_tokens
- [ ] Request body is truncated to max_body_log_size
- [ ] Sensitive fields (api_key, password, token) are redacted as "REDACTED"
- [ ] Debug mode logs response headers (content-type, status, usage)
- [ ] Debug mode logs SSE streaming event count
- [ ] Debug mode logs TLS version (TLS 1.2, TLS 1.3, etc.)
- [ ] Debug mode logs TLS connection reuse (true/false)
- [ ] Debug mode logs DNS resolution time
- [ ] Debug mode logs TCP connect time
- [ ] Debug mode logs TLS handshake time
- [ ] Debug mode logs backend response time
- [ ] Debug mode logs total proxy latency
- [ ] --debug flag enables all debug options without config
- [ ] Starting with --debug flag logs "debug mode enabled" message
- [ ] Request body preview appears in logs at debug level
- [ ] TLS metrics appear in logs with timing breakdown
- [ ] Proxy metrics appear in logs with duration

**Configuration:**
- [ ] YAML config accepts debug_options section
- [ ] YAML config accepts log_request_body: true/false
- [ ] YAML config accepts log_response_headers: true/false
- [ ] YAML config accepts log_tls_metrics: true/false
- [ ] YAML config accepts max_body_log_size: <number>
- [ ] Default max_body_log_size is 1000 if not specified
- [ ] Debug options can be individually enabled/disabled
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-proxy/01-09-SUMMARY.md` with:
- Enhanced debug logging capabilities summary
- Configuration examples (YAML with debug_options)
- Example log outputs showing debug details
- Performance notes (TLS trace overhead)
- --debug flag usage examples
- Testing results
</output>
