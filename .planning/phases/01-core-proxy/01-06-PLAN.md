---
phase: 01-core-proxy
plan: 06
type: execute
wave: 5
depends_on: ["01-05"]
files_modified:
  - go.mod
  - go.sum
  - internal/config/config.go
  - cmd/cc-relay/main.go
  - internal/proxy/middleware.go
  - internal/proxy/handler.go
  - internal/providers/anthropic.go
  - internal/proxy/logger.go
  - internal/proxy/logger_test.go
autonomous: true

must_haves:
  truths:
    - "Proxy logs structured JSON or pretty console output based on config"
    - "Request IDs are present in all log entries for a given request"
    - "Auth success/failure is logged with correlation IDs"
    - "Proxy requests are logged with method, path, duration, status code"
    - "Log level can be changed via config (debug, info, warn, error)"
    - "Logs include provider name and backend URL for each request"
  artifacts:
    - path: "internal/config/config.go"
      provides: "LoggingConfig struct with level, format, output, pretty fields"
      contains: "type LoggingConfig struct"
    - path: "internal/proxy/logger.go"
      provides: "Logger initialization from config"
      exports: ["NewLogger", "AddRequestID", "FromRequest"]
    - path: "cmd/cc-relay/main.go"
      provides: "Logger initialization using zerolog from config"
      contains: "zerolog.New"
    - path: "internal/proxy/middleware.go"
      provides: "Request ID middleware and auth logging"
      contains: "X-Request-ID"
    - path: "internal/proxy/handler.go"
      provides: "Request/response logging with timing"
      contains: "zerolog.Ctx"
  key_links:
    - from: "cmd/cc-relay/main.go"
      to: "internal/proxy/logger.go"
      via: "NewLogger function"
      pattern: "proxy.NewLogger"
    - from: "internal/proxy/middleware.go"
      to: "internal/proxy/logger.go"
      via: "AddRequestID function"
      pattern: "AddRequestID.*WithContext"
    - from: "internal/proxy/handler.go"
      to: "request logger"
      via: "zerolog.Ctx(r.Context())"
      pattern: "zerolog\\.Ctx\\(.*Context\\(\\)\\)"
---

<objective>
Integrate zerolog for structured logging across cc-relay with request correlation tracking.

Purpose: Replace basic log/slog with production-ready structured logging that supports JSON and pretty console formats, configurable log levels, and request correlation IDs for debugging.

Output: Working structured logging with zerolog throughout the proxy, configurable via YAML, with comprehensive unit tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-proxy/01-RESEARCH.md
@.planning/phases/01-core-proxy/01-05-SUMMARY.md
@cmd/cc-relay/main.go
@internal/config/config.go
@internal/proxy/middleware.go
@internal/proxy/handler.go
@internal/providers/anthropic.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add zerolog dependency and expand LoggingConfig</name>
  <files>go.mod, go.sum, internal/config/config.go</files>
  <action>
Add zerolog dependency and extend LoggingConfig struct with fields needed for zerolog initialization.

**Step 1: Add dependency**
```bash
go get github.com/rs/zerolog@latest
go mod tidy
```

**Step 2: Extend LoggingConfig in internal/config/config.go**

The LoggingConfig struct already exists with basic fields. Extend it:

```go
// LoggingConfig defines logging behavior.
type LoggingConfig struct {
	Level  string `yaml:"level"`  // debug, info, warn, error (existing)
	Format string `yaml:"format"` // json, console (existing)
	Output string `yaml:"output"` // stdout, stderr, or file path (NEW)
	Pretty bool   `yaml:"pretty"` // enable colored console output (NEW)
}
```

Add a method to parse log level string to zerolog.Level:

```go
// ParseLevel converts a string log level to zerolog.Level.
// Returns zerolog.InfoLevel if the level string is invalid.
func (l *LoggingConfig) ParseLevel() zerolog.Level {
	switch strings.ToLower(l.Level) {
	case "debug":
		return zerolog.DebugLevel
	case "info":
		return zerolog.InfoLevel
	case "warn":
		return zerolog.WarnLevel
	case "error":
		return zerolog.ErrorLevel
	default:
		return zerolog.InfoLevel
	}
}
```

**Why this design:**
- `Output` field supports file logging in addition to stdout/stderr
- `Pretty` field enables colored console writer for development
- `ParseLevel()` method encapsulates level parsing logic (don't repeat in main.go)
- Default to InfoLevel for safety (not debug)
  </action>
  <verify>
```bash
# Verify dependency added
go list -m github.com/rs/zerolog

# Verify code compiles
go build ./internal/config/...

# Verify ParseLevel method works
go test ./internal/config/... -run TestLoggingConfig
```
  </verify>
  <done>
- go.mod contains github.com/rs/zerolog dependency
- LoggingConfig has Output and Pretty fields
- ParseLevel() method exists and converts strings to zerolog levels
- Code compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create logger initialization utility</name>
  <files>internal/proxy/logger.go, internal/proxy/logger_test.go</files>
  <action>
Create a new file `internal/proxy/logger.go` with utility functions for initializing zerolog loggers from config and managing request correlation IDs.

**internal/proxy/logger.go:**

```go
package proxy

import (
	"context"
	"io"
	"os"

	"github.com/google/uuid"
	"github.com/omarluq/cc-relay/internal/config"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
)

// RequestIDKey is the context key for request IDs.
type ctxKey string

const RequestIDKey ctxKey = "request_id"

// NewLogger creates a zerolog.Logger from LoggingConfig.
// Returns a configured logger ready for use as global logger.
func NewLogger(cfg config.LoggingConfig) (zerolog.Logger, error) {
	// Determine output writer
	var output io.Writer
	switch cfg.Output {
	case "", "stdout":
		output = os.Stdout
	case "stderr":
		output = os.Stderr
	default:
		// File output
		f, err := os.OpenFile(cfg.Output, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
		if err != nil {
			return zerolog.Logger{}, err
		}
		output = f
	}

	// Apply format
	if cfg.Format == "console" || cfg.Pretty {
		// Use ConsoleWriter for human-readable output
		consoleWriter := zerolog.ConsoleWriter{
			Out:        output,
			TimeFormat: "15:04:05",
			NoColor:    !cfg.Pretty,
		}
		output = consoleWriter
	}

	// Create logger with level
	logger := zerolog.New(output).
		Level(cfg.ParseLevel()).
		With().
		Timestamp().
		Logger()

	return logger, nil
}

// AddRequestID adds or extracts request ID from request headers and adds it to the context.
// If X-Request-ID header exists, use it. Otherwise, generate a new UUID.
func AddRequestID(ctx context.Context, requestID string) context.Context {
	if requestID == "" {
		requestID = uuid.New().String()
	}

	// Add to context for retrieval
	ctx = context.WithValue(ctx, RequestIDKey, requestID)

	// Add to zerolog context
	logger := log.Ctx(ctx).With().Str("request_id", requestID).Logger()
	return logger.WithContext(ctx)
}

// GetRequestID retrieves the request ID from context.
func GetRequestID(ctx context.Context) string {
	if id, ok := ctx.Value(RequestIDKey).(string); ok {
		return id
	}
	return ""
}
```

**internal/proxy/logger_test.go:**

```go
package proxy

import (
	"bytes"
	"encoding/json"
	"strings"
	"testing"

	"github.com/omarluq/cc-relay/internal/config"
	"github.com/rs/zerolog"
)

func TestNewLogger_JSONFormat(t *testing.T) {
	cfg := config.LoggingConfig{
		Level:  "info",
		Format: "json",
		Output: "stdout",
		Pretty: false,
	}

	logger, err := NewLogger(cfg)
	if err != nil {
		t.Fatalf("NewLogger failed: %v", err)
	}

	// Capture output
	var buf bytes.Buffer
	logger = logger.Output(&buf)

	logger.Info().Msg("test message")

	// Verify JSON format
	var logEntry map[string]interface{}
	if err := json.Unmarshal(buf.Bytes(), &logEntry); err != nil {
		t.Fatalf("Log output is not valid JSON: %v", err)
	}

	if logEntry["message"] != "test message" {
		t.Errorf("Expected message 'test message', got %v", logEntry["message"])
	}

	if logEntry["level"] != "info" {
		t.Errorf("Expected level 'info', got %v", logEntry["level"])
	}
}

func TestNewLogger_ConsoleFormat(t *testing.T) {
	cfg := config.LoggingConfig{
		Level:  "debug",
		Format: "console",
		Output: "stdout",
		Pretty: false,
	}

	logger, err := NewLogger(cfg)
	if err != nil {
		t.Fatalf("NewLogger failed: %v", err)
	}

	// Capture output
	var buf bytes.Buffer
	logger = logger.Output(&buf)

	logger.Debug().Msg("debug message")

	output := buf.String()
	if !strings.Contains(output, "debug message") {
		t.Errorf("Expected console output to contain 'debug message', got: %s", output)
	}
}

func TestNewLogger_LevelFiltering(t *testing.T) {
	cfg := config.LoggingConfig{
		Level:  "warn",
		Format: "json",
		Output: "stdout",
	}

	logger, err := NewLogger(cfg)
	if err != nil {
		t.Fatalf("NewLogger failed: %v", err)
	}

	var buf bytes.Buffer
	logger = logger.Output(&buf)

	// Debug and Info should be filtered out
	logger.Debug().Msg("should not appear")
	logger.Info().Msg("should not appear")
	logger.Warn().Msg("should appear")

	output := buf.String()
	if strings.Contains(output, "should not appear") {
		t.Errorf("Debug/Info logs should be filtered at warn level")
	}
	if !strings.Contains(output, "should appear") {
		t.Errorf("Warn logs should appear at warn level")
	}
}

func TestAddRequestID_GeneratesUUID(t *testing.T) {
	ctx := context.Background()
	ctx = AddRequestID(ctx, "")

	requestID := GetRequestID(ctx)
	if requestID == "" {
		t.Error("Expected generated UUID, got empty string")
	}

	// Verify it's a valid UUID format (basic check)
	if len(requestID) != 36 {
		t.Errorf("Expected UUID length 36, got %d", len(requestID))
	}
}

func TestAddRequestID_UsesProvidedID(t *testing.T) {
	ctx := context.Background()
	expectedID := "custom-request-id-123"
	ctx = AddRequestID(ctx, expectedID)

	requestID := GetRequestID(ctx)
	if requestID != expectedID {
		t.Errorf("Expected request ID %s, got %s", expectedID, requestID)
	}
}
```

**Why this design:**
- `NewLogger` handles all config combinations (JSON/console, pretty/plain, file/stdout)
- `AddRequestID` both generates UUIDs and accepts existing IDs (for X-Request-ID header preservation)
- Uses zerolog's context feature (`WithContext`) to attach logger to request context
- `GetRequestID` utility for retrieving ID later (useful for response headers)
  </action>
  <verify>
```bash
# Verify code compiles
go build ./internal/proxy/...

# Run unit tests
go test -v ./internal/proxy/ -run TestNewLogger
go test -v ./internal/proxy/ -run TestAddRequestID

# Verify all tests pass
go test ./internal/proxy/...
```
  </verify>
  <done>
- internal/proxy/logger.go exists with NewLogger, AddRequestID, GetRequestID functions
- internal/proxy/logger_test.go exists with comprehensive tests
- All unit tests pass
- Code compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Update main.go and add logging to middleware and handlers</name>
  <files>cmd/cc-relay/main.go, internal/proxy/middleware.go, internal/proxy/handler.go, internal/providers/anthropic.go</files>
  <action>
Replace log/slog with zerolog in main.go, add request ID middleware, and add structured logging to proxy components.

**Step 1: Update cmd/cc-relay/main.go**

Replace the slog setup (lines 26-28) with zerolog initialization:

```go
// Remove:
// logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
// slog.SetDefault(logger)

// Add after config load (around line 40):
logger, err := proxy.NewLogger(cfg.Logging)
if err != nil {
	// Fallback to console logger for error reporting
	log.Fatal().Err(err).Msg("failed to initialize logger")
}
log.Logger = logger
zerolog.DefaultContextLogger = &logger

// Change error logs to use zerolog:
// Before: slog.Error("failed to load config", "error", err, "path", *configPath)
// After:
log.Error().Err(err).Str("path", *configPath).Msg("failed to load config")

// Before: slog.Error("no enabled anthropic provider found in config")
// After:
log.Error().Msg("no enabled anthropic provider found in config")

// Before: slog.Error("failed to setup routes", "error", err)
// After:
log.Error().Err(err).Msg("failed to setup routes")

// Before: slog.Info("starting cc-relay", "listen", cfg.Server.Listen)
// After:
log.Info().Str("listen", cfg.Server.Listen).Msg("starting cc-relay")

// Before: slog.Error("server error", "error", err)
// After:
log.Error().Err(err).Msg("server error")

// Before: slog.Info("shutting down...")
// After:
log.Info().Msg("shutting down...")

// Before: slog.Error("shutdown error", "error", err)
// After:
log.Error().Err(err).Msg("shutdown error")

// Before: slog.Info("server stopped")
// After:
log.Info().Msg("server stopped")
```

Add imports:
```go
import (
	// Remove: "log/slog"
	// Add:
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
)
```

**Step 2: Add request ID middleware in internal/proxy/middleware.go**

Add after the existing AuthMiddleware function:

```go
import (
	"net/http"
	"time"

	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
)

// RequestIDMiddleware adds X-Request-ID header and logger with request ID to context.
func RequestIDMiddleware() func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			// Extract or generate request ID
			requestID := r.Header.Get("X-Request-ID")
			ctx := AddRequestID(r.Context(), requestID)

			// Write request ID to response header
			if requestID == "" {
				requestID = GetRequestID(ctx)
			}
			w.Header().Set("X-Request-ID", requestID)

			// Attach logger to request
			r = r.WithContext(ctx)

			next.ServeHTTP(w, r)
		})
	}
}

// LoggingMiddleware logs each request with method, path, and duration.
func LoggingMiddleware() func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			start := time.Now()

			// Wrap ResponseWriter to capture status code
			wrapped := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}

			// Log request start
			zerolog.Ctx(r.Context()).Info().
				Str("method", r.Method).
				Str("path", r.URL.Path).
				Str("remote_addr", r.RemoteAddr).
				Msg("request started")

			// Serve request
			next.ServeHTTP(wrapped, r)

			// Log request completion
			duration := time.Since(start)
			logger := zerolog.Ctx(r.Context()).With().
				Str("method", r.Method).
				Str("path", r.URL.Path).
				Int("status", wrapped.statusCode).
				Dur("duration_ms", duration).
				Logger()

			if wrapped.statusCode >= 500 {
				logger.Error().Msg("request failed")
			} else if wrapped.statusCode >= 400 {
				logger.Warn().Msg("request error")
			} else {
				logger.Info().Msg("request completed")
			}
		})
	}
}

// responseWriter wraps http.ResponseWriter to capture status code.
type responseWriter struct {
	http.ResponseWriter
	statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
	rw.statusCode = code
	rw.ResponseWriter.WriteHeader(code)
}
```

Update AuthMiddleware to log auth attempts:

```go
// In AuthMiddleware, after the providedKey check:
// Before return on missing key:
zerolog.Ctx(r.Context()).Warn().Msg("authentication failed: missing x-api-key header")
WriteError(w, http.StatusUnauthorized, "authentication_error", "missing x-api-key header")
return

// Before return on invalid key:
zerolog.Ctx(r.Context()).Warn().Msg("authentication failed: invalid x-api-key")
WriteError(w, http.StatusUnauthorized, "authentication_error", "invalid x-api-key")
return

// After successful auth, before next.ServeHTTP:
zerolog.Ctx(r.Context()).Debug().Msg("authentication succeeded")
next.ServeHTTP(w, r)
```

**Step 3: Update internal/proxy/handler.go**

Add logging to proxy handler:

```go
import (
	// Add:
	"github.com/rs/zerolog"
)

// In NewHandler, after creating handler, log provider setup:
// After h.proxy = &httputil.ReverseProxy{ ... }
// No direct logging here, but in ServeHTTP

// Update ServeHTTP method:
func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	logger := zerolog.Ctx(r.Context()).With().
		Str("provider", h.provider.Name()).
		Str("backend_url", h.provider.BaseURL()).
		Logger()

	// Update context with provider-aware logger
	r = r.WithContext(logger.WithContext(r.Context()))

	// Log proxy start
	logger.Debug().Msg("proxying request to backend")

	h.proxy.ServeHTTP(w, r)
}
```

**Step 4: Update internal/providers/anthropic.go**

Add logging to Authenticate method:

```go
import (
	// Add:
	"github.com/rs/zerolog/log"
)

// In Authenticate method, before return:
func (p *AnthropicProvider) Authenticate(req *http.Request, key string) error {
	req.Header.Set("x-api-key", key)

	// Log authentication (key is redacted for security)
	log.Ctx(req.Context()).Debug().
		Str("provider", p.name).
		Msg("added authentication header")

	return nil
}
```

**Step 5: Wire middleware in internal/proxy/routes.go or handler setup**

In the file where middleware is applied (check routes.go or main.go where SetupRoutes is used), ensure middleware order:

```go
// Apply middleware in this order:
// 1. RequestIDMiddleware (first - generates ID)
// 2. LoggingMiddleware (second - logs with ID)
// 3. AuthMiddleware (third - auth logs include ID)
// 4. Handler

handler = RequestIDMiddleware()(handler)
handler = LoggingMiddleware()(handler)
handler = AuthMiddleware(cfg.Server.APIKey)(handler)
```

**Why this design:**
- Request ID generated/extracted first so all logs include it
- LoggingMiddleware captures status code via wrapper (standard pattern)
- Debug-level logs for detailed flow, Info for request completion, Warn/Error for failures
- Provider and backend URL added to context for visibility
- Auth logs are separate from request completion logs (easier filtering)
  </action>
  <verify>
```bash
# Verify code compiles
go build ./...

# Run unit tests
go test ./...

# Test with actual config (manual verification)
# Create test config:
cat > /tmp/test-logging.yaml << 'EOF'
logging:
  level: debug
  format: json
  output: stdout
  pretty: false

server:
  listen: ":9999"
  api_key: test-key-123

providers:
  - name: anthropic-test
    type: anthropic
    enabled: true
    base_url: https://api.anthropic.com
    keys:
      - key: sk-test-xxx
EOF

# Start server and check logs are structured JSON with request_id
# go run ./cmd/cc-relay --config /tmp/test-logging.yaml

# Send test request and verify logs:
# curl -X POST http://localhost:9999/v1/messages \
#   -H "x-api-key: test-key-123" \
#   -H "Content-Type: application/json" \
#   -d '{"model":"claude-3-5-sonnet-20241022","messages":[{"role":"user","content":"hi"}],"max_tokens":10}'

# Expected log output (JSON with request_id field in every line)
```
  </verify>
  <done>
- cmd/cc-relay/main.go uses zerolog instead of slog
- Logger initialized from cfg.Logging
- All error/info logs use zerolog structured logging
- RequestIDMiddleware exists and adds X-Request-ID header
- LoggingMiddleware logs requests with method, path, duration, status
- AuthMiddleware logs auth attempts (success/failure)
- Handler.ServeHTTP logs provider name and backend URL
- Anthropic provider logs authentication
- Middleware applied in correct order (RequestID -> Logging -> Auth -> Handler)
- All code compiles
- Unit tests pass
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Dependency verification:**
   ```bash
   go list -m github.com/rs/zerolog
   ```

2. **Unit tests pass:**
   ```bash
   go test ./internal/config/... -v
   go test ./internal/proxy/... -v
   ```

3. **Integration test:**
   ```bash
   # Create test config
   cat > /tmp/zerolog-test.yaml << 'EOF'
   logging:
     level: debug
     format: json
     output: stdout
     pretty: false

   server:
     listen: ":8787"
     api_key: test-key-for-logging

   providers:
     - name: anthropic-dev
       type: anthropic
       enabled: true
       base_url: https://api.anthropic.com
       keys:
         - key: ${ANTHROPIC_API_KEY}
   EOF

   # Start proxy
   go run ./cmd/cc-relay --config /tmp/zerolog-test.yaml &
   PID=$!
   sleep 2

   # Send request and capture logs
   curl -X POST http://localhost:8787/v1/messages \
     -H "x-api-key: test-key-for-logging" \
     -H "X-Request-ID: test-request-123" \
     -H "Content-Type: application/json" \
     -d '{"model":"claude-3-5-sonnet-20241022","messages":[{"role":"user","content":"ping"}],"max_tokens":5}' \
     2>&1 | tee /tmp/response.log

   # Verify logs contain:
   # - "request_id":"test-request-123" in all entries
   # - "level":"info" or "debug"
   # - "provider":"anthropic-dev"
   # - "method":"POST"
   # - "path":"/v1/messages"
   # - "duration_ms" field
   # - "authentication succeeded"

   kill $PID
   ```

4. **Pretty console mode test:**
   ```bash
   # Test pretty console output
   cat > /tmp/pretty-test.yaml << 'EOF'
   logging:
     level: info
     format: console
     output: stdout
     pretty: true

   server:
     listen: ":8788"
     api_key: test-key

   providers:
     - name: test-provider
       type: anthropic
       enabled: true
       keys:
         - key: sk-test
   EOF

   go run ./cmd/cc-relay --config /tmp/pretty-test.yaml
   # Verify output is colored and human-readable (not JSON)
   ```

5. **Level filtering test:**
   ```bash
   # Set level to warn, verify debug/info logs don't appear
   sed -i 's/level: info/level: warn/' /tmp/pretty-test.yaml
   go run ./cmd/cc-relay --config /tmp/pretty-test.yaml
   # Should only see warn/error logs, not info/debug
   ```
</verification>

<success_criteria>
**Code Quality:**
- [ ] All Go files compile without errors
- [ ] All existing tests pass
- [ ] New unit tests for logger utilities pass
- [ ] golangci-lint passes (run `task lint`)
- [ ] gofmt compliance (run `task fmt`)

**Functional Requirements:**
- [ ] Zerolog dependency added to go.mod
- [ ] LoggingConfig extended with Output and Pretty fields
- [ ] ParseLevel() method converts config strings to zerolog.Level
- [ ] NewLogger() creates zerolog logger from config
- [ ] Logger supports JSON format (structured output)
- [ ] Logger supports console format (human-readable)
- [ ] Logger supports pretty mode (colored console)
- [ ] Logger respects level filtering (debug/info/warn/error)
- [ ] Logger can write to stdout, stderr, or file
- [ ] RequestIDMiddleware adds X-Request-ID header
- [ ] RequestIDMiddleware generates UUID if header missing
- [ ] RequestIDMiddleware preserves existing X-Request-ID
- [ ] All logs include request_id field
- [ ] LoggingMiddleware logs request start and completion
- [ ] LoggingMiddleware captures method, path, status, duration
- [ ] AuthMiddleware logs authentication attempts
- [ ] Handler logs provider name and backend URL
- [ ] Anthropic provider logs authentication header addition

**Observable Behaviors:**
- [ ] Starting proxy with JSON format produces structured JSON logs
- [ ] Starting proxy with console format produces human-readable logs
- [ ] Pretty mode produces colored output in terminal
- [ ] Each request generates logs with consistent request_id
- [ ] Failed auth produces warn-level log before 401 response
- [ ] Successful request produces info-level completion log with timing
- [ ] 4xx responses produce warn-level logs
- [ ] 5xx responses produce error-level logs
- [ ] Debug level shows detailed flow (auth, proxy start, header forwarding)
- [ ] Info level shows request summary only
- [ ] Warn level shows only errors and warnings
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-proxy/01-06-SUMMARY.md` with:
- Zerolog integration summary
- Configuration options added
- Logging patterns established (request ID, structured fields)
- Example log outputs (JSON and console formats)
- Testing results
</output>
