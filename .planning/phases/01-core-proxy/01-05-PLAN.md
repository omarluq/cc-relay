---
phase: 01-core-proxy
plan: 05
type: execute
wave: 4
depends_on: ["01-04"]
files_modified:
  - internal/proxy/handler_integration_test.go
autonomous: false

must_haves:
  truths:
    - "Proxy can forward requests to real Anthropic API"
    - "SSE streaming works without visible buffering delays"
    - "tool_use_id is preserved in parallel tool call scenarios"
    - "Extended thinking content blocks stream correctly"
    - "Invalid API keys are rejected before hitting backend"
    - "Error responses (400, 500, 502) match exact Anthropic format"
  artifacts:
    - path: "internal/proxy/handler_integration_test.go"
      provides: "Integration tests for full proxy flow"
      exports: []
  key_links:
    - from: "cmd/cc-relay/main.go"
      to: "real Anthropic API"
      via: "HTTP proxy"
      pattern: "api.anthropic.com"
---

<objective>
Verify the complete proxy works end-to-end with real Anthropic API and Claude Code.

Purpose: Integration testing to confirm Phase 1 success criteria are met - SSE streaming works, tool_use_id is preserved, authentication works, and the proxy is transparent to Claude Code.

Output: Verified working proxy that passes all integration tests and can be used with Claude Code.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-proxy/01-RESEARCH.md
@.planning/phases/01-core-proxy/01-01-SUMMARY.md
@.planning/phases/01-core-proxy/01-02-SUMMARY.md
@.planning/phases/01-core-proxy/01-03-SUMMARY.md
@.planning/phases/01-core-proxy/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create integration test suite</name>
  <files>internal/proxy/handler_integration_test.go</files>
  <action>
Create integration tests that verify the full proxy flow:

**handler_integration_test.go:**
```go
//go:build integration
// +build integration

package proxy_test

// Tests require ANTHROPIC_API_KEY environment variable
// Run with: go test -tags=integration -v ./internal/proxy/...

func TestIntegration_NonStreamingRequest(t *testing.T) {
    // 1. Start proxy server with test config
    // 2. Send non-streaming request through proxy
    // 3. Verify response has correct format
    // 4. Verify response contains expected content
}

func TestIntegration_StreamingRequest(t *testing.T) {
    // 1. Start proxy server
    // 2. Send streaming request ("stream": true)
    // 3. Verify SSE events arrive incrementally (not buffered)
    // 4. Verify event sequence: message_start -> content_block_start -> deltas -> stops
}

func TestIntegration_ToolUseIdPreservation(t *testing.T) {
    // 1. Start proxy server
    // 2. Send request with tool_result containing tool_use_id
    // 3. Verify tool_use_id is preserved in response
}

func TestIntegration_AuthenticationRejection(t *testing.T) {
    // 1. Start proxy server with required API key
    // 2. Send request without x-api-key header
    // 3. Verify 401 response in Anthropic error format
}

func TestIntegration_HeaderForwarding(t *testing.T) {
    // 1. Start proxy server
    // 2. Send request with anthropic-version and anthropic-beta headers
    // 3. Verify headers are forwarded (by checking response behavior)
}

func TestIntegration_ErrorFormatCompliance(t *testing.T) {
    // Verify ALL error responses match exact Anthropic format
    // Test cases:
    // 1. 401 (missing key) - already covered above
    // 2. 400 (invalid request - use malformed JSON body)
    // 3. 502 (upstream failure - use invalid backend URL)
    //
    // Each must return: {"type":"error","error":{"type":"...","message":"..."}}
}
```

Tests are tagged with `integration` so they don't run in normal CI (they require real API key).

For streaming test, verify events arrive incrementally:
```go
func verifyStreamingBehavior(resp *http.Response) error {
    scanner := bufio.NewScanner(resp.Body)
    var eventCount int
    var lastEventTime time.Time

    for scanner.Scan() {
        now := time.Now()
        if !lastEventTime.IsZero() {
            // Events should arrive quickly (within 5s of each other)
            if now.Sub(lastEventTime) > 5*time.Second {
                // This could indicate buffering
            }
        }
        lastEventTime = now
        eventCount++
    }
    return nil
}
```

For error format compliance test:
```go
func TestIntegration_ErrorFormatCompliance(t *testing.T) {
    // Start proxy with invalid backend URL to trigger 502
    cfg := &config.Config{
        Server: config.ServerConfig{
            Listen: "127.0.0.1:0",
            APIKey: "test-key",
        },
    }
    provider := providers.NewAnthropicProvider("test", "http://localhost:1") // Invalid backend
    handler, _ := proxy.SetupRoutes(cfg, provider, "fake-key")

    // Test 502 error format
    req := httptest.NewRequest("POST", "/v1/messages", strings.NewReader(`{"model":"test"}`))
    req.Header.Set("x-api-key", "test-key")
    rec := httptest.NewRecorder()
    handler.ServeHTTP(rec, req)

    // Verify error format
    var errResp struct {
        Type  string `json:"type"`
        Error struct {
            Type    string `json:"type"`
            Message string `json:"message"`
        } `json:"error"`
    }
    if err := json.Unmarshal(rec.Body.Bytes(), &errResp); err != nil {
        t.Fatalf("failed to parse error response: %v", err)
    }
    if errResp.Type != "error" {
        t.Errorf("type = %q, want \"error\"", errResp.Type)
    }
    if errResp.Error.Type != "api_error" {
        t.Errorf("error.type = %q, want \"api_error\"", errResp.Error.Type)
    }
}
```
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go build ./internal/proxy/...
# Integration tests require API key, just verify they compile
# Verify error format test exists
grep -n "ErrorFormat\|error.*format" /home/omarluq/sandbox/go/cc-relay/internal/proxy/handler_integration_test.go
```
  </verify>
  <done>Integration tests compile, tagged for separate execution, includes error format compliance test</done>
</task>

<task type="auto">
  <name>Task 2: Create test configuration</name>
  <files>testdata/test-config.yaml</files>
  <action>
Create a test configuration file for integration testing:

**testdata/test-config.yaml:**
```yaml
# Test configuration for integration tests
# Uses environment variables for API keys

server:
  listen: "127.0.0.1:0"  # Random port for tests
  timeout_ms: 60000
  api_key: "test-proxy-key"  # Key clients must use

providers:
  - name: "anthropic"
    type: "anthropic"
    enabled: true
    keys:
      - key: "${ANTHROPIC_API_KEY}"

logging:
  level: "debug"
  format: "text"
```

This config:
- Uses port 0 so tests get a random available port
- Requires proxy API key for incoming requests
- Uses ANTHROPIC_API_KEY from environment for backend
  </action>
  <verify>
```bash
ls -la /home/omarluq/sandbox/go/cc-relay/testdata/test-config.yaml
```
  </verify>
  <done>Test config file created with environment variable placeholders</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete proxy that forwards requests to Anthropic API with SSE streaming support:
- HTTP server on port 8787 (or configured port)
- Authentication middleware validates x-api-key header
- Proxy forwards requests to Anthropic preserving all fields
- SSE streaming flushes immediately (FlushInterval: -1)
- Headers forwarded: anthropic-version, anthropic-beta, etc.
- Error responses match exact Anthropic format for 401, 400, 500, 502
  </what-built>
  <how-to-verify>
1. **Build and start the proxy:**
   ```bash
   cd /home/omarluq/sandbox/go/cc-relay
   go build -o cc-relay ./cmd/cc-relay/...

   # Create a test config (or use example.yaml)
   cp example.yaml config.yaml
   # Edit config.yaml to set a simple api_key under server section
   # e.g., add "api_key: test-key" under server:

   # Start proxy (requires ANTHROPIC_API_KEY env var)
   ANTHROPIC_API_KEY=your-key ./cc-relay
   ```

2. **Test basic proxy functionality with curl:**
   ```bash
   # Test auth rejection (no key) - should return 401 in Anthropic format
   curl -X POST http://localhost:8787/v1/messages \
     -H "Content-Type: application/json" \
     -d '{"model":"claude-sonnet-4-5-20250929","max_tokens":10,"messages":[{"role":"user","content":"Hi"}]}'
   # Verify response is: {"type":"error","error":{"type":"authentication_error","message":"..."}}

   # Test successful request (with key)
   curl -X POST http://localhost:8787/v1/messages \
     -H "Content-Type: application/json" \
     -H "x-api-key: test-key" \
     -H "anthropic-version: 2023-06-01" \
     -d '{"model":"claude-sonnet-4-5-20250929","max_tokens":100,"messages":[{"role":"user","content":"Say hello"}]}'
   # Should return JSON response from Claude

   # Test streaming
   curl -X POST http://localhost:8787/v1/messages \
     -H "Content-Type: application/json" \
     -H "x-api-key: test-key" \
     -H "anthropic-version: 2023-06-01" \
     -d '{"model":"claude-sonnet-4-5-20250929","max_tokens":100,"stream":true,"messages":[{"role":"user","content":"Count to 5"}]}'
   # Should show SSE events arriving incrementally, not all at once
   ```

3. **Verify error formats match Anthropic (API-07 requirement):**
   ```bash
   # Test 400 - invalid request (malformed JSON)
   curl -X POST http://localhost:8787/v1/messages \
     -H "Content-Type: application/json" \
     -H "x-api-key: test-key" \
     -H "anthropic-version: 2023-06-01" \
     -d 'not valid json'
   # Should return: {"type":"error","error":{"type":"invalid_request_error","message":"..."}}

   # Note: 500/502 errors are harder to trigger manually but are covered in integration tests
   ```

4. **Test with Claude Code (optional but recommended):**
   ```bash
   # In another terminal, configure Claude Code to use proxy
   export ANTHROPIC_BASE_URL="http://localhost:8787"
   export ANTHROPIC_API_KEY="test-key"
   claude  # Start Claude Code

   # Send a message and verify streaming works
   # Try parallel tool calls if possible
   ```

5. **Verify health endpoint:**
   ```bash
   curl http://localhost:8787/health
   # Should return {"status":"ok"}
   ```
  </how-to-verify>
  <resume-signal>Type "approved" if proxy works correctly, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
```bash
# Build and verify
cd /home/omarluq/sandbox/go/cc-relay && go build ./...
cd /home/omarluq/sandbox/go/cc-relay && go test ./...

# Integration tests (requires ANTHROPIC_API_KEY)
# cd /home/omarluq/sandbox/go/cc-relay && go test -tags=integration -v ./internal/proxy/...
```
</verification>

<success_criteria>
- [ ] Integration tests compile (tagged, not run in normal CI)
- [ ] Test config created with environment variable support
- [ ] Proxy starts and listens on configured port
- [ ] Auth rejection returns 401 in Anthropic error format
- [ ] Valid requests are proxied to Anthropic
- [ ] Streaming responses arrive incrementally (no buffering)
- [ ] Error responses (400, 500, 502) match exact Anthropic format
- [ ] Health endpoint returns 200
- [ ] Manual verification with curl passes
- [ ] (Optional) Claude Code can connect and work through proxy
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-proxy/01-05-SUMMARY.md`
</output>
