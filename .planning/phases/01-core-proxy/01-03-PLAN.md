---
phase: 01-core-proxy
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - internal/proxy/handler.go
  - internal/proxy/sse.go
autonomous: true

must_haves:
  truths:
    - "Proxy handler accepts POST /v1/messages requests"
    - "Request body is forwarded with all fields preserved (including tool_use_id)"
    - "SSE streaming flushes each event immediately (no buffering)"
    - "SSE headers are set correctly for nginx/CDN compatibility"
    - "anthropic-* headers from client are forwarded to backend"
    - "Backend response is streamed to client in real-time"
  artifacts:
    - path: "internal/proxy/handler.go"
      provides: "Proxy request handler using httputil.ReverseProxy"
      exports: ["Handler", "NewHandler"]
    - path: "internal/proxy/sse.go"
      provides: "SSE streaming utilities"
      exports: ["SetSSEHeaders", "IsStreamingRequest"]
  key_links:
    - from: "internal/proxy/handler.go"
      to: "internal/providers/provider.go"
      via: "uses Provider interface for authentication"
      pattern: "Provider\\."
    - from: "internal/proxy/handler.go"
      to: "internal/proxy/sse.go"
      via: "uses SSE utilities for streaming"
      pattern: "SetSSEHeaders\\|IsStreamingRequest"
    - from: "internal/proxy/handler.go"
      to: "internal/proxy/errors.go"
      via: "uses WriteError in ErrorHandler callback for upstream failures"
      pattern: "ErrorHandler.*WriteError"
---

<objective>
Create the core proxy handler that forwards requests to Anthropic with correct SSE streaming.

Purpose: Build the heart of cc-relay - the proxy handler that accepts Claude Code requests, transforms them for the backend provider, and streams responses back with immediate flushing. This must preserve all request fields (especially tool_use_id) and handle SSE streaming correctly.

Output: Working proxy handler that can forward requests to Anthropic and stream responses back to Claude Code without buffering delays.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-proxy/01-RESEARCH.md
@.planning/phases/01-core-proxy/01-01-SUMMARY.md
@.planning/phases/01-core-proxy/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: SSE streaming utilities</name>
  <files>internal/proxy/sse.go</files>
  <action>
Create SSE streaming utilities for proper real-time event delivery:

**sse.go:**
```go
// IsStreamingRequest checks if request body contains "stream": true
func IsStreamingRequest(body []byte) bool {
    // Parse as map to check stream field
    var req map[string]interface{}
    if err := json.Unmarshal(body, &req); err != nil {
        return false
    }
    stream, ok := req["stream"].(bool)
    return ok && stream
}

// SetSSEHeaders sets required headers for SSE streaming
// These headers MUST be set for proper streaming through nginx/CDN
func SetSSEHeaders(h http.Header) {
    h.Set("Content-Type", "text/event-stream")
    h.Set("Cache-Control", "no-cache, no-transform")
    h.Set("X-Accel-Buffering", "no")  // CRITICAL for nginx
    h.Set("Connection", "keep-alive")
}
```

Header requirements from Anthropic docs:
- `Content-Type: text/event-stream` - SSE format
- `Cache-Control: no-cache, no-transform` - prevent caching
- `X-Accel-Buffering: no` - CRITICAL: disable nginx/Cloudflare buffering
- `Connection: keep-alive` - maintain streaming connection
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go build ./internal/proxy/...
```
  </verify>
  <done>SSE utilities compile, IsStreamingRequest parses stream field, SetSSEHeaders sets all 4 required headers</done>
</task>

<task type="auto">
  <name>Task 2: Proxy handler with ReverseProxy and Rewrite function</name>
  <files>internal/proxy/handler.go</files>
  <action>
Create the proxy handler using modern ReverseProxy pattern with Rewrite function:

**handler.go:**
```go
// Handler proxies requests to a backend provider
type Handler struct {
    provider  providers.Provider
    apiKey    string  // Backend provider API key
    proxy     *httputil.ReverseProxy
}

// NewHandler creates a new proxy handler
func NewHandler(provider providers.Provider, apiKey string) (*Handler, error) {
    targetURL, err := url.Parse(provider.BaseURL())
    if err != nil {
        return nil, fmt.Errorf("invalid provider base URL: %w", err)
    }

    h := &Handler{
        provider: provider,
        apiKey:   apiKey,
    }

    h.proxy = &httputil.ReverseProxy{
        Rewrite: func(r *httputil.ProxyRequest) {
            // Set backend URL
            r.SetURL(targetURL)
            r.SetXForwarded()

            // Authenticate with provider
            h.provider.Authenticate(r.Out, h.apiKey)

            // Forward anthropic-* headers
            forwardHeaders := h.provider.ForwardHeaders(r.In.Header)
            for key, values := range forwardHeaders {
                r.Out.Header[key] = values
            }
        },

        // CRITICAL: Immediate flush for SSE streaming
        FlushInterval: -1,

        ModifyResponse: func(resp *http.Response) error {
            // Add SSE headers if streaming response
            if resp.Header.Get("Content-Type") == "text/event-stream" {
                SetSSEHeaders(resp.Header)
            }
            return nil
        },

        ErrorHandler: func(w http.ResponseWriter, r *http.Request, err error) {
            // Use Anthropic-format error response (key_link to errors.go)
            WriteError(w, http.StatusBadGateway, "api_error", "upstream connection failed")
        },
    }

    return h, nil
}

// ServeHTTP handles the proxy request
func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    h.proxy.ServeHTTP(w, r)
}
```

Key requirements:
- Use `Rewrite` function (NOT deprecated `Director`)
- Set `FlushInterval: -1` for immediate SSE flushing
- Forward all anthropic-* headers via provider.ForwardHeaders()
- Use provider.Authenticate() to add backend API key
- Handle errors with Anthropic-format error responses via WriteError (from errors.go)
- DO NOT parse/modify request body - pass through to preserve tool_use_id
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go build ./internal/proxy/...
# Verify ErrorHandler uses WriteError (key_link to errors.go)
grep -n "ErrorHandler" /home/omarluq/sandbox/go/cc-relay/internal/proxy/handler.go | head -5
grep -n "WriteError" /home/omarluq/sandbox/go/cc-relay/internal/proxy/handler.go
```
  </verify>
  <done>Handler compiles, uses Rewrite function, FlushInterval: -1, forwards headers correctly, ErrorHandler calls WriteError</done>
</task>

<task type="auto">
  <name>Task 3: Unit tests for handler and SSE</name>
  <files>internal/proxy/handler_test.go, internal/proxy/sse_test.go</files>
  <action>
Create unit tests for proxy handler and SSE utilities:

**sse_test.go:**
- TestIsStreamingRequest_True: `{"stream": true}` returns true
- TestIsStreamingRequest_False: `{"stream": false}` returns false
- TestIsStreamingRequest_Missing: `{}` returns false
- TestIsStreamingRequest_InvalidJSON: returns false
- TestSetSSEHeaders: verify all 4 headers are set correctly

**handler_test.go:**
- TestNewHandler_ValidProvider: creates handler successfully
- TestNewHandler_InvalidURL: returns error for bad base URL
- TestHandler_ForwardsAnthropicHeaders: verify anthropic-beta, anthropic-version forwarded
- TestHandler_HasErrorHandler: verify ErrorHandler is configured and uses WriteError
- TestHandler_StructureCorrect: verify Handler has provider, apiKey, proxy fields (structure check without external deps)
- Use httptest.Server to mock backend

Key test for tool_use_id preservation:
```go
func TestHandler_PreservesToolUseId(t *testing.T) {
    // Create mock backend that echoes request body
    // Send request with tool_use_id field
    // Verify tool_use_id appears in forwarded request unchanged
}
```

Key test for handler structure (verifies wiring without external dependencies):
```go
func TestHandler_StructureCorrect(t *testing.T) {
    provider := providers.NewAnthropicProvider("test", "https://api.anthropic.com")
    handler, err := NewHandler(provider, "test-key")
    if err != nil {
        t.Fatalf("NewHandler failed: %v", err)
    }
    // Verify handler has non-nil proxy
    if handler.proxy == nil {
        t.Error("handler.proxy is nil")
    }
    // Verify FlushInterval is set to -1
    if handler.proxy.FlushInterval != -1 {
        t.Errorf("FlushInterval = %v, want -1", handler.proxy.FlushInterval)
    }
}
```

Keep tests focused on HTTP behavior, not full integration.
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go test -v ./internal/proxy/...
# Verify handler structure test exists
grep -n "TestHandler_StructureCorrect\|TestHandler.*Structure" /home/omarluq/sandbox/go/cc-relay/internal/proxy/handler_test.go
```
  </verify>
  <done>All handler and SSE tests pass, tool_use_id preservation verified, handler structure verified without external dependencies</done>
</task>

</tasks>

<verification>
```bash
# All packages build
cd /home/omarluq/sandbox/go/cc-relay && go build ./internal/proxy/...

# All tests pass
cd /home/omarluq/sandbox/go/cc-relay && go test -v ./internal/proxy/...

# Verify FlushInterval is set to -1 (critical for SSE)
grep -n "FlushInterval.*-1" /home/omarluq/sandbox/go/cc-relay/internal/proxy/handler.go

# Verify ErrorHandler uses WriteError (key_link)
grep -A2 "ErrorHandler" /home/omarluq/sandbox/go/cc-relay/internal/proxy/handler.go | grep "WriteError"

# Verify handler structure test exists (tests wiring without external deps)
grep -c "TestHandler.*Structure\|proxy.*FlushInterval" /home/omarluq/sandbox/go/cc-relay/internal/proxy/handler_test.go
```
</verification>

<success_criteria>
- [ ] IsStreamingRequest correctly detects "stream": true in request body
- [ ] SetSSEHeaders sets all 4 required headers (Content-Type, Cache-Control, X-Accel-Buffering, Connection)
- [ ] Handler uses httputil.ReverseProxy with Rewrite function (not Director)
- [ ] Handler sets FlushInterval: -1 for immediate SSE flushing
- [ ] Handler forwards anthropic-* headers to backend
- [ ] Handler uses provider.Authenticate() for API key injection
- [ ] Handler does NOT modify request body (preserves tool_use_id)
- [ ] Handler ErrorHandler calls WriteError for Anthropic-format errors
- [ ] Unit tests pass for SSE and handler
- [ ] Handler structure test verifies FlushInterval without external dependencies
- [ ] `go build ./internal/proxy/...` succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-proxy/01-03-SUMMARY.md`
</output>
