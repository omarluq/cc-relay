---
phase: 01-core-proxy
plan: 08
type: execute
wave: 6
depends_on: ["01-07"]
files_modified:
  - internal/auth/subscription.go
  - internal/auth/subscription_test.go
  - internal/config/config.go
  - internal/proxy/middleware.go
  - internal/proxy/routes.go
  - example.yaml
  - README.md
autonomous: false

must_haves:
  truths:
    - "Claude Code users with subscription tokens can authenticate to cc-relay"
    - "Subscription tokens are validated (or passed through) correctly"
    - "Invalid subscription tokens return 401 with clear error message"
    - "Config option exists to enable/disable subscription auth"
    - "Documentation explains how Claude Code users configure subscription tokens"
  artifacts:
    - path: "internal/auth/subscription.go"
      provides: "SubscriptionAuthenticator for Claude Code tokens"
      exports: ["NewSubscriptionAuthenticator", "SubscriptionAuthenticator"]
    - path: "internal/auth/subscription_test.go"
      provides: "Unit tests for subscription auth"
      min_lines: 50
    - path: "internal/config/config.go"
      provides: "AuthConfig with subscription validation settings"
      contains: "AllowSubscription"
    - path: "example.yaml"
      provides: "Example subscription auth config"
      contains: "allow_subscription"
  key_links:
    - from: "internal/proxy/middleware.go"
      to: "internal/auth/subscription.go"
      via: "NewSubscriptionAuthenticator in chain"
      pattern: "NewSubscriptionAuthenticator"
    - from: "internal/config/config.go"
      to: "internal/auth/subscription.go"
      via: "AuthConfig.AllowSubscription flag"
      pattern: "AllowSubscription.*bool"
---

<objective>
Add Claude Code subscription token authentication support to cc-relay, enabling subscription users to authenticate with their session tokens.

Purpose: Claude Code users authenticate differently based on whether they use API keys or subscriptions. This plan adds support for subscription tokens, making cc-relay accessible to all Claude Code users, not just those with API keys.

Output: Working subscription token authentication with config options, tests, and documentation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-proxy/01-RESEARCH.md
@.planning/phases/01-core-proxy/01-07-SUMMARY.md
@internal/auth/auth.go
@internal/auth/oauth.go
@internal/auth/chain.go
@internal/config/config.go
@internal/proxy/middleware.go
@example.yaml
</context>

<tasks>

<task type="checkpoint:decision" gate="blocking">
  <decision>Determine Claude Code subscription token authentication mechanism</decision>
  <context>
Before implementing subscription token support, we need to understand how Claude Code actually authenticates subscription users. The existing BearerAuthenticator (oauth.go) provides generic Bearer token support, but Claude Code subscription tokens may require special handling.

**Current State:**
- BearerAuthenticator validates Authorization: Bearer tokens
- If `bearer_secret` is empty, any token is accepted
- If `bearer_secret` is set, tokens are validated via constant-time comparison

**Unknown:**
1. What format do Claude Code subscription tokens use? (JWT, opaque session token, other?)
2. Does Claude Code send subscription tokens as Bearer tokens?
3. Do subscription tokens need to be validated against Anthropic's API?
4. Or should they be passed through to Anthropic for validation?
5. Are there specific headers Claude Code sends for subscription users?

**Research needed:**
- Check Claude Code CLI source code (if available)
- Test with actual Claude Code subscription account
- Review Anthropic API docs for subscription auth
- Network trace Claude Code requests with subscription vs API key
  </context>
  <options>
    <option id="option-a">
      <name>Passthrough Mode - Forward subscription tokens to Anthropic</name>
      <pros>
        - Simplest implementation (no validation logic needed)
        - Always up-to-date (Anthropic validates)
        - No risk of false rejections
      </pros>
      <cons>
        - Can't reject invalid tokens early (wastes backend call)
        - Relies on Anthropic for all validation
        - May expose rate limiting if Anthropic counts these differently
      </cons>
    </option>
    <option id="option-b">
      <name>JWT Validation - Decode and validate JWT signature locally</name>
      <pros>
        - Fast rejection of invalid tokens (no backend call)
        - Can extract user info from token claims
        - Standard approach for JWT-based auth
      </pros>
      <cons>
        - Requires Anthropic's public key for signature verification
        - Needs JWT library dependency
        - May break if Anthropic changes token format
      </cons>
    </option>
    <option id="option-c">
      <name>API Validation - Call Anthropic validation endpoint</name>
      <pros>
        - Authoritative validation (Anthropic confirms)
        - Handles token revocation correctly
        - No local state needed
      </pros>
      <cons>
        - Adds latency to every request
        - Requires validation endpoint discovery
        - Extra API calls may count against rate limits
      </cons>
    </option>
    <option id="option-d">
      <name>No Special Handling - Use existing BearerAuthenticator</name>
      <pros>
        - Zero implementation needed
        - Already works if tokens are standard Bearer
        - Simple config (set allow_bearer: true, no bearer_secret)
      </pros>
      <cons>
        - May not work if Claude Code uses non-standard auth
        - No subscription-specific features
        - Can't distinguish subscription vs other Bearer tokens
      </cons>
    </option>
  </options>
  <resume-signal>
Select an option (option-a, option-b, option-c, option-d) or provide research findings.

If you have access to Claude Code subscription account, please test:
```bash
# Set subscription token as env var
export ANTHROPIC_API_KEY="your-subscription-token"

# Start cc-relay with bearer auth enabled
cat > test-config.yaml << EOF
server:
  listen: "127.0.0.1:8787"
  auth:
    allow_bearer: true
    # No bearer_secret = accept any token
providers:
  - name: "anthropic"
    type: "anthropic"
    enabled: true
    keys:
      - key: "${REAL_ANTHROPIC_API_KEY}"
EOF

./cc-relay serve --config test-config.yaml

# In another terminal, test Claude Code
export ANTHROPIC_BASE_URL="http://localhost:8787"
claude "test message"
```

Report back with:
1. Does Claude Code send Authorization: Bearer token?
2. What error (if any) occurs?
3. Network trace of the request headers
  </resume-signal>
</task>

<task type="auto">
  <name>Task 1: Implement subscription token authenticator</name>
  <files>internal/auth/subscription.go, internal/auth/subscription_test.go</files>
  <action>
Implement SubscriptionAuthenticator based on decision from checkpoint.

**If option-a (Passthrough):**
Create a passthrough authenticator that validates token format but doesn't validate content:

```go
// SubscriptionAuthenticator accepts Claude Code subscription tokens.
// It validates token format but defers actual validation to Anthropic backend.
type SubscriptionAuthenticator struct {
    // No secret validation - passthrough mode
}

func (s *SubscriptionAuthenticator) Validate(r *http.Request) Result {
    authHeader := r.Header.Get("Authorization")

    // Check for Bearer token format
    if !strings.HasPrefix(authHeader, "Bearer ") {
        return Result{Valid: false, Type: TypeBearer, Error: "missing bearer token"}
    }

    token := strings.TrimSpace(authHeader[7:])

    // Basic format validation (non-empty, reasonable length)
    if token == "" || len(token) < 10 {
        return Result{Valid: false, Type: TypeBearer, Error: "invalid token format"}
    }

    // Accept token - actual validation happens at Anthropic
    return Result{Valid: true, Type: TypeBearer, Token: token}
}
```

**If option-b (JWT):**
Decode JWT and validate signature:

```go
import "github.com/golang-jwt/jwt/v5"

type SubscriptionAuthenticator struct {
    publicKey *rsa.PublicKey
}

func (s *SubscriptionAuthenticator) Validate(r *http.Request) Result {
    // Extract token
    // Parse JWT
    // Verify signature with publicKey
    // Check expiration
    // Return result
}
```

**If option-c (API Validation):**
Call Anthropic validation endpoint:

```go
type SubscriptionAuthenticator struct {
    client *http.Client
    validationURL string
}

func (s *SubscriptionAuthenticator) Validate(r *http.Request) Result {
    // Extract token
    // Call validationURL with token
    // Return validation result
}
```

**If option-d (No Change):**
Skip this task entirely - existing BearerAuthenticator is sufficient.

**Testing:**
Write comprehensive tests for chosen approach:
- Valid subscription token passes
- Invalid token rejected
- Expired token rejected (if JWT)
- Malformed token rejected
- Missing token rejected
  </action>
  <verify>go test ./internal/auth -v -run TestSubscription</verify>
  <done>SubscriptionAuthenticator implementation exists with passing tests</done>
</task>

<task type="auto">
  <name>Task 2: Update config and middleware for subscription auth</name>
  <files>internal/config/config.go, internal/proxy/middleware.go, internal/proxy/routes.go, example.yaml</files>
  <action>
Add subscription auth config option and integrate into auth chain.

**Step 1: Update AuthConfig in internal/config/config.go**

Add subscription auth fields:

```go
type AuthConfig struct {
    APIKey string `yaml:"api_key"`
    AllowBearer bool `yaml:"allow_bearer"`
    BearerSecret string `yaml:"bearer_secret"`

    // NEW: Subscription token support
    AllowSubscription bool `yaml:"allow_subscription"`
    SubscriptionValidationMode string `yaml:"subscription_validation_mode"` // "passthrough", "jwt", "api"
    SubscriptionValidationURL string `yaml:"subscription_validation_url"` // For API mode
}

func (a *AuthConfig) IsEnabled() bool {
    return a.APIKey != "" || a.AllowBearer || a.AllowSubscription
}
```

**Step 2: Update MultiAuthMiddleware in internal/proxy/middleware.go**

Add SubscriptionAuthenticator to chain:

```go
func MultiAuthMiddleware(authConfig *config.AuthConfig) func(http.Handler) http.Handler {
    var authenticators []auth.Authenticator

    // Existing: API key auth
    if effectiveKey := /* ... */; effectiveKey != "" {
        authenticators = append(authenticators, auth.NewAPIKeyAuthenticator(effectiveKey))
    }

    // Existing: Bearer auth
    if authConfig.AllowBearer {
        authenticators = append(authenticators, auth.NewBearerAuthenticator(authConfig.BearerSecret))
    }

    // NEW: Subscription auth
    if authConfig.AllowSubscription {
        var subAuth auth.Authenticator
        switch authConfig.SubscriptionValidationMode {
        case "passthrough":
            subAuth = auth.NewSubscriptionAuthenticator()
        case "jwt":
            // subAuth = auth.NewJWTSubscriptionAuthenticator(...)
        case "api":
            // subAuth = auth.NewAPISubscriptionAuthenticator(authConfig.SubscriptionValidationURL)
        default:
            subAuth = auth.NewSubscriptionAuthenticator() // Default to passthrough
        }
        authenticators = append(authenticators, subAuth)
    }

    // Build chain
    chainAuth := auth.NewChainAuthenticator(authenticators...)

    // Rest of middleware...
}
```

**Step 3: Update example.yaml**

Add subscription auth example:

```yaml
server:
  listen: "127.0.0.1:8787"
  auth:
    # API key authentication (for API users)
    api_key: "${PROXY_API_KEY}"

    # Bearer token authentication (generic)
    allow_bearer: true
    bearer_secret: ""  # Empty = accept any bearer token

    # Claude Code subscription authentication
    allow_subscription: true
    subscription_validation_mode: "passthrough"  # Options: passthrough, jwt, api
    # subscription_validation_url: "https://api.anthropic.com/v1/auth/validate"  # Only for API mode
```

**Step 4: Update routes.go to use new middleware**

Ensure routes.go uses the updated MultiAuthMiddleware (should already work if implemented correctly).
  </action>
  <verify>
go test ./internal/config -v
go test ./internal/proxy -v -run TestSetupRoutes
go run ./cmd/cc-relay validate --config example.yaml
  </verify>
  <done>
AuthConfig includes subscription fields, middleware creates subscription authenticator, example.yaml documented, all tests pass
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Claude Code subscription token authentication system</what-built>
  <how-to-verify>
Test subscription auth end-to-end with Claude Code:

**Step 1: Start cc-relay with subscription auth enabled**

```bash
# Create test config
cat > test-sub-config.yaml << EOF
server:
  listen: "127.0.0.1:8787"
  auth:
    allow_subscription: true
    subscription_validation_mode: "passthrough"

providers:
  - name: "anthropic"
    type: "anthropic"
    enabled: true
    keys:
      - key: "${ANTHROPIC_API_KEY}"  # Your real Anthropic API key
EOF

# Start proxy
./cc-relay serve --config test-sub-config.yaml
```

**Step 2: Test with Claude Code subscription token**

In another terminal:

```bash
# If you have a subscription token:
export ANTHROPIC_BASE_URL="http://localhost:8787"
export ANTHROPIC_API_KEY="your-subscription-token"  # Your subscription token
claude "What is 2+2?"

# Expected: Response from Claude (proxied through cc-relay)
```

**Step 3: Test with invalid token**

```bash
export ANTHROPIC_API_KEY="invalid-token-12345"
claude "test"

# Expected: 401 Unauthorized error
```

**Step 4: Test with API key (fallback)**

```bash
export ANTHROPIC_API_KEY="sk-ant-..."  # Regular API key
claude "test"

# Expected: Should still work (API key auth as fallback)
```

**Step 5: Check logs**

Verify logs show:
- Subscription token authentication attempts
- Which auth method succeeded
- Correct error messages for invalid tokens

**Success criteria:**
- [ ] Valid subscription token authenticates successfully
- [ ] Invalid subscription token returns 401
- [ ] Subscription users can proxy requests through cc-relay
- [ ] Logs clearly indicate subscription auth method used
- [ ] No crashes or panics with various token formats
  </how-to-verify>
  <resume-signal>
Type "approved" if all checks pass, or describe issues found.

If subscription tokens don't work, provide:
1. Error message from Claude Code
2. Log output from cc-relay
3. Network trace of the request (curl -v or browser devtools)
  </resume-signal>
</task>

<task type="auto">
  <name>Task 3: Document subscription auth</name>
  <files>README.md</files>
  <action>
Add documentation explaining Claude Code subscription token support.

**Add section to README.md** (after "Authentication" section):

```markdown
### Claude Code Subscription Token Support

cc-relay supports authentication for Claude Code subscription users. There are two ways to authenticate:

#### API Key Users

If you have an Anthropic API key (starts with `sk-ant-...`):

```bash
export ANTHROPIC_BASE_URL="http://localhost:8787"
export ANTHROPIC_API_KEY="sk-ant-..."
claude
```

cc-relay configuration:

```yaml
server:
  auth:
    api_key: "${PROXY_API_KEY}"  # Your proxy auth key
```

#### Subscription Users

If you use Claude Code with a subscription (no API key):

1. Get your subscription token from Claude Code settings or session storage

2. Configure cc-relay to accept subscription tokens:

```yaml
server:
  auth:
    allow_subscription: true
    subscription_validation_mode: "passthrough"  # Recommended
```

3. Use your subscription token:

```bash
export ANTHROPIC_BASE_URL="http://localhost:8787"
export ANTHROPIC_API_KEY="your-subscription-token"
claude
```

**Validation Modes:**

- `passthrough` (recommended): Token is validated by Anthropic backend. Simple and always up-to-date.
- `jwt` (advanced): Decodes and validates JWT signature locally. Faster but requires token format knowledge.
- `api` (advanced): Calls Anthropic validation endpoint. Adds latency but authoritative.

**Security Note:** Subscription tokens should be treated as sensitive as API keys. Don't commit them to version control or share them publicly.
```

**Update Authentication section:**

Add note that multiple auth methods can be enabled simultaneously:

```markdown
## Authentication

cc-relay supports multiple authentication methods:

1. **API Key** (`x-api-key` header) - For Anthropic API key users
2. **Bearer Token** (`Authorization: Bearer`) - Generic OAuth/token auth
3. **Subscription Token** - For Claude Code subscription users

You can enable multiple methods simultaneously. The proxy tries them in order until one succeeds.

Example config enabling all methods:

```yaml
server:
  auth:
    api_key: "${PROXY_API_KEY}"
    allow_bearer: true
    bearer_secret: ""  # Empty = accept any bearer token
    allow_subscription: true
```
```
  </action>
  <verify>
cat README.md | grep -A 10 "Subscription Token"
  </verify>
  <done>README.md documents subscription auth with examples and security notes</done>
</task>

</tasks>

<verification>
End-to-end verification:

**Manual Testing:**
1. Start cc-relay with subscription auth enabled
2. Test with valid Claude Code subscription token → should authenticate
3. Test with invalid token → should return 401
4. Test with API key → should still work (fallback)
5. Check logs for auth method used

**Automated Testing:**
```bash
# Unit tests
go test ./internal/auth -v

# Integration tests
go test ./internal/proxy -v

# Config validation
go run ./cmd/cc-relay validate --config example.yaml

# Full CI suite
task ci
```

**Documentation:**
```bash
# Verify README.md has subscription auth section
grep -A 20 "Subscription Token" README.md

# Verify example.yaml has subscription config
grep -A 5 "allow_subscription" example.yaml
```
</verification>

<success_criteria>
**Functional:**
- [ ] Claude Code users with subscription tokens can authenticate to cc-relay
- [ ] Invalid subscription tokens return 401 with clear error message
- [ ] Subscription auth works alongside API key and bearer auth (multi-method support)
- [ ] Config option `allow_subscription` enables/disables subscription auth
- [ ] Validation mode can be configured (passthrough/jwt/api)

**Code Quality:**
- [ ] SubscriptionAuthenticator implements Authenticator interface
- [ ] Unit tests cover valid/invalid token cases
- [ ] Integration tests verify end-to-end auth flow
- [ ] Code follows existing auth patterns (constant-time comparison if secrets involved)

**Documentation:**
- [ ] example.yaml includes subscription auth config with comments
- [ ] README.md explains how subscription users configure cc-relay
- [ ] Security notes warn about token handling
- [ ] Validation modes are documented with tradeoffs

**Observability:**
- [ ] Logs indicate when subscription auth is used
- [ ] Auth failures log reason (invalid token, missing token, etc.)
- [ ] Request ID correlation works with subscription auth
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-proxy/01-08-SUMMARY.md` following the summary template.
</output>
