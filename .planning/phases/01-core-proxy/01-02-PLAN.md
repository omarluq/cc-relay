---
phase: 01-core-proxy
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/proxy/server.go
  - internal/proxy/middleware.go
  - internal/proxy/errors.go
autonomous: true

must_haves:
  truths:
    - "HTTP server listens on configured address"
    - "Long streaming requests complete without timeout (10+ minute operations)"
    - "Auth middleware validates x-api-key header"
    - "Invalid API key returns 401 with Anthropic error format"
    - "Missing API key returns 401 with Anthropic error format"
    - "Valid API key allows request through"
  artifacts:
    - path: "internal/proxy/server.go"
      provides: "HTTP server setup with timeouts"
      exports: ["Server", "NewServer"]
    - path: "internal/proxy/middleware.go"
      provides: "Authentication middleware"
      exports: ["AuthMiddleware"]
    - path: "internal/proxy/errors.go"
      provides: "Anthropic-format error responses"
      exports: ["WriteError", "ErrorResponse"]
  key_links:
    - from: "internal/proxy/middleware.go"
      to: "internal/proxy/errors.go"
      via: "uses WriteError for 401 responses"
      pattern: "WriteError.*401"
    - from: "internal/proxy/server.go"
      to: "internal/proxy/middleware.go"
      via: "applies AuthMiddleware to handler chain"
      pattern: "AuthMiddleware"
---

<objective>
Create the HTTP server foundation with authentication middleware for cc-relay.

Purpose: Build the HTTP server that Claude Code will connect to, with proper timeouts for streaming and authentication that validates API keys before requests reach the proxy handler. Authentication must use constant-time comparison to prevent timing attacks.

Output: HTTP server that starts listening, rejects invalid API keys with 401 in Anthropic error format, and allows valid keys through.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-proxy/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Anthropic-format error responses</name>
  <files>internal/proxy/errors.go</files>
  <action>
Create error response utilities matching exact Anthropic API error format:

**errors.go:**
```go
// ErrorResponse matches Anthropic's error response format exactly
type ErrorResponse struct {
    Type  string       `json:"type"`
    Error ErrorDetail  `json:"error"`
}

type ErrorDetail struct {
    Type    string `json:"type"`
    Message string `json:"message"`
}
```

- `WriteError(w http.ResponseWriter, statusCode int, errorType, message string)` - writes JSON error response
- Error types to support (from Anthropic docs):
  - `authentication_error` (401)
  - `invalid_request_error` (400)
  - `api_error` (500)
  - `rate_limit_error` (429)
  - `overloaded_error` (529)
- Always set `Content-Type: application/json` header
- Response format MUST be exactly: `{"type":"error","error":{"type":"...","message":"..."}}`

This matches what Claude Code expects for error handling.
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go build ./internal/proxy/...
```
  </verify>
  <done>ErrorResponse struct and WriteError function compile, match Anthropic format exactly</done>
</task>

<task type="auto">
  <name>Task 2: Authentication middleware with constant-time comparison</name>
  <files>internal/proxy/middleware.go</files>
  <action>
Create authentication middleware using crypto/subtle for timing-attack-safe comparison:

**middleware.go:**
```go
// AuthMiddleware creates middleware that validates x-api-key header
func AuthMiddleware(expectedAPIKey string) func(http.Handler) http.Handler {
    // Pre-hash expected key at creation time
    expectedHash := sha256.Sum256([]byte(expectedAPIKey))

    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            providedKey := r.Header.Get("x-api-key")

            if providedKey == "" {
                WriteError(w, http.StatusUnauthorized, "authentication_error", "missing x-api-key header")
                return
            }

            providedHash := sha256.Sum256([]byte(providedKey))

            // CRITICAL: Constant-time comparison prevents timing attacks
            if subtle.ConstantTimeCompare(providedHash[:], expectedHash[:]) != 1 {
                WriteError(w, http.StatusUnauthorized, "authentication_error", "invalid x-api-key")
                return
            }

            next.ServeHTTP(w, r)
        })
    }
}
```

Key requirements:
- Use `crypto/sha256` to hash keys before comparison
- Use `crypto/subtle.ConstantTimeCompare` for comparison (NEVER use `==`)
- Pre-hash expected key at middleware creation (not per-request)
- Return Anthropic-format error on failure
- Never expose backend provider keys in error messages
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go build ./internal/proxy/...
```
  </verify>
  <done>AuthMiddleware compiles, uses constant-time comparison, returns Anthropic-format errors</done>
</task>

<task type="auto">
  <name>Task 3: HTTP server with proper timeouts</name>
  <files>internal/proxy/server.go</files>
  <action>
Create HTTP server wrapper with streaming-appropriate timeouts:

**server.go:**
```go
// Server wraps http.Server with cc-relay configuration
type Server struct {
    httpServer *http.Server
    addr       string
}

// NewServer creates a new Server with proper timeouts for streaming
func NewServer(addr string, handler http.Handler) *Server {
    return &Server{
        addr: addr,
        httpServer: &http.Server{
            Addr:         addr,
            Handler:      handler,
            ReadTimeout:  10 * time.Second,   // Prevent slow client attacks
            WriteTimeout: 600 * time.Second,  // 10 min for long streaming responses
            IdleTimeout:  120 * time.Second,  // Keep-alive connections
        },
    }
}

// ListenAndServe starts the server (blocks)
func (s *Server) ListenAndServe() error

// Shutdown gracefully stops the server
func (s *Server) Shutdown(ctx context.Context) error
```

Timeout rationale:
- ReadTimeout: 10s - protect against slowloris attacks
- WriteTimeout: 600s - Claude Code operations can stream for 10+ minutes
- IdleTimeout: 120s - reasonable keep-alive
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go build ./internal/proxy/...
```
  </verify>
  <done>Server struct compiles, has proper timeouts, exposes ListenAndServe and Shutdown methods</done>
</task>

</tasks>

<verification>
```bash
# All packages build
cd /home/omarluq/sandbox/go/cc-relay && go build ./internal/proxy/...

# Run linter
cd /home/omarluq/sandbox/go/cc-relay && golangci-lint run ./internal/proxy/...
```
</verification>

<success_criteria>
- [ ] ErrorResponse struct matches Anthropic API error format exactly
- [ ] WriteError function sets correct Content-Type and status code
- [ ] AuthMiddleware uses sha256 hashing before comparison
- [ ] AuthMiddleware uses subtle.ConstantTimeCompare (not `==`)
- [ ] Missing x-api-key returns 401 with "authentication_error" type
- [ ] Invalid x-api-key returns 401 with "authentication_error" type
- [ ] Server has ReadTimeout, WriteTimeout, IdleTimeout configured
- [ ] WriteTimeout is at least 600s for streaming support
- [ ] `go build ./internal/proxy/...` succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-proxy/01-02-SUMMARY.md`
</output>
