---
phase: 02.3-codebase-refactor-samber-libs
plan: 07b
type: execute
wave: 7
depends_on: ["02.3-07a"]
files_modified:
  - cmd/cc-relay/serve.go
  - cmd/cc-relay/serve_test.go
autonomous: true

must_haves:
  truths:
    - "serve.go uses DI container instead of manual wiring"
    - "All existing serve tests pass"
    - "Server starts correctly with DI container"
  artifacts:
    - path: "cmd/cc-relay/serve.go"
      provides: "Server startup with DI container"
      contains: "di.NewContainer"
  key_links:
    - from: "cmd/cc-relay/serve.go"
      to: "cmd/cc-relay/di/container.go"
      via: "import"
      pattern: "di\\.NewContainer"
---

<objective>
Integrate DI container into serve.go to replace manual service wiring.

Purpose: The manual wiring in serve.go is brittle and hard to test. Replacing it with the DI container improves testability, reduces boilerplate, and makes service dependencies explicit.
Output: serve.go using di.NewContainer() for service initialization.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02.3-codebase-refactor-samber-libs/02.3-RESEARCH.md

# Samber skills for consistent patterns
@.claude/skills/samber-lo.md
@.claude/skills/samber-mo.md
@.claude/skills/samber-do.md

# Prior summary - DI foundation
@.planning/phases/02.3-codebase-refactor-samber-libs/02.3-07a-SUMMARY.md

# Current serve.go implementation
@cmd/cc-relay/serve.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor serve.go to use DI container</name>
  <files>
    cmd/cc-relay/serve.go
  </files>
  <action>
Replace manual service wiring with DI container:

1. Before (manual wiring):
   ```go
   func runServe(configPath string) error {
       cfg, err := config.Load(configPath)
       if err != nil { return err }

       cache, err := cache.New(cfg.Cache)
       if err != nil { return err }

       keyPool := keypool.New(cfg.Keys, cache)
       // ... more manual wiring
   }
   ```

2. After (DI container):
   ```go
   import "github.com/omarluq/cc-relay/cmd/cc-relay/di"

   func runServe(configPath string) error {
       // Create DI container
       injector, err := di.NewContainer(configPath)
       if err != nil {
           return fmt.Errorf("failed to initialize services: %w", err)
       }
       defer di.Shutdown(injector)

       // Get HTTP server from container
       server := do.MustInvoke[*http.Server](injector)

       // Handle graceful shutdown
       return runWithGracefulShutdown(server, injector)
   }
   ```

3. Keep signal handling and graceful shutdown:
   - Use context for cancellation
   - Call di.Shutdown on SIGINT/SIGTERM
   - Drain connections before exit

4. Remove manual service initialization code that's now in di/providers.go.
  </action>
  <verify>
Run: `go build ./cmd/cc-relay/` - builds successfully
Run: `./bin/cc-relay serve --help` - works correctly
  </verify>
  <done>serve.go refactored to use DI container</done>
</task>

<task type="auto">
  <name>Task 2: Update serve tests for DI</name>
  <files>
    cmd/cc-relay/serve_test.go
  </files>
  <action>
Update serve tests to work with DI:

1. Test server startup with DI:
   ```go
   func TestRunServe(t *testing.T) {
       configPath := createTestConfig(t)

       // Start server in goroutine
       errCh := make(chan error, 1)
       go func() {
           errCh <- runServe(configPath)
       }()

       // Give it time to start
       time.Sleep(100 * time.Millisecond)

       // Send shutdown signal
       // ...

       // Verify clean shutdown
       select {
       case err := <-errCh:
           assert.NoError(t, err)
       case <-time.After(5 * time.Second):
           t.Fatal("server did not shut down in time")
       }
   }
   ```

2. Test DI container error handling:
   - Invalid config path
   - Missing required config fields
   - Service initialization failures

3. Test graceful shutdown:
   - Verify all services are shut down
   - Verify connections are drained

4. Integration test (if not already exists):
   - Start server
   - Make HTTP request
   - Verify response
   - Shutdown server
  </action>
  <verify>
Run: `go test -v ./cmd/cc-relay/` - all tests pass
Run: `go test -cover ./cmd/cc-relay/` - coverage maintained >80%
  </verify>
  <done>serve tests updated for DI container</done>
</task>

<task type="auto">
  <name>Task 3: End-to-end verification</name>
  <files>
    (no new files - verification only)
  </files>
  <action>
Run comprehensive verification:

1. Build and run server:
   ```bash
   go build ./cmd/cc-relay/
   ./bin/cc-relay serve --config config/example.yaml &
   PID=$!
   sleep 2
   ```

2. Verify server is running:
   ```bash
   curl -s http://localhost:8787/health || echo "Health check failed"
   ```

3. Send shutdown signal:
   ```bash
   kill -SIGTERM $PID
   wait $PID
   echo "Server shutdown complete"
   ```

4. Run full test suite:
   ```bash
   go test -race ./...
   ```

5. Verify coverage:
   ```bash
   go test -cover ./cmd/cc-relay/ ./cmd/cc-relay/di/
   ```

6. Check for any memory leaks or resource issues:
   - Monitor memory during startup/shutdown
   - Verify all goroutines exit cleanly
  </action>
  <verify>
Run: `go test -race ./...` - all tests pass
Server starts and shuts down cleanly
No resource leaks detected
  </verify>
  <done>DI integration complete and verified</done>
</task>

</tasks>

<verification>
1. `go build ./cmd/cc-relay/` - builds successfully
2. `go test -v ./cmd/cc-relay/` - all tests pass
3. `go test -cover ./cmd/cc-relay/` - coverage >80%
4. Server starts with DI container
5. Graceful shutdown works correctly
</verification>

<success_criteria>
- serve.go uses di.NewContainer() for service initialization
- Manual wiring removed from serve.go
- All existing tests pass
- Server starts and serves requests correctly
- Graceful shutdown works
- No memory leaks or resource issues
</success_criteria>

<output>
After completion, create `.planning/phases/02.3-codebase-refactor-samber-libs/02.3-07b-SUMMARY.md`
</output>
