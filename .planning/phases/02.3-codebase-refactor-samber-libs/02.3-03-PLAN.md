---
phase: 02.3-codebase-refactor-samber-libs
plan: 03
type: execute
wave: 2
depends_on: ["02.3-01", "02.3-02"]
files_modified:
  - internal/keypool/pool.go
  - internal/keypool/key.go
  - internal/keypool/least_loaded.go
  - internal/keypool/round_robin.go
  - internal/keypool/selector.go
autonomous: true

must_haves:
  truths:
    - "All for-range loops in keypool package converted to lo functions"
    - "All existing keypool tests pass"
    - "No performance regression in key selection"
  artifacts:
    - path: "internal/keypool/pool.go"
      provides: "KeyPool with lo functional patterns"
      contains: "github.com/samber/lo"
    - path: "internal/keypool/key.go"
      provides: "Key metadata with lo patterns"
      contains: "github.com/samber/lo"
  key_links:
    - from: "internal/keypool/pool.go"
      to: "github.com/samber/lo"
      via: "import"
      pattern: "lo\\.(Map|Filter|Reduce|Find)"
---

<objective>
Convert internal/keypool package from imperative loops to samber/lo functional patterns.

Purpose: keypool is a good first refactoring target - high test coverage (93.6%), clear collection operations, and isolated from other packages. Success here validates the approach.
Output: keypool package using lo.Map, lo.Filter, lo.Reduce, lo.Find where appropriate.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02.3-codebase-refactor-samber-libs/02.3-RESEARCH.md
@.claude/skills/samber-lo.md

# Source files to refactor
@internal/keypool/pool.go
@internal/keypool/key.go
@internal/keypool/least_loaded.go
@internal/keypool/round_robin.go
@internal/keypool/selector.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor pool.go with lo functional patterns</name>
  <files>
    internal/keypool/pool.go
  </files>
  <action>
Convert imperative loops in pool.go to lo functions:

1. Identify all for-range loops (use grep to find them first):
   - Key filtering (available keys, exhausted keys)
   - Stats aggregation (total RPM, total TPM)
   - Key searching (find by ID, find best key)

2. Convert patterns:
   - `for _, key := range keys { if condition { result = append(result, key) } }` -> `lo.Filter(keys, predicate)`
   - `for _, key := range keys { values = append(values, key.field) }` -> `lo.Map(keys, mapper)`
   - `for _, key := range keys { total += key.value }` -> `lo.Reduce(keys, reducer, 0)`
   - `for _, key := range keys { if key.ID == id { return key } }` -> `lo.Find(keys, predicate)`

3. Add import: `"github.com/samber/lo"`

4. Preserve exact behavior - this is a refactor, not a feature change.

5. Run tests after each function conversion to catch regressions early.
  </action>
  <verify>
Run: `go test -v ./internal/keypool/` - all tests pass
Run: `grep -c "for .*, .* := range" internal/keypool/pool.go` - should be 0 or minimal
  </verify>
  <done>pool.go converted to lo functional patterns, all tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Refactor key.go and selector files with lo patterns</name>
  <files>
    internal/keypool/key.go
    internal/keypool/least_loaded.go
    internal/keypool/round_robin.go
    internal/keypool/selector.go
  </files>
  <action>
Convert remaining keypool files to lo patterns:

1. key.go:
   - Header parsing helpers (if any loop over headers)
   - Capacity calculation aggregations

2. least_loaded.go:
   - Finding key with minimum load: `lo.MinBy(keys, compareLoad)`
   - Filtering available keys: `lo.Filter(keys, isAvailable)`

3. round_robin.go:
   - Any index calculations or wrapping logic
   - May have fewer loops (round-robin is index-based)

4. selector.go:
   - Interface file - likely minimal changes
   - Any default implementations

Use lo functions appropriately:
- `lo.MinBy` for finding minimum by comparator
- `lo.MaxBy` for finding maximum by comparator
- `lo.SumBy` for summing a field
- `lo.CountBy` for counting by predicate

Do NOT convert loops that are simpler as loops (e.g., single-iteration for error handling).
  </action>
  <verify>
Run: `go test -v ./internal/keypool/` - all tests pass
Run: `go test -race ./internal/keypool/` - no race conditions
  </verify>
  <done>All keypool files converted to lo patterns where appropriate</done>
</task>

<task type="auto">
  <name>Task 3: Benchmark and verify no performance regression</name>
  <files>
    internal/keypool/pool_bench_test.go
  </files>
  <action>
Create benchmark tests and verify performance:

1. Create pool_bench_test.go with benchmarks:
   ```go
   func BenchmarkKeyPoolGetKey(b *testing.B) {
       pool := createTestPool(100) // 100 keys
       b.ResetTimer()
       for i := 0; i < b.N; i++ {
           pool.GetKey()
       }
   }

   func BenchmarkKeyPoolUpdateFromHeaders(b *testing.B) {
       // benchmark header parsing
   }

   func BenchmarkLeastLoadedSelector(b *testing.B) {
       // benchmark selector
   }
   ```

2. Run benchmarks:
   `go test -bench=. -benchmem ./internal/keypool/`

3. Compare with baseline (before lo conversion):
   - If regression >10%, investigate
   - lo functions should be comparable or faster due to optimizations
   - Document benchmark results in commit message

4. Run full test suite one more time:
   `go test -race ./internal/keypool/`
  </action>
  <verify>
Run: `go test -bench=. -benchmem ./internal/keypool/` - benchmarks complete
No significant performance regression (document baseline in summary)
  </verify>
  <done>Benchmarks created, no performance regression detected</done>
</task>

</tasks>

<verification>
1. `go test -v ./internal/keypool/` - all tests pass
2. `go test -race ./internal/keypool/` - no race conditions
3. `grep "github.com/samber/lo" internal/keypool/*.go` - lo is imported
4. `grep -c "for .*, .* := range" internal/keypool/*.go` - minimal remaining loops
5. Benchmarks show no significant regression
</verification>

<success_criteria>
- All keypool package tests pass (93.6%+ coverage maintained)
- lo imported and used for collection operations
- Imperative for-range loops replaced where lo improves readability
- No race conditions
- Performance comparable to or better than baseline
</success_criteria>

<output>
After completion, create `.planning/phases/02.3-codebase-refactor-samber-libs/02.3-03-SUMMARY.md`
</output>
