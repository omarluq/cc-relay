# Phase 2.3: Codebase Refactor with Samber Libraries - Research

**Researched:** 2026-01-22
**Domain:** Go codebase refactoring with functional programming libraries (samber ecosystem)
**Confidence:** HIGH

## Summary

Phase 2.3 involves comprehensive codebase refactoring using four samber libraries (lo, do, mo, ro) to modernize cc-relay with functional patterns, dependency injection, monadic error handling, and reactive streams. Current test coverage is mixed (13.6% in cmd, 77-100% in internal packages, average ~81%). The codebase has ~15k LOC with 76 for-range loops, moderate linter strictness, and room for improvement in cognitive complexity and tech debt reduction.

The samber ecosystem is mature (all v1+ stable), actively maintained as of 2026, uses Go 1.18+ generics for type safety, and has zero external dependencies (pure stdlib). This refactor will modernize error handling, eliminate boilerplate loops, clean up service wiring, and prepare the codebase for reactive patterns while improving test coverage to >80% across all packages.

**Primary recommendation:** Map codebase architecture first using /gsd:map-codebase, establish comprehensive test coverage baseline, then refactor incrementally in layers (lo → mo → do → ro) with verification at each step. Use property-based testing for complex logic (rate limiters, key selectors). Create reusable skills/agents alongside refactoring for knowledge capture.

## Standard Stack

The established libraries/tools for this refactoring phase:

### Core Libraries (samber ecosystem)

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| samber/lo | v1.x (stable) | Functional collection utilities (Map, Filter, Reduce) | Lodash for Go - 300+ type-safe helpers, 4 execution models (core/parallel/mutable/lazy), most popular Go FP library |
| samber/do | v2.0.0 (latest) | Dependency injection container with generics | Type-safe DI without reflection/codegen, replaces uber/dig with modern approach, lazy loading + lifecycle management |
| samber/mo | v1.x (stable) | Monads (Option, Result, Either) | Eliminates error-prone nil checks, functional error handling, pattern matching, seamless composition |
| samber/ro | v0.2.0 | Reactive streams with operators | Go implementation of ReactiveX spec, replaces RxGo (unmaintained), rich plugin ecosystem for observability/caching/validation |

### Supporting Libraries

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| stretchr/testify | v1.x (stable) | Assertions, mocking, test suites | All test refactoring - assert/require packages, mock generation, suite structure |
| testcontainers-go | Latest | Docker-based integration testing | Integration tests requiring real services (databases, message queues) |
| gopter | Latest | Property-based testing | Complex logic validation (rate limiters, key selectors, header parsing) |
| flying mutant/rapid | Latest | Modern property-based testing alternative | Simpler API than gopter, automatic shrinking without user code |

### samber/ro Plugins

| Plugin | Purpose | Replaces/Enhances |
|--------|---------|-------------------|
| ro/plugins/observability/zerolog | Reactive logging streams | Current zerolog usage - adds stream-based logging |
| ro/plugins/network/http | HTTP request/response operators | Proxy stream processing |
| ro/plugins/cache/hot | In-memory caching with LRU/TTL | internal/cache/ - modern reactive cache |
| ro/plugins/observability/oops | Structured error handling | Complements mo Result types |
| ro/plugins/system/signal | Graceful shutdown handling | Current signal handling in serve.go |
| ro/plugins/validation/ozzo | Config validation operators | Config validation logic |
| ro/plugins/ratelimit/native | Rate limiting operators | internal/ratelimit/ - reactive rate limiting |
| ro/plugins/io/fsnotify | File system monitoring | Future config hot-reload (Phase 7 prep) |
| ro/plugins/testing/testify | Testing utilities for streams | Stream-based testing patterns |

### Tools & Linters

| Tool | Purpose | Configuration |
|------|---------|---------------|
| golangci-lint | Meta-linter (40+ linters) | Enable ALL rules except exhaustruct, varnamelen, forbidigo, funlen, cyclop |
| gocognit | Cognitive complexity analysis | Min complexity: 10 (reduce from current 20) |
| gocyclo | Cyclomatic complexity | Min complexity: 10 (reduce from current 15) |
| govulncheck | Security vulnerability scanning | Already in pre-push hooks |
| gosec | Security-focused linting | Already enabled |

**Installation:**
```bash
# Core libraries
go get github.com/samber/lo@v1
go get github.com/samber/do/v2@latest
go get github.com/samber/mo@v1
go get github.com/samber/ro@v0.2.0

# Testing libraries
go get github.com/stretchr/testify
go get github.com/testcontainers/testcontainers-go
go get github.com/leanovate/gopter

# ro plugins
go get github.com/samber/ro/plugins/observability/zerolog
go get github.com/samber/ro/plugins/network/http
go get github.com/samber/ro/plugins/cache/hot
go get github.com/samber/ro/plugins/observability/oops
go get github.com/samber/ro/plugins/system/signal
go get github.com/samber/ro/plugins/validation/ozzo
go get github.com/samber/ro/plugins/ratelimit/native
go get github.com/samber/ro/plugins/io/fsnotify
go get github.com/samber/ro/plugins/testing/testify
```

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| samber/lo | Standard library slices package (Go 1.21+) | Slices has limited FP functions (Sort, BinarySearch), lo has 300+ |
| samber/do | uber/dig, wire (Google) | dig uses reflection (slower), wire requires codegen (build complexity) |
| samber/mo | Custom error wrappers | Hand-rolling monads is error-prone, missing pattern matching/composition |
| samber/ro | ReactiveX/RxGo | RxGo unmaintained (3+ years no commits), no generics support |
| gopter | testing/quick (stdlib) | testing/quick lacks shrinking (can't minimize failing cases), feature-frozen |
| testify | Standard testing only | More verbose assertions, no mocking framework, manual test suites |

## Architecture Patterns

### Current Codebase Structure (Before Refactoring)

```
cc-relay/
├── cmd/cc-relay/           # CLI commands (13.6% coverage - LOW)
│   ├── serve.go            # Service initialization - complex wiring
│   ├── config*.go          # Config commands
│   └── *_test.go
├── internal/
│   ├── auth/               # Auth chain (100% coverage - GOOD)
│   ├── cache/              # In-memory cache (77.3% coverage - NEEDS WORK)
│   ├── config/             # Config loading (86.5% coverage - GOOD)
│   ├── keypool/            # API key management (93.6% coverage - GOOD)
│   ├── providers/          # Provider implementations (91.7% coverage - GOOD)
│   ├── proxy/              # HTTP proxy server (83.6% coverage - GOOD)
│   ├── ratelimit/          # Token bucket rate limiter (94.5% coverage - GOOD)
│   └── version/            # Version info (100% coverage - GOOD)
```

**Current State:**
- ~15,483 total lines of Go code
- 76 for-range loops (refactor targets)
- Mixed test coverage (13.6% to 100%)
- Moderate linter strictness (gocognit: 20, gocyclo: 15)
- Manual dependency wiring in serve.go
- Traditional Go error handling (value, error tuples)
- Imperative loops for collections

### Recommended Refactored Structure

```
cc-relay/
├── cmd/cc-relay/
│   ├── serve.go            # DI container initialization (samber/do)
│   └── di/                 # DI service providers
│       ├── providers.go    # Provider registration
│       ├── middleware.go   # Middleware registration
│       └── scoped.go       # Request-scoped services
├── internal/
│   ├── domain/             # Core domain logic (pure, no dependencies)
│   │   ├── models/         # Domain models (mo.Option for nullable fields)
│   │   └── errors/         # Domain errors (mo.Result for error flows)
│   ├── app/                # Application layer (use cases)
│   │   ├── proxy/          # Proxy use case (ro streams)
│   │   └── routing/        # Routing logic (lo functional)
│   ├── infra/              # Infrastructure layer
│   │   ├── cache/          # Cache impl (ro hot plugin)
│   │   ├── ratelimit/      # Rate limiting (ro native plugin)
│   │   ├── providers/      # Provider clients
│   │   └── config/         # Config loading (ro validation plugin)
│   ├── delivery/           # Delivery layer (HTTP handlers)
│   │   ├── http/           # HTTP server (ro http plugin)
│   │   └── middleware/     # Middleware (DI-injected)
│   └── pkg/                # Shared utilities
│       ├── functional/     # lo helpers (generic utilities)
│       └── streams/        # ro helpers (common operators)
```

### Pattern 1: Functional Collection Processing (samber/lo)

**What:** Replace imperative for-loops with declarative functional operations
**When to use:** All slice/map transformations, filtering, aggregations

**Before (Imperative):**
```go
// Example: Filter active providers
var activeProviders []Provider
for _, p := range allProviders {
    if p.IsActive {
        activeProviders = append(activeProviders, p)
    }
}
```

**After (Functional):**
```go
// Source: https://github.com/samber/lo
import "github.com/samber/lo"

activeProviders := lo.Filter(allProviders, func(p Provider, _ int) bool {
    return p.IsActive
})
```

**More Patterns:**
```go
// Map: Transform slice elements
apiKeys := lo.Map(providers, func(p Provider, _ int) string {
    return p.APIKey
})

// Reduce: Aggregate values
totalRPM := lo.Reduce(keys, func(sum int, k APIKey, _ int) int {
    return sum + k.RPM
}, 0)

// GroupBy: Organize by key
byProvider := lo.GroupBy(keys, func(k APIKey) string {
    return k.ProviderName
})

// Uniq: Remove duplicates
uniqueModels := lo.Uniq(modelNames)

// Chunk: Divide into batches
batches := lo.Chunk(items, 10)

// FlatMap: Map and flatten
allKeys := lo.FlatMap(providers, func(p Provider, _ int) []APIKey {
    return p.Keys
})
```

### Pattern 2: Monadic Error Handling (samber/mo)

**What:** Replace (value, error) tuples with Result[T] monad for composable error handling
**When to use:** All functions that can fail, especially chained operations

**Before (Traditional Go):**
```go
// Nested error checks
func ProcessRequest(req *Request) (*Response, error) {
    validated, err := ValidateRequest(req)
    if err != nil {
        return nil, err
    }

    authenticated, err := Authenticate(validated)
    if err != nil {
        return nil, err
    }

    resp, err := RouteToProvider(authenticated)
    if err != nil {
        return nil, err
    }

    return resp, nil
}
```

**After (Monadic):**
```go
// Source: https://github.com/samber/mo
import "github.com/samber/mo"

func ProcessRequest(req *Request) mo.Result[*Response] {
    return ValidateRequest(req).
        FlatMap(Authenticate).
        FlatMap(RouteToProvider)
}

// Convert traditional tuple to Result
func ValidateRequest(req *Request) mo.Result[*Request] {
    if err := validate(req); err != nil {
        return mo.Err[*Request](err)
    }
    return mo.Ok(req)
}

// Pattern matching for handling both cases
result.Match(
    func(resp *Response) { /* success */ },
    func(err error) { /* failure */ },
)
```

**Option[T] for Nullable Fields:**
```go
// Before: nil checks everywhere
type Config struct {
    Timeout *int // nullable
}

if cfg.Timeout != nil {
    value := *cfg.Timeout
    // use value
}

// After: Option monad
type Config struct {
    Timeout mo.Option[int]
}

cfg.Timeout.
    Map(func(t int) int { return t * 1000 }). // ms to seconds
    OrElse(30) // default value
```

### Pattern 3: Dependency Injection (samber/do)

**What:** Replace manual service wiring with type-safe DI container
**When to use:** Application initialization, service lifecycle management

**Before (Manual Wiring):**
```go
// serve.go - complex manual wiring
func runServer(cfg *Config) error {
    cache := cache.New(cfg.CacheSize)
    keyPool := keypool.New(cfg.Keys, cache)

    anthropicProvider := providers.NewAnthropic(cfg.Anthropic)
    zaiProvider := providers.NewZAI(cfg.ZAI)
    providerMap := map[string]Provider{
        "anthropic": anthropicProvider,
        "zai": zaiProvider,
    }

    proxyHandler := proxy.New(keyPool, providerMap, cache)
    // ... more wiring
}
```

**After (DI Container):**
```go
// Source: https://github.com/samber/do/v2
import "github.com/samber/do/v2"

// di/providers.go - Service registration
func RegisterServices(injector *do.Injector) {
    // Singletons (long-lived)
    do.Provide(injector, NewConfig)
    do.Provide(injector, NewCache)
    do.Provide(injector, NewKeyPool)
    do.Provide(injector, NewProviderMap)

    // Transient (per-request)
    do.ProvideTransient(injector, NewRequestLogger)
}

func NewKeyPool(i *do.Injector) (*keypool.KeyPool, error) {
    cfg := do.MustInvoke[*Config](i)
    cache := do.MustInvoke[*cache.Cache](i)
    return keypool.New(cfg.Keys, cache), nil
}

// serve.go - Simple initialization
func runServer(cfg *Config) error {
    injector := do.New()
    RegisterServices(injector)

    // Inject and run
    handler := do.MustInvoke[*proxy.Handler](injector)
    return http.ListenAndServe(":8787", handler)
}
```

**Request-Scoped Services:**
```go
// Scoped container per HTTP request
func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    scope := do.NewScope(h.injector)

    // Provide request-scoped dependencies
    do.ProvideValue(scope, r.Context())
    do.ProvideValue(scope, extractRequestID(r))

    // Invoke with scoped dependencies
    processor := do.MustInvoke[*RequestProcessor](scope)
    processor.Handle(w, r)
}
```

### Pattern 4: Reactive Streams (samber/ro)

**What:** Process event streams with composable operators
**When to use:** Asynchronous data flows, event processing, observability

**Example: SSE Streaming with ro:**
```go
// Source: https://github.com/samber/ro
import (
    "github.com/samber/ro"
    rohttp "github.com/samber/ro/plugins/network/http"
)

// Create observable from HTTP request
stream := ro.Pipe(
    rohttp.FromRequest(req),
    ro.Filter(func(chunk []byte) bool {
        return len(chunk) > 0
    }),
    ro.Map(func(chunk []byte) SSEEvent {
        return parseSSE(chunk)
    }),
    ro.Catch(func(err error) ro.Observable[SSEEvent] {
        return ro.Just(errorEvent(err))
    }),
)

// Subscribe to stream
stream.Subscribe(ro.Observer[SSEEvent]{
    OnNext: func(event SSEEvent) {
        w.Write(formatSSE(event))
        w.(http.Flusher).Flush()
    },
    OnError: func(err error) {
        log.Error().Err(err).Msg("stream error")
    },
})
```

**Rate Limiting with ro:**
```go
// Replace internal/ratelimit with ro operators
import ratelimit "github.com/samber/ro/plugins/ratelimit/native"

observable := ro.Pipe(
    ro.FromChannel(requestChan),
    ratelimit.RateLimit(100, time.Second), // 100 req/sec
    ro.Map(processRequest),
)
```

### Pattern 5: Property-Based Testing

**What:** Generate random test cases to verify properties hold
**When to use:** Complex logic with many edge cases (rate limiters, parsers, selectors)

**Example with gopter:**
```go
// Source: https://github.com/leanovate/gopter
import "github.com/leanovate/gopter"

func TestRateLimiterProperty(t *testing.T) {
    properties := gopter.NewProperties(nil)

    properties.Property("rate limiter never exceeds limit", prop.ForAll(
        func(rpm int, duration time.Duration) bool {
            limiter := NewRateLimiter(rpm)

            allowed := 0
            for i := 0; i < rpm*2; i++ {
                if limiter.Allow() {
                    allowed++
                }
            }

            return allowed <= rpm
        },
        gen.IntRange(1, 1000),
        gen.TimeRange(time.Second, time.Minute),
    ))

    properties.TestingRun(t)
}
```

### Anti-Patterns to Avoid

**1. Over-functional Programming**
- **Bad:** Using lo.Map for simple single transformations that are clearer as loops
- **Good:** Use functional style when it improves readability, not everywhere

**2. Ignoring Performance**
- **Bad:** Using lo.Filter().Map().Reduce() creating multiple intermediate slices
- **Good:** Use lo/parallel for large datasets, or single pass with lo.FilterMap

**3. Mixing Error Handling Styles**
- **Bad:** Some functions return Result[T], others return (T, error)
- **Good:** Consistent use of Result[T] across codebase, use mo.TupleToResult for boundaries

**4. DI Container Abuse**
- **Bad:** Putting everything in DI container (including values, configs)
- **Good:** Services and interfaces in DI, simple values passed directly

**5. Reactive Streams for Simple Cases**
- **Bad:** Using ro.Observable for single HTTP request/response
- **Good:** Use ro for actual streams (SSE, websockets, event processing)

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Collection utilities | Custom Map/Filter/Reduce functions | samber/lo | 300+ battle-tested functions, optimized, parallel variants available |
| Dependency injection | Manual factory pattern or global vars | samber/do | Type-safe, lifecycle management, scoped services, circular dependency detection |
| Optional values | Custom Maybe type or *T everywhere | mo.Option[T] | Pattern matching, safe unwrapping, JSON serialization, composition |
| Error handling chains | Nested if err != nil checks | mo.Result[T] | Composable, Railway Oriented Programming, matches on both branches |
| Rate limiting | Token bucket from scratch | ro native rate limit plugin | Production-tested, integrates with streams, handles edge cases |
| In-memory cache | map[string]interface{} with mutex | ro hot plugin or samber/hot | LRU eviction, TTL, jitter, thread-safe, janitor for cleanup |
| Property-based testing | Random value generation manually | gopter or rapid | Automatic shrinking, stateful testing, integrated with testing.T |
| HTTP mocking | Custom mock servers | testify/mock + httptest | Interface mocking, call verification, easy setup/teardown |
| Integration testing | Docker compose scripts | testcontainers-go | Programmatic container lifecycle, automatic cleanup, parallel tests |
| Graceful shutdown | Manual signal handling | ro signal plugin | Proper drain, timeout handling, multiple services coordination |

**Key insight:** The samber ecosystem provides production-tested solutions for common Go patterns. These libraries use Go 1.18+ generics (no reflection overhead), have zero external dependencies, and are semantically versioned (v1 stable). Hand-rolling any of these solutions adds maintenance burden, bugs, and lacks the optimizations (parallel execution, memory pooling) that these libraries provide.

## Common Pitfalls

### Pitfall 1: Refactoring Without Test Coverage

**What goes wrong:** Refactoring code with low test coverage leads to silent regressions. cc-relay's cmd package has only 13.6% coverage.

**Why it happens:** Developers rush to refactor without establishing safety net. Functional refactors change control flow (loops → lo.Map), making behavioral equivalence hard to verify without tests.

**How to avoid:**
1. Achieve >80% test coverage BEFORE major refactoring
2. Add tests for current behavior (characterization tests)
3. Refactor incrementally with test runs between changes
4. Use coverage tools to identify untested paths

**Warning signs:**
- "Tests are broken but code works" (tests are oracle, not code)
- Coverage drops after refactoring
- Integration tests pass but unit tests fail

### Pitfall 2: Performance Regression from Functional Style

**What goes wrong:** Naive functional code creates unnecessary allocations and intermediate slices.

**Why it happens:** Chaining lo.Filter().Map().Reduce() creates intermediate slices at each step. For large datasets (1000+ items), this causes GC pressure.

**How to avoid:**
1. Use `lo.FilterMap` for filter+map in single pass
2. Use `lo/parallel` for CPU-bound operations on large datasets
3. Benchmark before/after with realistic data sizes
4. Keep hot paths imperative if benchmarks show regression

**Warning signs:**
```go
// BAD: 3 intermediate slices
result := lo.Reduce(
    lo.Map(
        lo.Filter(items, filterFn),
        mapFn,
    ),
    reduceFn, initial,
)

// GOOD: Single pass
result := lo.Reduce(items, func(acc T, item I, _ int) T {
    if filterFn(item, 0) {
        return reduceFn(acc, mapFn(item, 0), 0)
    }
    return acc
}, initial)
```

### Pitfall 3: DI Container Scope Confusion

**What goes wrong:** Mixing singleton and request-scoped services causes bugs (shared state across requests, memory leaks).

**Why it happens:** samber/do v2 has scopes, but it's easy to invoke singleton service from scoped container or vice versa.

**How to avoid:**
1. Document which services are singleton vs transient
2. Use `do.NewScope(parent)` for request-scoped containers
3. Never store request-specific data (context, request ID) in singleton services
4. Use do.Explain() to visualize dependency graph

**Warning signs:**
- Request ID from one request appearing in another request's logs
- Context cancellation affecting unrelated requests
- Memory growing unbounded (leaked request-scoped objects)

### Pitfall 4: Result[T] Unwrapping Without Handling Errors

**What goes wrong:** Using `.MustGet()` or `.Get()` without checking `.IsOk()` defeats purpose of monadic error handling.

**Why it happens:** Developers treat Result[T] like a tuple and unwrap immediately instead of composing.

**How to avoid:**
1. Use `.FlatMap()` to chain operations
2. Use `.Match()` to handle both success and error cases
3. Only use `.MustGet()` in tests or after explicit `.IsOk()` check
4. Convert to traditional tuple at API boundaries only

**Warning signs:**
```go
// BAD: Immediate unwrapping defeats monads
result := Validate(req)
if !result.IsOk() {
    return result.Error()
}
value := result.MustGet()

// GOOD: Composition
return Validate(req).
    FlatMap(Authenticate).
    FlatMap(Process)
```

### Pitfall 5: Over-Engineering with Reactive Streams

**What goes wrong:** Using ro.Observable for simple synchronous operations adds complexity without benefit.

**Why it happens:** Enthusiasm for new paradigm leads to applying it everywhere, even where traditional patterns are clearer.

**How to avoid:**
1. Use ro for actual streams: SSE, websockets, file watching, event processing
2. Keep simple HTTP request/response as traditional handlers
3. Start with ro in bounded areas (observability, caching) before full adoption
4. Evaluate if reactive adds value or just complexity

**Warning signs:**
- Observable wrapping single value (use direct value instead)
- Synchronous operations forced into async streams
- Team struggling to understand reactive code
- More code after refactor than before

### Pitfall 6: Insufficient Property-Based Test Coverage

**What goes wrong:** Property tests generate hundreds of cases but fail to test the actual properties that matter.

**Why it happens:** Writing good properties is hard. Developers test implementation details instead of invariants.

**How to avoid:**
1. Identify true invariants (e.g., "rate limiter never exceeds limit", not "counter increments")
2. Use shrinking to find minimal failing case
3. Combine with example-based tests for known edge cases
4. Generate realistic data (not just primitives)

**Warning signs:**
- Property tests pass but production bugs slip through
- Properties test intermediate steps instead of end result
- Custom generators are more complex than code being tested

### Pitfall 7: Golangci-lint Strict Mode Whack-a-Mole

**What goes wrong:** Enabling all linters without understanding them leads to meaningless fixes and disabled checks.

**Why it happens:** Different linters conflict (e.g., gocritic wants if-else chains, but another wants early returns). Strict mode surfaces 100+ violations at once.

**How to avoid:**
1. Enable linters incrementally (one category at a time)
2. Fix violations category by category (start with correctness, then style)
3. Document why specific checks are disabled (not just disable silently)
4. Set realistic complexity thresholds (gocognit: 10-15, not 5)

**Warning signs:**
- .golangci.yml with 50+ disabled checks
- //nolint comments everywhere
- Team ignoring linter output
- CI failing on linter, devs bypassing with --no-verify

### Pitfall 8: Breaking API Compatibility During Internal Refactor

**What goes wrong:** Refactoring changes HTTP API contract (endpoint paths, request/response formats, headers).

**Why it happens:** Enthusiastic refactoring touches delivery layer without considering external clients.

**How to avoid:**
1. Lock HTTP API contract with integration tests
2. Refactor internals (domain, app, infra) but keep delivery layer stable
3. Use adapter pattern if internal types change
4. Version API if breaking changes are necessary

**Warning signs:**
- Claude Code fails to connect after refactor
- Anthropic API compatibility tests fail
- Tool use IDs change format
- SSE event sequence differs

## Code Examples

Verified patterns from official sources:

### Example 1: Functional Collection Processing

```go
// Source: https://github.com/samber/lo
import "github.com/samber/lo"

// Current: Filter active keys imperatively
func GetActiveKeys(keys []APIKey) []APIKey {
    var active []APIKey
    for _, k := range keys {
        if k.IsActive && k.RemainingRPM > 0 {
            active = append(active, k)
        }
    }
    return active
}

// Refactored: Functional filter
func GetActiveKeys(keys []APIKey) []APIKey {
    return lo.Filter(keys, func(k APIKey, _ int) bool {
        return k.IsActive && k.RemainingRPM > 0
    })
}

// Advanced: Parallel processing for large datasets
func GetActiveKeys(keys []APIKey) []APIKey {
    return parallel.Filter(keys, func(k APIKey, _ int) bool {
        return k.IsActive && k.RemainingRPM > 0
    })
}

// Multiple transformations
func GetProviderNames(providers []Provider) []string {
    return lo.Uniq(
        lo.Map(providers, func(p Provider, _ int) string {
            return p.Name
        }),
    )
}

// GroupBy for organizing
func GroupKeysByProvider(keys []APIKey) map[string][]APIKey {
    return lo.GroupBy(keys, func(k APIKey) string {
        return k.ProviderName
    })
}
```

### Example 2: Monadic Error Handling

```go
// Source: https://github.com/samber/mo
import "github.com/samber/mo"

// Current: Nested error checks
func AuthenticateAndRoute(req *Request) (*Response, error) {
    if err := ValidateAPIKey(req.APIKey); err != nil {
        return nil, fmt.Errorf("invalid key: %w", err)
    }

    provider, err := SelectProvider(req)
    if err != nil {
        return nil, fmt.Errorf("select provider: %w", err)
    }

    resp, err := provider.Send(req)
    if err != nil {
        return nil, fmt.Errorf("send request: %w", err)
    }

    return resp, nil
}

// Refactored: Monadic composition
func AuthenticateAndRoute(req *Request) mo.Result[*Response] {
    return ValidateAPIKey(req.APIKey).
        FlatMap(func(*APIKey) mo.Result[Provider] {
            return SelectProvider(req)
        }).
        FlatMap(func(p Provider) mo.Result[*Response] {
            return p.Send(req)
        })
}

// Helper: Convert traditional to Result
func ValidateAPIKey(key string) mo.Result[*APIKey] {
    apiKey, err := lookupKey(key)
    return mo.TupleToResult(apiKey, err)
}

// Pattern matching for handling
result := AuthenticateAndRoute(req)
result.Match(
    func(resp *Response) {
        writeResponse(w, resp)
    },
    func(err error) {
        writeError(w, err)
    },
)

// Option for nullable fields
type Config struct {
    Timeout      mo.Option[time.Duration]
    MaxRetries   mo.Option[int]
    FallbackURL  mo.Option[string]
}

timeout := cfg.Timeout.OrElse(30 * time.Second)
retries := cfg.MaxRetries.
    Map(func(r int) int { return r * 2 }). // double it
    OrElse(3) // default
```

### Example 3: Dependency Injection Setup

```go
// Source: https://do.samber.dev/docs/about
import "github.com/samber/do/v2"

// cmd/cc-relay/di/providers.go
func RegisterSingletons(i *do.Injector) {
    do.Provide(i, NewConfig)
    do.Provide(i, NewCache)
    do.Provide(i, NewKeyPool)
    do.Provide(i, NewProviderMap)
    do.Provide(i, NewProxyHandler)
}

func NewConfig(i *do.Injector) (*config.Config, error) {
    return config.Load("config.yaml")
}

func NewCache(i *do.Injector) (*cache.Cache, error) {
    cfg := do.MustInvoke[*config.Config](i)
    return cache.New(cfg.CacheSize), nil
}

func NewKeyPool(i *do.Injector) (*keypool.KeyPool, error) {
    cfg := do.MustInvoke[*config.Config](i)
    cache := do.MustInvoke[*cache.Cache](i)
    return keypool.New(cfg.Keys, cache), nil
}

func NewProviderMap(i *do.Injector) (map[string]Provider, error) {
    cfg := do.MustInvoke[*config.Config](i)

    providers := make(map[string]Provider)
    for _, pcfg := range cfg.Providers {
        providers[pcfg.Name] = createProvider(pcfg)
    }
    return providers, nil
}

func NewProxyHandler(i *do.Injector) (*proxy.Handler, error) {
    keyPool := do.MustInvoke[*keypool.KeyPool](i)
    providers := do.MustInvoke[map[string]Provider](i)
    cache := do.MustInvoke[*cache.Cache](i)

    return proxy.NewHandler(keyPool, providers, cache), nil
}

// cmd/cc-relay/serve.go - Simplified
func runServer(cfg *config.Config) error {
    injector := do.New()
    do.ProvideValue(injector, cfg) // Provide loaded config
    RegisterSingletons(injector)

    handler := do.MustInvoke[*proxy.Handler](injector)

    server := &http.Server{
        Addr:    ":8787",
        Handler: handler,
    }

    return server.ListenAndServe()
}

// Request-scoped services (middleware)
func RequestScopeMiddleware(injector *do.Injector) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            scope := do.NewScope(injector)

            // Provide request-scoped values
            do.ProvideValue(scope, r.Context())
            do.ProvideValue(scope, extractRequestID(r))

            // Inject logger with request ID
            do.ProvideTransient(scope, func(i *do.Injector) (*zerolog.Logger, error) {
                reqID := do.MustInvoke[string](i)
                logger := log.With().Str("request_id", reqID).Logger()
                return &logger, nil
            })

            // Store scope in context
            ctx := context.WithValue(r.Context(), scopeKey, scope)
            next.ServeHTTP(w, r.WithContext(ctx))
        })
    }
}
```

### Example 4: Reactive Stream Processing

```go
// Source: https://github.com/samber/ro
import (
    "github.com/samber/ro"
    rohttp "github.com/samber/ro/plugins/network/http"
    rolog "github.com/samber/ro/plugins/observability/zerolog"
    rlimit "github.com/samber/ro/plugins/ratelimit/native"
)

// SSE streaming with ro
func StreamSSE(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "text/event-stream")
    w.Header().Set("Cache-Control", "no-cache")

    // Create stream pipeline
    stream := ro.Pipe(
        rohttp.FromRequest(r),
        ro.Filter(func(chunk []byte) bool {
            return len(chunk) > 0
        }),
        ro.Map(parseSSEEvent),
        rolog.LogEach("sse_event"),
        ro.Catch(func(err error) ro.Observable[SSEEvent] {
            return ro.Just(errorEvent(err))
        }),
    )

    // Subscribe and forward to client
    stream.Subscribe(ro.Observer[SSEEvent]{
        OnNext: func(evt SSEEvent) {
            fmt.Fprintf(w, "data: %s\n\n", evt.Data)
            w.(http.Flusher).Flush()
        },
        OnError: func(err error) {
            log.Error().Err(err).Msg("stream error")
        },
        OnComplete: func() {
            log.Info().Msg("stream complete")
        },
    })
}

// Rate limiting with ro operators
func RateLimitedStream(requests <-chan Request) ro.Observable[Response] {
    return ro.Pipe(
        ro.FromChannel(requests),
        rlimit.RateLimit(100, time.Second), // 100/sec
        ro.Map(func(req Request) Response {
            return processRequest(req)
        }),
    )
}

// Cache integration with ro hot plugin
import rohot "github.com/samber/ro/plugins/cache/hot"

func CachedLookup(key string) ro.Observable[Value] {
    return ro.Pipe(
        ro.Just(key),
        rohot.Cache(
            rohot.WithTTL(5 * time.Minute),
            rohot.WithLRU(1000),
        ),
        ro.Map(fetchFromUpstream),
    )
}
```

### Example 5: Property-Based Testing

```go
// Source: https://github.com/leanovate/gopter
import (
    "testing"
    "github.com/leanovate/gopter"
    "github.com/leanovate/gopter/gen"
    "github.com/leanovate/gopter/prop"
)

// Property: Rate limiter respects limits
func TestRateLimiterProperty(t *testing.T) {
    properties := gopter.NewProperties(nil)

    properties.Property("never allows more than RPM", prop.ForAll(
        func(rpm int) bool {
            limiter := ratelimit.New(rpm)

            allowed := 0
            for i := 0; i < rpm*2; i++ {
                if limiter.Allow() {
                    allowed++
                }
            }

            return allowed <= rpm
        },
        gen.IntRange(1, 1000),
    ))

    properties.TestingRun(t)
}

// Property: Key selection is deterministic
func TestKeySelectionDeterministic(t *testing.T) {
    properties := gopter.NewProperties(nil)

    properties.Property("same input produces same key", prop.ForAll(
        func(keys []APIKey, req Request) bool {
            selector := NewKeySelector(keys)

            key1, _ := selector.Select(req)
            key2, _ := selector.Select(req)

            return key1 == key2
        },
        genAPIKeys(),
        genRequest(),
    ))

    properties.TestingRun(t)
}

// Custom generators
func genAPIKeys() gopter.Gen {
    return gen.SliceOf(gen.Struct(reflect.TypeOf(APIKey{}), map[string]gopter.Gen{
        "Key":       gen.AlphaString(),
        "RPM":       gen.IntRange(100, 10000),
        "IsActive":  gen.Bool(),
    }))
}
```

### Example 6: Testify Assertions and Mocking

```go
// Source: https://github.com/stretchr/testify
import (
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
    "github.com/stretchr/testify/mock"
)

// Current: Verbose assertions
func TestValidateKey(t *testing.T) {
    key, err := ValidateKey("test-key")
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }
    if key == nil {
        t.Fatal("expected key, got nil")
    }
    if key.IsActive != true {
        t.Errorf("expected active key, got %v", key.IsActive)
    }
}

// Refactored: Testify assertions
func TestValidateKey(t *testing.T) {
    key, err := ValidateKey("test-key")

    require.NoError(t, err)
    require.NotNil(t, key)
    assert.True(t, key.IsActive)
    assert.Equal(t, "test-key", key.Value)
}

// Mocking with testify
type MockProvider struct {
    mock.Mock
}

func (m *MockProvider) Send(req *Request) (*Response, error) {
    args := m.Called(req)
    return args.Get(0).(*Response), args.Error(1)
}

func TestProxyHandler(t *testing.T) {
    mockProvider := new(MockProvider)
    mockProvider.On("Send", mock.Anything).Return(&Response{Status: 200}, nil)

    handler := NewHandler(mockProvider)
    resp, err := handler.Route(&Request{})

    require.NoError(t, err)
    assert.Equal(t, 200, resp.Status)
    mockProvider.AssertExpectations(t)
}

// Test suites
type ProxyTestSuite struct {
    suite.Suite
    handler *Handler
    mock    *MockProvider
}

func (s *ProxyTestSuite) SetupTest() {
    s.mock = new(MockProvider)
    s.handler = NewHandler(s.mock)
}

func (s *ProxyTestSuite) TestSuccessfulRoute() {
    s.mock.On("Send", mock.Anything).Return(&Response{}, nil)
    resp, err := s.handler.Route(&Request{})
    s.NoError(err)
    s.NotNil(resp)
}

func TestProxySuite(t *testing.T) {
    suite.Run(t, new(ProxyTestSuite))
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Reflection-based DI (uber/dig) | Generic-based DI (samber/do v2) | 2023 (Go 1.18+ generics) | Type safety at compile time, ~10x faster |
| testing/quick for property tests | gopter or rapid | 2019-2020 | Automatic shrinking, stateful testing |
| RxGo for reactive streams | samber/ro | 2025-2026 | Maintained, generics support, plugin ecosystem |
| Manual for-loops everywhere | Functional utilities (samber/lo) | 2022+ (Go 1.18 generics) | Concise, parallel variants, less error-prone |
| (value, error) tuple pattern | Result[T] monads (samber/mo) | 2022+ (Go 1.18 generics) | Composable error handling, Railway-Oriented Programming |
| gocyclo only | gocognit preferred | 2019 | Better refactoring guidance (measures understandability) |
| Manual mock generation | mockery/testify codegen | 2020+ | Auto-generated mocks, interface detection |
| Docker compose for tests | testcontainers-go | 2021+ | Programmatic container lifecycle, parallel tests |

**Deprecated/outdated:**
- **testing/quick**: Feature-frozen, lacks shrinking → Use gopter or rapid
- **RxGo**: Unmaintained (3+ years no commits) → Use samber/ro
- **uber/dig**: Reflection overhead → Use samber/do v2 with generics
- **Global variables for DI**: Hard to test → Use DI container
- **Cyclomatic complexity only**: Doesn't measure understandability → Use cognitive complexity (gocognit)

## Open Questions

Things that couldn't be fully resolved:

### 1. Request-Scoped Services in samber/do v2

**What we know:**
- samber/do v2 has `do.NewScope(parent)` for scoped containers
- Scopes inherit singleton services from parent
- Can provide request-specific values (context, request ID) to scope

**What's unclear:**
- Best practice for middleware integration (context key vs global scope manager?)
- Performance impact of creating scope per request (allocation overhead?)
- How to handle concurrent requests with shared parent container

**Recommendation:**
- Prototype both approaches (context key vs scope manager)
- Benchmark with realistic load (1000 req/sec)
- Document pattern in local skill (di-patterns.md)

### 2. ro Plugin Maturity and Production-Readiness

**What we know:**
- ro is v0.2.0 (pre-1.0 stability)
- Plugin ecosystem exists (zerolog, http, hot, ratelimit, etc.)
- Active development as of 2025-2026

**What's unclear:**
- Which plugins are production-ready vs experimental?
- Breaking changes expected before v1.0?
- Community adoption and battle-testing

**Recommendation:**
- Start with core ro operators (Map, Filter, Concat)
- Add plugins incrementally (zerolog → http → others)
- Monitor GitHub releases for breaking changes
- Create abstraction layer if stability is concern

### 3. Performance Impact of Functional Style

**What we know:**
- Generics have minimal overhead vs reflection (~10x faster than dig)
- Parallel variants exist for CPU-bound operations
- Intermediate allocations possible with chained operations

**What's unclear:**
- Actual performance impact on cc-relay's hot paths (proxy routing, SSE streaming)
- GC pressure from functional style on 1000+ req/sec load
- Break-even point for parallel vs sequential

**Recommendation:**
- Establish baseline benchmarks BEFORE refactoring
- Benchmark each major refactor (lo, mo, ro)
- Use pprof to identify allocations/GC hotspots
- Keep imperative loops in proven hot paths if benchmarks show regression

### 4. Optimal Linter Strictness

**What we know:**
- Current: gocognit 20, gocyclo 15 (moderate)
- Target: Enable all linters, reduce complexity thresholds
- Some linters conflict (gocritic ifElseChain vs early returns)

**What's unclear:**
- Realistic cognitive complexity threshold (10? 15? 20?)
- Which conflicting linters to prioritize
- Team tolerance for linter noise

**Recommendation:**
- Reduce gradually: gocognit 20 → 15 → 10
- Enable linters by category (correctness → performance → style)
- Document disabled linters with rationale
- Review after 1 month to adjust thresholds

### 5. Migration Path for Existing Code

**What we know:**
- 76 for-range loops to convert
- Mixed test coverage (13.6% to 100%)
- HTTP API must remain stable

**What's unclear:**
- Best order: lo → mo → do → ro, or different?
- Package-by-package vs layer-by-layer migration?
- How to handle partially-refactored codebase (mixing styles?)

**Recommendation:**
- Order: **Test coverage → lo → mo → do → ro** (dependencies flow)
- Package-by-package within each library (complete one before next)
- Start with high-coverage packages (auth, keypool) for quick wins
- Keep API boundary (proxy handlers) stable until end

### 6. Codebase Architecture Documentation

**What we know:**
- /gsd:map-codebase exists for architecture mapping
- Clean Architecture and Hexagonal Architecture are common Go patterns
- Current structure is flat internal/ packages

**What's unclear:**
- Should we reorganize into domain/app/infra/delivery layers?
- Or keep flat structure with better naming?
- Impact on imports and circular dependencies

**Recommendation:**
- Run /gsd:map-codebase to understand current dependencies
- Identify circular dependencies and god objects
- Refactor structure if dependencies are tangled
- Otherwise keep flat structure (simpler imports)

## Sources

### Primary (HIGH confidence)

**samber Ecosystem:**
- [GitHub - samber/lo](https://github.com/samber/lo) - Functional utilities
- [GitHub - samber/do](https://github.com/samber/do) - Dependency injection v2
- [GitHub - samber/mo](https://github.com/samber/mo) - Monads (Option, Result, Either)
- [GitHub - samber/ro](https://github.com/samber/ro) - Reactive streams
- [do.samber.dev Documentation](https://do.samber.dev/docs/about) - Official do docs
- [ro.samber.dev Documentation](https://ro.samber.dev/docs/getting-started) - Official ro docs
- [lo.samber.dev Documentation](https://lo.samber.dev/) - Official lo docs

**Testing:**
- [GitHub - stretchr/testify](https://github.com/stretchr/testify) - Assertions and mocking
- [GitHub - testcontainers/testcontainers-go](https://github.com/testcontainers/testcontainers-go) - Container-based testing
- [testcontainers.org Go Guide](https://golang.testcontainers.org/) - Official docs
- [GitHub - leanovate/gopter](https://github.com/leanovate/gopter) - Property-based testing
- [GitHub - uudashr/gocognit](https://github.com/uudashr/gocognit) - Cognitive complexity

**Linting:**
- [golangci-lint Configuration](https://golangci-lint.run/docs/configuration/) - Official docs
- [golangci-lint Linters](https://golangci-lint.run/docs/linters/) - All available linters

### Secondary (MEDIUM confidence)

**Community Guides:**
- [How To Simplify Go Data Manipulation with Samber/lo](https://www.loupzeur.net/articles/how-to-simplify-go-data-manipulation-with-samber-lo-one-liners) - LZRCORP
- [Enhancing Go Performance with Samber/Lo](https://blog.onnasoft.us/enhancing-go-performance-and-safety-with-samber-lo-library/) - OnnaSoft
- [Golang Dependency Injection with samber/do](https://medium.com/@JoshuaTan/golang-dependency-injection-based-on-generics-samber-do-without-code-generation-42f8a2d0971c) - Medium
- [Property-Based Testing in Go](https://dzone.com/articles/property-based-testing-guide-go) - DZone Comprehensive Guide
- [Golang Code Refactoring Best Practices](https://codilime.com/blog/golang-code-refactoring-use-case/) - CodiLime

**Testing Best Practices:**
- [Test Coverage in Go](https://webreference.com/go/testing/coverage/) - WebReference
- [Go Code Coverage Best Practices](https://getotterwise.com/blog/go-code-coverage-tracking-best-practices-cicd) - OtterWise
- [Google Testing Blog: Code Coverage](https://testing.googleblog.com/2020/08/code-coverage-best-practices.html) - Google

**Architecture:**
- [Clean Architecture in Go](https://threedots.tech/post/introducing-clean-architecture/) - Three Dots Labs
- [Clean Architecture with Go](https://manakuro.medium.com/clean-architecture-with-go-bce409427d31) - Medium

### Tertiary (LOW confidence - for exploration)

**Community Discussions:**
- [FP-Go Discussion](https://news.ycombinator.com/item?id=37171149) - Hacker News
- [Go beyond Goroutines: Reactive Programming](https://samuelberthe.substack.com/p/go-beyond-goroutines-introducing) - samber blog
- [Introducing Do Notation in Mo](https://dev.to/taman9333/introducing-do-notation-in-the-mo-package-for-golang-1jpc) - DEV Community

**Performance:**
- [Go code refactoring: 23x performance hunt](https://medium.com/@val_deleplace/go-code-refactoring-the-23x-performance-hunt-156746b522f7) - Medium
- [Functional Programming with Go Generics](https://bitfieldconsulting.com/posts/functional) - Bitfield Consulting

## Metadata

**Confidence breakdown:**
- Standard stack: **HIGH** - All libraries verified from GitHub repos and official docs, stable v1+ versions
- Architecture patterns: **HIGH** - Examples from official documentation and verified sources
- Pitfalls: **MEDIUM** - Based on community guides and general Go/FP experience, not cc-relay-specific
- Testing strategies: **HIGH** - Official Go testing guidance + verified library docs
- ro plugins: **MEDIUM** - v0.2.0 (pre-1.0), plugin docs partially available, needs prototype validation

**Research date:** 2026-01-22
**Valid until:** 2026-02-22 (30 days - stable ecosystem, but ro pre-1.0 may evolve)

**Key uncertainties requiring validation:**
1. Request-scoped DI performance at scale
2. ro plugin production-readiness and stability
3. Optimal cognitive complexity thresholds for team
4. Performance impact of functional style on hot paths
5. Best migration path order (test coverage first is certain, but lo→mo→do→ro needs validation)
