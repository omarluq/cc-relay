---
phase: 02.3-codebase-refactor-samber-libs
plan: 12
type: execute
wave: 12
depends_on: ["02.3-11"]
files_modified:
  - go.mod
  - go.sum
  - internal/ratelimit/ro_limiter.go
  - internal/ratelimit/ro_limiter_test.go
  - internal/cache/ro_cache.go
  - internal/cache/ro_cache_test.go
  - internal/proxy/sse_stream.go
autonomous: true

must_haves:
  truths:
    - "ro plugins integrated for rate limiting, caching, and SSE"
    - "Reactive alternatives available alongside existing implementations"
    - "All existing tests continue to pass"
  artifacts:
    - path: "internal/ratelimit/ro_limiter.go"
      provides: "Reactive rate limiter using ro native plugin"
      contains: "ro/plugins/ratelimit"
    - path: "internal/proxy/sse_stream.go"
      provides: "SSE streaming with ro operators"
      contains: "ro.Pipe"
  key_links:
    - from: "internal/ratelimit/ro_limiter.go"
      to: "github.com/samber/ro/plugins/ratelimit/native"
      via: "import"
      pattern: "ratelimit\\.RateLimit"
---

<objective>
Integrate remaining ro plugins for rate limiting, caching, and SSE streaming.

Purpose: CONTEXT.md specifies full ro plugin adoption with 8 plugins. This plan integrates the remaining plugins into actual cc-relay functionality, providing reactive alternatives to existing implementations.
Output: Reactive rate limiter, reactive cache wrapper, and SSE streaming utilities.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02.3-codebase-refactor-samber-libs/02.3-CONTEXT.md
@.planning/phases/02.3-codebase-refactor-samber-libs/02.3-RESEARCH.md

# Prior ro work
@.planning/phases/02.3-codebase-refactor-samber-libs/02.3-11-SUMMARY.md

# Skills for patterns
@.claude/skills/samber-ro.md
@.claude/skills/streams.md

# Current implementations to enhance
@internal/ratelimit/limiter.go
@internal/cache/cache.go
@internal/proxy/handler.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install remaining ro plugins and create reactive rate limiter</name>
  <files>
    go.mod
    go.sum
    internal/ratelimit/ro_limiter.go
    internal/ratelimit/ro_limiter_test.go
  </files>
  <action>
Install remaining plugins and create reactive rate limiter:

1. Install remaining plugins:
   ```bash
   # Rate limiting
   go get github.com/samber/ro/plugins/ratelimit/native

   # HTTP (for SSE)
   go get github.com/samber/ro/plugins/network/http

   # Hot cache
   go get github.com/samber/ro/plugins/cache/hot

   # File watching (prep for Phase 7)
   go get github.com/samber/ro/plugins/io/fsnotify

   go mod tidy
   ```

2. Create ro_limiter.go:
   ```go
   package ratelimit

   import (
       "time"
       "github.com/samber/ro"
       rlimit "github.com/samber/ro/plugins/ratelimit/native"
   )

   // ROLimiter wraps ro rate limiting for stream processing
   type ROLimiter struct {
       rpm int
       tpm int
   }

   // NewROLimiter creates reactive rate limiter
   func NewROLimiter(rpm, tpm int) *ROLimiter {
       return &ROLimiter{rpm: rpm, tpm: tpm}
   }

   // LimitRPM applies RPM limit to observable
   func (r *ROLimiter) LimitRPM[T any](source ro.Observable[T]) ro.Observable[T] {
       return ro.Pipe(
           source,
           rlimit.RateLimit[T](r.rpm, time.Minute),
       )
   }

   // LimitTPM applies TPM limit to observable
   func (r *ROLimiter) LimitTPM[T any](source ro.Observable[T]) ro.Observable[T] {
       return ro.Pipe(
           source,
           rlimit.RateLimit[T](r.tpm, time.Minute),
       )
   }
   ```

3. Tests in ro_limiter_test.go:
   - Test rate limit enforcement
   - Test burst handling
   - Test concurrent access

Note: ROLimiter is an ALTERNATIVE to existing TokenBucket, not a replacement.
Both can coexist - use ROLimiter for stream processing, TokenBucket for sync.
  </action>
  <verify>
Run: `go build ./internal/ratelimit/` - builds successfully
Run: `go test -v ./internal/ratelimit/` - all tests pass (including new ones)
  </verify>
  <done>Reactive rate limiter created with ro native plugin</done>
</task>

<task type="auto">
  <name>Task 2: Create reactive cache wrapper</name>
  <files>
    internal/cache/ro_cache.go
    internal/cache/ro_cache_test.go
  </files>
  <action>
Create reactive cache wrapper using ro hot plugin:

1. ro_cache.go:
   ```go
   package cache

   import (
       "time"
       "github.com/samber/ro"
       rohot "github.com/samber/ro/plugins/cache/hot"
   )

   // ROCache provides reactive cache operations
   type ROCache struct {
       cache *rohot.Cache[string, any]
   }

   // NewROCache creates reactive cache
   func NewROCache(maxSize int, ttl time.Duration) *ROCache {
       return &ROCache{
           cache: rohot.New[string, any](
               rohot.WithMaxSize(maxSize),
               rohot.WithTTL(ttl),
           ),
       }
   }

   // GetOrFetch returns cached value or fetches from source
   func (c *ROCache) GetOrFetch[T any](
       key string,
       fetch func() ro.Observable[T],
   ) ro.Observable[T] {
       if val, ok := c.cache.Get(key); ok {
           if typed, ok := val.(T); ok {
               return ro.Just(typed)
           }
       }

       return ro.Pipe(
           fetch(),
           ro.Do(func(val T) {
               c.cache.Set(key, val)
           }),
       )
   }

   // Invalidate removes key from cache
   func (c *ROCache) Invalidate(key string) {
       c.cache.Delete(key)
   }
   ```

2. Tests in ro_cache_test.go:
   - Test cache hit returns cached value
   - Test cache miss fetches from source
   - Test TTL expiration
   - Test invalidation

Note: ROCache complements existing Cache, doesn't replace it.
Use for stream-based operations where reactive patterns fit.
  </action>
  <verify>
Run: `go build ./internal/cache/` - builds successfully
Run: `go test -v ./internal/cache/` - all tests pass
  </verify>
  <done>Reactive cache wrapper created</done>
</task>

<task type="auto">
  <name>Task 3: Create SSE streaming utilities</name>
  <files>
    internal/proxy/sse_stream.go
    internal/proxy/sse_stream_test.go
  </files>
  <action>
Create SSE streaming utilities with ro:

1. sse_stream.go:
   ```go
   package proxy

   import (
       "bufio"
       "net/http"
       "github.com/samber/ro"
       rohttp "github.com/samber/ro/plugins/network/http"
   )

   // SSEEvent represents a Server-Sent Event
   type SSEEvent struct {
       Event string
       Data  []byte
       ID    string
       Retry int
   }

   // StreamSSE creates observable from SSE response
   func StreamSSE(resp *http.Response) ro.Observable[SSEEvent] {
       return ro.Create(func(observer ro.Observer[SSEEvent]) {
           defer resp.Body.Close()
           reader := bufio.NewReader(resp.Body)

           for {
               line, err := reader.ReadBytes('\n')
               if err != nil {
                   if err.Error() != "EOF" {
                       observer.OnError(err)
                   }
                   break
               }

               event, ok := parseSSELine(line)
               if ok {
                   observer.OnNext(event)
               }
           }

           observer.OnComplete()
       })
   }

   // ForwardSSE pipes SSE events to http.ResponseWriter
   func ForwardSSE(
       events ro.Observable[SSEEvent],
       w http.ResponseWriter,
   ) error {
       w.Header().Set("Content-Type", "text/event-stream")
       w.Header().Set("Cache-Control", "no-cache, no-transform")
       w.Header().Set("X-Accel-Buffering", "no")

       flusher, ok := w.(http.Flusher)
       if !ok {
           return ErrNotFlushable
       }

       errCh := make(chan error, 1)

       events.Subscribe(ro.Observer[SSEEvent]{
           OnNext: func(event SSEEvent) {
               writeSSEEvent(w, event)
               flusher.Flush()
           },
           OnError: func(err error) {
               errCh <- err
           },
           OnComplete: func() {
               close(errCh)
           },
       })

       return <-errCh
   }

   // parseSSELine parses a single SSE line
   func parseSSELine(line []byte) (SSEEvent, bool) {
       // Parse event: / data: / id: / retry: prefixes
   }

   // writeSSEEvent writes event in SSE format
   func writeSSEEvent(w http.ResponseWriter, event SSEEvent) {
       // Write event in SSE wire format
   }
   ```

2. Tests in sse_stream_test.go:
   - Test StreamSSE parses events correctly
   - Test ForwardSSE writes correct format
   - Test error propagation

Note: These utilities can be used by handler.go in the future.
Current handler.go can continue using direct streaming for now.
  </action>
  <verify>
Run: `go build ./internal/proxy/` - builds successfully
Run: `go test -v ./internal/proxy/` - all tests pass
  </verify>
  <done>SSE streaming utilities created with ro</done>
</task>

</tasks>

<verification>
1. All ro plugins installed (native, http, hot, fsnotify)
2. `go build ./...` - all packages build
3. `go test -race ./...` - all tests pass
4. Reactive alternatives available:
   - ROLimiter for stream rate limiting
   - ROCache for reactive caching
   - SSE streaming utilities
5. Existing implementations unchanged (backward compatible)
</verification>

<success_criteria>
- 8 ro plugins installed and importable
- Reactive rate limiter (ROLimiter) created
- Reactive cache wrapper (ROCache) created
- SSE streaming utilities (StreamSSE, ForwardSSE) created
- All existing tests pass
- New utilities have >80% coverage
- Documentation in code explains when to use reactive vs sync
</success_criteria>

<output>
After completion, create `.planning/phases/02.3-codebase-refactor-samber-libs/02.3-12-SUMMARY.md`
</output>
