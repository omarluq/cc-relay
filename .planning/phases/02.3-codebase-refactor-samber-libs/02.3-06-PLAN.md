---
phase: 02.3-codebase-refactor-samber-libs
plan: 06
type: execute
wave: 3
depends_on: ["02.3-03", "02.3-04", "02.3-05"]
files_modified:
  - internal/config/config.go
  - internal/keypool/key.go
  - internal/proxy/handler.go
  - internal/auth/chain.go
autonomous: true

must_haves:
  truths:
    - "Error-returning functions use mo.Result[T] pattern"
    - "Nullable config fields use mo.Option[T]"
    - "All existing tests pass with monadic types"
  artifacts:
    - path: "internal/config/config.go"
      provides: "Config with mo.Option for nullable fields"
      contains: "github.com/samber/mo"
    - path: "internal/auth/chain.go"
      provides: "Auth chain with mo.Result pattern"
      contains: "github.com/samber/mo"
  key_links:
    - from: "internal/auth/chain.go"
      to: "github.com/samber/mo"
      via: "import"
      pattern: "mo\\.(Result|Option|Ok|Err)"
---

<objective>
Introduce samber/mo monads for improved error handling and nullable field safety.

Purpose: mo.Result[T] enables composable error handling (Railway-Oriented Programming). mo.Option[T] eliminates nil-pointer risks for optional config fields. This refactor improves code safety and expressiveness.
Output: Auth flows using Result chains, Config using Option for nullable fields.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02.3-codebase-refactor-samber-libs/02.3-RESEARCH.md
@.claude/skills/samber-mo.md

# Relevant summaries
@.planning/phases/02.3-codebase-refactor-samber-libs/02.3-03-SUMMARY.md
@.planning/phases/02.3-codebase-refactor-samber-libs/02.3-04-SUMMARY.md
@.planning/phases/02.3-codebase-refactor-samber-libs/02.3-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mo.Option[T] to config nullable fields</name>
  <files>
    internal/config/config.go
    internal/config/loader.go
    internal/config/config_test.go
  </files>
  <action>
Replace pointer-based nullable fields with mo.Option[T]:

1. Identify nullable config fields (fields that are *Type):
   ```bash
   grep -n "\*int\|\*string\|\*time.Duration\|\*bool" internal/config/config.go
   ```

2. Convert to Option pattern:
   ```go
   // Before
   type ServerConfig struct {
       Timeout *time.Duration `yaml:"timeout,omitempty"`
   }

   // After
   type ServerConfig struct {
       Timeout mo.Option[time.Duration] `yaml:"timeout,omitempty"`
   }
   ```

3. Update usage sites:
   ```go
   // Before
   if cfg.Timeout != nil {
       timeout = *cfg.Timeout
   } else {
       timeout = defaultTimeout
   }

   // After
   timeout := cfg.Timeout.OrElse(defaultTimeout)
   ```

4. Handle YAML unmarshaling:
   - mo.Option has JSON/YAML support built-in
   - Test that yaml.v3 correctly unmarshal Option fields

5. Update tests to use Option patterns:
   - Replace nil checks with IsPresent()/IsAbsent()
   - Use OrElse() for default values
  </action>
  <verify>
Run: `go test -v ./internal/config/` - all tests pass
Verify YAML loading still works correctly
  </verify>
  <done>Config nullable fields converted to mo.Option[T]</done>
</task>

<task type="auto">
  <name>Task 2: Add mo.Result[T] to auth flow</name>
  <files>
    internal/auth/chain.go
    internal/auth/apikey.go
    internal/auth/auth.go
    internal/auth/chain_test.go
  </files>
  <action>
Convert auth chain to use Result[T] for composable error handling:

1. Identify auth functions returning (value, error):
   ```bash
   grep -n "func.*error" internal/auth/*.go
   ```

2. Convert to Result pattern (internal functions first, keep API stable):
   ```go
   // Internal helper - converted to Result
   func validateKey(key string) mo.Result[*APIKey] {
       if key == "" {
           return mo.Err[*APIKey](ErrEmptyKey)
       }
       return mo.Ok(&APIKey{Value: key})
   }

   // Chain authentication
   func (c *Chain) AuthenticateRequest(r *http.Request) mo.Result[*AuthResult] {
       return c.extractKey(r).
           FlatMap(c.validateKey).
           FlatMap(c.checkPermissions)
   }
   ```

3. Keep public API compatible:
   - Public functions can still return (value, error)
   - Use .Get() or .Error() at boundaries
   - Internal functions use Result for composition

4. Update tests:
   - Use Result assertions
   - Test error chaining behavior
   - Verify error messages preserved
  </action>
  <verify>
Run: `go test -v ./internal/auth/` - all tests pass (100% coverage maintained)
Run: `go test -race ./internal/auth/` - no race conditions
  </verify>
  <done>Auth chain uses mo.Result for composable error handling</done>
</task>

<task type="auto">
  <name>Task 3: Apply mo patterns to keypool and proxy where beneficial</name>
  <files>
    internal/keypool/key.go
    internal/keypool/pool.go
    internal/proxy/handler.go
  </files>
  <action>
Selectively apply mo patterns to other packages:

1. keypool - Result for key selection:
   ```go
   func (p *Pool) GetKey() mo.Result[*Key] {
       // Return Result instead of (*Key, error)
   }
   ```

2. keypool - Option for optional key fields:
   ```go
   type KeyMetadata struct {
       Priority mo.Option[int] // Optional priority override
   }
   ```

3. proxy/handler.go - Keep existing API but use Result internally:
   - Error handling chains in request processing
   - Don't change public Handler interface

4. Be selective - don't force mo everywhere:
   - Use Result where error chaining adds clarity
   - Use Option where nil checks were error-prone
   - Keep simple functions as (value, error) if clearer

5. Run comprehensive tests after each change:
   ```bash
   go test -v ./internal/keypool/ ./internal/proxy/
   ```
  </action>
  <verify>
Run: `go test -race ./...` - all tests pass
Run: `go build ./cmd/cc-relay/` - builds successfully
  </verify>
  <done>mo patterns applied selectively across codebase</done>
</task>

</tasks>

<verification>
1. `go test -v ./internal/config/` - all tests pass
2. `go test -v ./internal/auth/` - all tests pass (100% coverage)
3. `go test -race ./...` - no race conditions
4. `grep "github.com/samber/mo" internal/*/*.go` - mo imported where used
5. YAML config loading verified working with Option fields
</verification>

<success_criteria>
- mo.Option[T] used for nullable config fields
- mo.Result[T] used for auth chain error handling
- Selective mo adoption in keypool and proxy
- All tests pass
- No race conditions
- HTTP API unchanged (mo is internal refactor)
</success_criteria>

<output>
After completion, create `.planning/phases/02.3-codebase-refactor-samber-libs/02.3-06-SUMMARY.md`
</output>
