---
phase: 02.3-codebase-refactor-samber-libs
plan: 11
type: execute
wave: 11
depends_on: ["02.3-10"]
files_modified:
  - go.mod
  - go.sum
  - internal/ro/streams.go
  - internal/ro/streams_test.go
  - internal/ro/README.md
autonomous: true

must_haves:
  truths:
    - "samber/ro v0.2.0 integrated with core operators"
    - "Reactive stream foundation established for future use"
    - "Stream utilities documented with usage patterns"
  artifacts:
    - path: "internal/ro/streams.go"
      provides: "Reactive stream utilities for cc-relay"
      contains: "github.com/samber/ro"
      min_lines: 100
    - path: "internal/ro/README.md"
      provides: "Documentation for ro integration"
      min_lines: 50
  key_links:
    - from: "internal/ro/streams.go"
      to: "github.com/samber/ro"
      via: "import"
      pattern: "ro\\.(Pipe|Map|Filter)"
---

<objective>
Establish samber/ro reactive stream foundation for future SSE and event processing.

Purpose: CONTEXT.md requires full ro plugin adoption. This plan creates the foundation: installs ro and plugins, creates stream utilities, and prepares the codebase for reactive patterns. Actual usage in proxy/SSE comes in Plan 12.
Output: internal/ro package with stream utilities, plugin integrations, and documentation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02.3-codebase-refactor-samber-libs/02.3-CONTEXT.md
@.planning/phases/02.3-codebase-refactor-samber-libs/02.3-RESEARCH.md

# Samber skills for patterns
@.claude/skills/samber-ro.md
@.claude/skills/streams.md

# Current go.mod
@go.mod
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install ro core and relevant plugins</name>
  <files>
    go.mod
    go.sum
  </files>
  <action>
Install samber/ro core library and plugins from CONTEXT.md requirements:

```bash
# Core ro library
go get github.com/samber/ro@v0.2.0

# Plugins (from CONTEXT.md)
# - Zerolog: reactive logging (complements existing zerolog)
go get github.com/samber/ro/plugins/observability/zerolog

# - Signal: graceful shutdown handling
go get github.com/samber/ro/plugins/system/signal

# - Oops: structured error handling (complements mo)
go get github.com/samber/ro/plugins/observability/oops

# - Validation (ozzo): config validation
go get github.com/samber/ro/plugins/validation/ozzo

# - Testify: testing utilities for streams
go get github.com/samber/ro/plugins/testing/testify

# Tidy dependencies
go mod tidy
```

Note: Some plugins may not be production-ready (ro is v0.2.0).
Install cautiously and test each import.

Plugins deferred to Plan 12 (require actual usage):
- ro/plugins/network/http (for SSE)
- ro/plugins/cache/hot (for cache)
- ro/plugins/ratelimit/native (for rate limiting)
- ro/plugins/io/fsnotify (for Phase 7 hot-reload)
  </action>
  <verify>
Run: `go mod tidy` - succeeds
Run: `go build ./...` - builds successfully
Verify: `grep "samber/ro" go.mod` - ro is present
  </verify>
  <done>ro core and plugins installed</done>
</task>

<task type="auto">
  <name>Task 2: Create ro stream utilities package</name>
  <files>
    internal/ro/streams.go
    internal/ro/operators.go
    internal/ro/shutdown.go
  </files>
  <action>
Create internal/ro package with stream utilities:

1. **streams.go** - Core stream patterns:
   ```go
   package ro

   import (
       "github.com/samber/ro"
   )

   // StreamFromChannel creates observable from channel
   func StreamFromChannel[T any](ch <-chan T) ro.Observable[T] {
       return ro.FromChannel(ch)
   }

   // StreamFromSlice creates observable from slice
   func StreamFromSlice[T any](items []T) ro.Observable[T] {
       return ro.FromSlice(items)
   }

   // ProcessStream applies standard pipeline
   func ProcessStream[T, R any](
       source ro.Observable[T],
       mapper func(T) R,
       filter func(R) bool,
   ) ro.Observable[R] {
       return ro.Pipe(
           source,
           ro.Map(mapper),
           ro.Filter(filter),
       )
   }
   ```

2. **operators.go** - Common operators for cc-relay:
   ```go
   // LogEach logs each item through zerolog
   func LogEach[T any](logger zerolog.Logger, name string) ro.Operator[T, T] {
       return func(source ro.Observable[T]) ro.Observable[T] {
           return ro.Do(source, func(item T) {
               logger.Debug().Interface("item", item).Str("stream", name).Msg("stream event")
           })
       }
   }

   // WithTimeout adds timeout to stream
   func WithTimeout[T any](timeout time.Duration) ro.Operator[T, T] {
       // Implementation using context cancellation
   }
   ```

3. **shutdown.go** - Signal handling with ro:
   ```go
   // GracefulShutdown creates shutdown observable
   func GracefulShutdown(ctx context.Context) ro.Observable[os.Signal] {
       // Use ro signal plugin or manual implementation
   }
   ```
  </action>
  <verify>
Run: `go build ./internal/ro/` - builds successfully
Package exports expected functions
  </verify>
  <done>ro stream utilities package created</done>
</task>

<task type="auto">
  <name>Task 3: Add tests and documentation</name>
  <files>
    internal/ro/streams_test.go
    internal/ro/operators_test.go
    internal/ro/README.md
  </files>
  <action>
Add comprehensive tests and documentation:

1. **streams_test.go**:
   ```go
   func TestStreamFromChannel(t *testing.T) {
       ch := make(chan int, 3)
       ch <- 1
       ch <- 2
       ch <- 3
       close(ch)

       var results []int
       StreamFromChannel(ch).Subscribe(ro.Observer[int]{
           OnNext: func(i int) { results = append(results, i) },
       })

       assert.Equal(t, []int{1, 2, 3}, results)
   }

   func TestProcessStream(t *testing.T) {
       items := []int{1, 2, 3, 4, 5}
       source := StreamFromSlice(items)

       doubled := ProcessStream(source,
           func(i int) int { return i * 2 },
           func(i int) bool { return i > 4 },
       )

       var results []int
       doubled.Subscribe(ro.Observer[int]{
           OnNext: func(i int) { results = append(results, i) },
       })

       assert.Equal(t, []int{6, 8, 10}, results)
   }
   ```

2. **operators_test.go**:
   - Test LogEach doesn't modify stream values
   - Test WithTimeout cancels properly

3. **README.md**:
   ```markdown
   # internal/ro - Reactive Streams for cc-relay

   ## Overview
   This package provides reactive stream utilities using samber/ro.

   ## When to Use
   - SSE streaming (proxy -> client)
   - Event processing (multiple sources)
   - Graceful shutdown coordination

   ## When NOT to Use
   - Simple request/response (use standard handlers)
   - Single-value operations (use mo.Result)

   ## Usage Examples
   ...
   ```
  </action>
  <verify>
Run: `go test -v ./internal/ro/` - all tests pass
README.md documents usage patterns
  </verify>
  <done>Tests and documentation complete</done>
</task>

</tasks>

<verification>
1. `go mod tidy` succeeds
2. `go build ./internal/ro/` builds successfully
3. `go test -v ./internal/ro/` all tests pass
4. README.md exists with usage guidance
5. Package exports usable stream utilities
</verification>

<success_criteria>
- samber/ro v0.2.0 installed
- Signal, zerolog, oops, validation, testify plugins installed
- internal/ro package provides stream utilities
- Tests pass with >80% coverage
- Documentation explains when to use (and not use) streams
</success_criteria>

<output>
After completion, create `.planning/phases/02.3-codebase-refactor-samber-libs/02.3-11-SUMMARY.md`
</output>
