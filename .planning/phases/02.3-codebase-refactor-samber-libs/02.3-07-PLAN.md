---
phase: 02.3-codebase-refactor-samber-libs
plan: 07
type: execute
wave: 4
depends_on: ["02.3-06"]
files_modified:
  - cmd/cc-relay/di/container.go
  - cmd/cc-relay/di/providers.go
  - cmd/cc-relay/di/middleware.go
  - cmd/cc-relay/serve.go
autonomous: true

must_haves:
  truths:
    - "Service wiring uses samber/do DI container"
    - "Singletons properly registered (Config, Cache, KeyPool, Providers)"
    - "serve.go simplified to DI initialization"
  artifacts:
    - path: "cmd/cc-relay/di/container.go"
      provides: "DI container setup"
      contains: "github.com/samber/do/v2"
      min_lines: 50
    - path: "cmd/cc-relay/di/providers.go"
      provides: "Service provider registrations"
      contains: "do.Provide"
      min_lines: 80
  key_links:
    - from: "cmd/cc-relay/serve.go"
      to: "cmd/cc-relay/di/container.go"
      via: "DI initialization"
      pattern: "di\\.(New|Setup|Register)"
---

<objective>
Introduce samber/do v2 dependency injection to clean up service wiring in serve.go.

Purpose: serve.go currently has complex manual wiring. DI container provides type-safe, lazy-loaded service initialization with lifecycle management. This improves testability and maintainability.
Output: New di/ package with container setup, serve.go simplified to use DI.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02.3-codebase-refactor-samber-libs/02.3-RESEARCH.md
@.claude/skills/samber-do.md

# Current serve.go to refactor
@cmd/cc-relay/serve.go

# Services that need registration
@internal/config/config.go
@internal/cache/cache.go
@internal/keypool/pool.go
@internal/providers/provider.go
@internal/proxy/handler.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DI container and service providers</name>
  <files>
    cmd/cc-relay/di/container.go
    cmd/cc-relay/di/providers.go
  </files>
  <action>
Create the DI package structure:

1. cmd/cc-relay/di/container.go:
   ```go
   package di

   import "github.com/samber/do/v2"

   // NewContainer creates and configures the DI container
   func NewContainer(configPath string) (*do.Injector, error) {
       injector := do.New()

       // Provide config path as value
       do.ProvideValue(injector, configPath)

       // Register all service providers
       RegisterSingletons(injector)

       return injector, nil
   }

   // Shutdown gracefully shuts down all services
   func Shutdown(injector *do.Injector) error {
       return injector.Shutdown()
   }
   ```

2. cmd/cc-relay/di/providers.go:
   ```go
   package di

   import (
       "github.com/samber/do/v2"
       "github.com/omarluq/cc-relay/internal/config"
       "github.com/omarluq/cc-relay/internal/cache"
       "github.com/omarluq/cc-relay/internal/keypool"
       "github.com/omarluq/cc-relay/internal/providers"
       "github.com/omarluq/cc-relay/internal/proxy"
   )

   func RegisterSingletons(i *do.Injector) {
       do.Provide(i, NewConfig)
       do.Provide(i, NewCache)
       do.Provide(i, NewKeyPool)
       do.Provide(i, NewProviderMap)
       do.Provide(i, NewProxyHandler)
       do.Provide(i, NewHTTPServer)
   }

   func NewConfig(i *do.Injector) (*config.Config, error) {
       path := do.MustInvoke[string](i) // config path
       return config.Load(path)
   }

   func NewCache(i *do.Injector) (*cache.Cache, error) {
       cfg := do.MustInvoke[*config.Config](i)
       return cache.NewFromConfig(cfg.Cache)
   }

   // ... similar for other services
   ```

3. Follow dependency order:
   - Config (no dependencies)
   - Cache (depends on Config)
   - Providers (depends on Config)
   - KeyPool (depends on Config, Cache)
   - Handler (depends on KeyPool, Providers, Cache)
   - Server (depends on Handler, Config)
  </action>
  <verify>
Run: `go build ./cmd/cc-relay/di/` - builds without errors
Verify all imports resolve correctly
  </verify>
  <done>DI container and providers created</done>
</task>

<task type="auto">
  <name>Task 2: Refactor serve.go to use DI container</name>
  <files>
    cmd/cc-relay/serve.go
  </files>
  <action>
Simplify serve.go to use DI instead of manual wiring:

1. Before (manual wiring):
   ```go
   func runServe(cmd *cobra.Command, args []string) error {
       cfg, err := config.Load(configPath)
       if err != nil { return err }

       cache, err := cache.NewFromConfig(cfg.Cache)
       if err != nil { return err }

       keyPool := keypool.New(cfg.Providers, cache)
       // ... more manual wiring
   }
   ```

2. After (DI-based):
   ```go
   func runServe(cmd *cobra.Command, args []string) error {
       // Create DI container
       injector, err := di.NewContainer(configPath)
       if err != nil {
           return fmt.Errorf("failed to create DI container: %w", err)
       }
       defer di.Shutdown(injector)

       // Get the HTTP server (all dependencies resolved automatically)
       server := do.MustInvoke[*http.Server](injector)

       // Start server with graceful shutdown
       return runServerWithGracefulShutdown(server, injector)
   }
   ```

3. Keep signal handling and graceful shutdown logic:
   - Signal handler calls di.Shutdown(injector)
   - Timeout for shutdown (30 seconds)
   - Log shutdown progress

4. Remove duplicated wiring code - DI handles it now.
  </action>
  <verify>
Run: `go test -v ./cmd/cc-relay/` - all tests pass
Run: `go build ./cmd/cc-relay/` - builds successfully
Manual test: `./bin/cc-relay serve --help` works
  </verify>
  <done>serve.go simplified to use DI container</done>
</task>

<task type="auto">
  <name>Task 3: Add tests and verify DI integration</name>
  <files>
    cmd/cc-relay/di/container_test.go
    cmd/cc-relay/di/providers_test.go
    cmd/cc-relay/serve_test.go
  </files>
  <action>
Add comprehensive tests for DI:

1. container_test.go:
   - Test container creation with valid config
   - Test container creation with invalid config (returns error)
   - Test shutdown behavior
   - Test service resolution order

2. providers_test.go:
   - Test each provider function individually
   - Test dependency injection works correctly
   - Test error propagation from providers
   - Mock dependencies for unit testing

3. Update serve_test.go:
   - Test serve with DI container
   - Test graceful shutdown with DI
   - Mock DI container for unit tests

4. Integration test:
   - Create container
   - Resolve all services
   - Verify they're correctly wired
   - Shutdown and verify cleanup

5. Run full test suite:
   ```bash
   go test -race ./cmd/cc-relay/...
   ```
  </action>
  <verify>
Run: `go test -v ./cmd/cc-relay/...` - all tests pass
Run: `go test -cover ./cmd/cc-relay/` - coverage improved from baseline
Run: `go test -race ./cmd/cc-relay/` - no race conditions
  </verify>
  <done>DI tests added, integration verified</done>
</task>

</tasks>

<verification>
1. `go build ./cmd/cc-relay/` - builds successfully
2. `go test -v ./cmd/cc-relay/...` - all tests pass
3. `go test -race ./cmd/cc-relay/` - no race conditions
4. DI package exists at cmd/cc-relay/di/
5. serve.go is simplified (fewer lines than before)
6. Manual test: binary starts and accepts requests
</verification>

<success_criteria>
- DI container created with samber/do v2
- All services registered as singletons
- serve.go significantly simplified
- Tests pass with >80% coverage in cmd/
- No race conditions
- Graceful shutdown works correctly
</success_criteria>

<output>
After completion, create `.planning/phases/02.3-codebase-refactor-samber-libs/02.3-07-SUMMARY.md`
</output>
