# Phase 04.1: Health Checker Wiring - Research

**Researched:** 2026-01-23
**Domain:** Go application lifecycle, DI container integration, service startup
**Confidence:** HIGH

## Summary

This research investigates how to wire the existing `health.Checker` component to make periodic health checks operational. The Phase 04 implementation created all necessary components (Checker, ProviderHealthCheck, HTTPHealthCheck) but left two integration gaps: `Checker.Start()` is never called and no providers are registered via `RegisterProvider()`.

The fix is straightforward because all building blocks exist. The DI container (`samber/do/v2`) already has `CheckerService` registered with proper shutdown support. The `Checker.Start()` method is fully implemented and tested. The `NewProviderHealthCheck()` factory function creates appropriate health checks from provider base URLs.

The wiring requires two changes: (1) Start the Checker after DI initialization in serve.go, and (2) Register health checks for each provider in the DI provider setup.

**Primary recommendation:** Call `checkerSvc.Checker.Start()` in serve.go after DI initialization, and loop through provider configs in DI to register health checks via `RegisterProvider(NewProviderHealthCheck(name, baseURL, nil))`.

## Standard Stack

This phase uses only existing codebase components - no new libraries.

### Core (Already Present)
| Component | Location | Purpose | Status |
|-----------|----------|---------|--------|
| `health.Checker` | `internal/health/checker.go` | Periodic health checking | Implemented, not started |
| `health.NewChecker` | `internal/health/checker.go` | Constructor | Used in DI |
| `health.RegisterProvider` | `internal/health/checker.go` | Register provider health check | Implemented, not called |
| `health.NewProviderHealthCheck` | `internal/health/checker.go` | Factory for health checks | Implemented, not called |
| `samber/do/v2` | `cmd/cc-relay/di/` | DI container | Already integrated |
| `CheckerService` | `cmd/cc-relay/di/providers.go` | DI wrapper | Registered with Shutdown() |

### Supporting (Already Present)
| Component | Location | Purpose | When to Use |
|-----------|----------|---------|-------------|
| `config.ProviderConfig.BaseURL` | `internal/config/config.go` | Provider base URL for health checks | In RegisterProvider call |
| `LoggerService` | `cmd/cc-relay/di/providers.go` | DI logger for health components | Already injected |

### No Alternatives Needed

This is gap closure - the design is already established. No library or approach alternatives to consider.

## Architecture Patterns

### Pattern 1: DI Service Startup Hook

**What:** Start long-running services after DI container is fully initialized
**When to use:** Services with background goroutines (like Checker) that need other services ready
**Where this applies:** serve.go, after `di.Invoke[*di.ServerService]` but before `ListenAndServe`

```go
// Source: Existing pattern in serve.go
// Get server from DI container (lazy initialization of all dependencies)
serverSvc, err := di.Invoke[*di.ServerService](container)

// NEW: Start health checker after all services initialized
checkerSvc := di.MustInvoke[*di.CheckerService](container)
checkerSvc.Checker.Start()

// Existing: Run server with graceful shutdown
return runWithGracefulShutdown(serverSvc.Server, container, cfg.Server.Listen)
```

### Pattern 2: Provider Registration in DI Factory

**What:** Register health checks for all providers during DI initialization
**When to use:** When health check registration needs access to provider config
**Where this applies:** `NewChecker` in providers.go, after creating Checker

```go
// Source: Pattern based on existing NewProxyHandler provider loop
func NewChecker(i do.Injector) (*CheckerService, error) {
    cfgSvc := do.MustInvoke[*ConfigService](i)
    trackerSvc := do.MustInvoke[*HealthTrackerService](i)
    loggerSvc := do.MustInvoke[*LoggerService](i)

    checker := health.NewChecker(
        trackerSvc.Tracker,
        cfgSvc.Config.Health.HealthCheck,
        loggerSvc.Logger,
    )

    // NEW: Register health checks for all enabled providers
    for idx := range cfgSvc.Config.Providers {
        pc := &cfgSvc.Config.Providers[idx]
        if !pc.Enabled {
            continue
        }
        healthCheck := health.NewProviderHealthCheck(pc.Name, pc.BaseURL, nil)
        checker.RegisterProvider(healthCheck)
    }

    return &CheckerService{Checker: checker}, nil
}
```

### Pattern 3: Graceful Shutdown via DI Shutdowner

**What:** CheckerService implements `do.Shutdowner` interface
**Where this applies:** Already implemented in providers.go
**Why it matters:** `container.ShutdownWithContext()` in serve.go will call `Checker.Stop()`

```go
// Source: Already exists in cmd/cc-relay/di/providers.go (lines 153-158)
func (h *CheckerService) Shutdown() error {
    if h.Checker != nil {
        h.Checker.Stop()
    }
    return nil
}
```

### Anti-Patterns to Avoid

- **Starting Checker in NewChecker:** Don't call `Start()` in the DI factory function. DI initialization order isn't guaranteed to have all services ready. Start in serve.go after full initialization.
- **Registering providers in serve.go:** Don't loop through configs in serve.go. Keep provider registration in DI where configs are already accessed.
- **Ignoring disabled checker:** If `health.health_check.enabled: false`, `Start()` is a no-op, but still call it - the check is inside `Start()`.

## Don't Hand-Roll

This phase requires no new implementations - only wiring existing components.

| Problem | Already Exists | Location | Notes |
|---------|----------------|----------|-------|
| Health check creation | `NewProviderHealthCheck()` | checker.go:116 | Handles empty URL (returns NoOp) |
| Provider iteration | Loop in NewProxyHandler | providers.go | Same pattern needed for Checker |
| Service startup | serve.go pattern | serve.go:85 | Get service, then use |
| Graceful shutdown | CheckerService.Shutdown | providers.go:153 | Already implemented |

**Key insight:** All building blocks exist. This phase is pure integration wiring.

## Common Pitfalls

### Pitfall 1: Starting Checker Too Early

**What goes wrong:** Start() called before all providers registered
**Why it happens:** Calling Start() in NewChecker before registration loop
**How to avoid:** Register providers in NewChecker, Start() in serve.go
**Warning signs:** Empty health check map in logs, no providers being checked

### Pitfall 2: Missing Provider Base URLs

**What goes wrong:** All providers get NoOpHealthCheck
**Why it happens:** Some providers have empty BaseURL (e.g., custom or test configs)
**How to avoid:** This is fine - `NewProviderHealthCheck()` handles empty URLs by returning NoOpHealthCheck
**Warning signs:** None - this is intentional design (see checker.go:117-118)

### Pitfall 3: Double Start on Restart

**What goes wrong:** Panic or goroutine leak on config hot-reload
**Why it happens:** Checker.Start() called multiple times without Stop()
**How to avoid:** Current design only calls Start() once at serve startup. Hot-reload would need CheckerService recreation.
**Warning signs:** Multiple "health checker started" log messages

### Pitfall 4: Shutdown Order Issues

**What goes wrong:** Checker goroutine running after server stopped
**Why it happens:** Server shutdown before Checker shutdown
**How to avoid:** DI container shutdown order is LIFO. Server registered after Checker, so Server shuts down first. This is correct.
**Warning signs:** "health check failed" errors during shutdown (requests to stopped server)

### Pitfall 5: Forgetting to Wire Start()

**What goes wrong:** Health checker silently never runs
**Why it happens:** Only registering providers, forgetting Start() call
**How to avoid:** Add integration test that verifies Checker.Start() is called
**Warning signs:** No "health checker started" log message on startup

## Code Examples

### Example 1: Modified NewChecker with Provider Registration

```go
// Source: Update to cmd/cc-relay/di/providers.go

// NewChecker creates the health checker from configuration and registers providers.
func NewChecker(i do.Injector) (*CheckerService, error) {
    cfgSvc := do.MustInvoke[*ConfigService](i)
    trackerSvc := do.MustInvoke[*HealthTrackerService](i)
    loggerSvc := do.MustInvoke[*LoggerService](i)

    checker := health.NewChecker(
        trackerSvc.Tracker,
        cfgSvc.Config.Health.HealthCheck,
        loggerSvc.Logger,
    )

    // Register health checks for all enabled providers
    for idx := range cfgSvc.Config.Providers {
        pc := &cfgSvc.Config.Providers[idx]
        if !pc.Enabled {
            continue
        }
        // NewProviderHealthCheck handles empty BaseURL (returns NoOpHealthCheck)
        healthCheck := health.NewProviderHealthCheck(pc.Name, pc.BaseURL, nil)
        checker.RegisterProvider(healthCheck)
        loggerSvc.Logger.Debug().
            Str("provider", pc.Name).
            Str("base_url", pc.BaseURL).
            Msg("registered health check")
    }

    return &CheckerService{Checker: checker}, nil
}
```

### Example 2: Start Checker in serve.go

```go
// Source: Addition to cmd/cc-relay/serve.go runServe function

func runServe(_ *cobra.Command, _ []string) error {
    // ... existing container creation and config setup ...

    // Get server from DI container (lazy initialization of all dependencies)
    serverSvc, err := di.Invoke[*di.ServerService](container)
    if err != nil {
        log.Error().Err(err).Msg("failed to create server")
        return err
    }

    // Start health checker (after all DI services initialized)
    checkerSvc := di.MustInvoke[*di.CheckerService](container)
    checkerSvc.Checker.Start()

    // Run server with graceful shutdown
    return runWithGracefulShutdown(serverSvc.Server, container, cfg.Server.Listen)
}
```

### Example 3: Integration Test for Checker Lifecycle

```go
// Source: New test in cmd/cc-relay/di/providers_test.go

func TestChecker_StartsAndStopsWithContainer(t *testing.T) {
    // Create minimal config with health check enabled
    cfg := &config.Config{
        Providers: []config.ProviderConfig{
            {Name: "test", Type: "anthropic", Enabled: true, BaseURL: "http://test:8080"},
        },
        Health: health.Config{
            HealthCheck: health.CheckConfig{IntervalMS: 100}, // Fast for testing
            CircuitBreaker: health.CircuitBreakerConfig{},
        },
    }

    // Setup test container
    container := do.New()
    do.ProvideValue(container, &ConfigService{Config: cfg})
    do.ProvideValue(container, &LoggerService{Logger: &zerolog.Nop()})
    do.Provide(container, NewHealthTracker)
    do.Provide(container, NewChecker)

    // Get checker and verify provider registered
    checkerSvc := do.MustInvoke[*CheckerService](container)
    assert.NotNil(t, checkerSvc.Checker)

    // Start checker
    checkerSvc.Checker.Start()

    // Give it time to run at least one cycle
    time.Sleep(150 * time.Millisecond)

    // Shutdown via container (tests graceful shutdown)
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    err := container.ShutdownWithContext(ctx)
    assert.NoError(t, err)
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Manual lifecycle management | DI container with Shutdowner interface | Phase 04 | Automatic cleanup |
| Start in constructor | Start after full initialization | Best practice | Avoids race conditions |

**No deprecated patterns:** This phase uses current Go best practices.

## Open Questions

None. This is gap closure with clear implementation path.

## Sources

### Primary (HIGH confidence)
- `/home/omarluq/sandbox/go/cc-relay/internal/health/checker.go` - Verified Checker.Start(), RegisterProvider(), NewProviderHealthCheck()
- `/home/omarluq/sandbox/go/cc-relay/cmd/cc-relay/di/providers.go` - Verified CheckerService, NewChecker, Shutdown()
- `/home/omarluq/sandbox/go/cc-relay/cmd/cc-relay/serve.go` - Verified startup flow, runServe()
- `/home/omarluq/sandbox/go/cc-relay/.planning/v0.0.1-MILESTONE-AUDIT.md` - Gap specification

### Secondary (MEDIUM confidence)
- `/home/omarluq/sandbox/go/cc-relay/.planning/phases/04-circuit-breaker-health/04-03-PLAN.md` - Original Checker design
- `/home/omarluq/sandbox/go/cc-relay/.planning/phases/04-circuit-breaker-health/04-04-SUMMARY.md` - Handler integration context

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All components exist in codebase, verified by reading source
- Architecture: HIGH - Patterns already established in codebase
- Pitfalls: HIGH - Based on codebase analysis and existing test patterns

**Research date:** 2026-01-23
**Valid until:** 2026-02-23 (30 days - gap closure, no external dependencies)
