---
phase: 07-configuration-management
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - internal/config/watcher.go
  - internal/config/watcher_test.go
autonomous: true

must_haves:
  truths:
    - "Config watcher detects file changes"
    - "Multiple rapid saves result in single reload (debouncing)"
    - "Only Write/Create events trigger reload, not Chmod"
    - "Watcher can be stopped cleanly via context cancellation"
  artifacts:
    - path: "internal/config/watcher.go"
      provides: "File watcher with debounce"
      exports: ["Watcher", "NewWatcher", "ReloadCallback"]
      min_lines: 80
    - path: "internal/config/watcher_test.go"
      provides: "Watcher tests including debounce behavior"
      min_lines: 100
  key_links:
    - from: "internal/config/watcher.go"
      to: "github.com/fsnotify/fsnotify"
      via: "fsnotify.Watcher"
      pattern: "fsnotify\\.NewWatcher"
    - from: "internal/config/watcher.go"
      to: "internal/config/loader.go"
      via: "Load() call on reload"
      pattern: "Load\\(w\\.path\\)"
---

<objective>
Implement config file watcher with debouncing for hot-reload support.

Purpose: Enable automatic configuration reload when config file changes (CONF-05). The watcher monitors the config file and triggers reload callbacks after debouncing rapid file change events (common with editors that do atomic writes).

Output:
- watcher.go with Watcher type that monitors config file
- Debounce logic to handle rapid editor saves
- OnReload callback registration for config consumers
- Graceful shutdown via context cancellation
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-configuration-management/07-RESEARCH.md
@internal/config/loader.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement config file watcher with debounce</name>
  <files>internal/config/watcher.go</files>
  <action>
Create a config file watcher that monitors for changes and triggers reload callbacks.

**Create internal/config/watcher.go:**

```go
package config

import (
    "context"
    "fmt"
    "path/filepath"
    "sync"
    "time"

    "github.com/fsnotify/fsnotify"
    "github.com/rs/zerolog"
)

// ReloadCallback is called when config file changes and new config is loaded.
// Receives the newly loaded configuration. Return error to log reload failure.
type ReloadCallback func(newCfg *Config) error

// Watcher monitors a config file for changes and triggers reload callbacks.
// Uses debouncing to handle rapid editor saves and watches the parent directory
// to handle atomic file writes (common with editors like vim, vscode).
type Watcher struct {
    watcher   *fsnotify.Watcher
    path      string // absolute path to config file
    dir       string // parent directory being watched
    filename  string // base filename to filter events
    logger    *zerolog.Logger
    callbacks []ReloadCallback
    mu        sync.RWMutex
}

// NewWatcher creates a config file watcher for the given path.
// The watcher monitors the parent directory (not the file directly) to handle
// atomic file writes used by editors.
func NewWatcher(configPath string, logger *zerolog.Logger) (*Watcher, error) {
    fsw, err := fsnotify.NewWatcher()
    if err != nil {
        return nil, fmt.Errorf("failed to create file watcher: %w", err)
    }

    absPath, err := filepath.Abs(configPath)
    if err != nil {
        _ = fsw.Close()
        return nil, fmt.Errorf("failed to resolve config path: %w", err)
    }

    w := &Watcher{
        watcher:  fsw,
        path:     absPath,
        dir:      filepath.Dir(absPath),
        filename: filepath.Base(absPath),
        logger:   logger,
    }

    // Watch the directory, not the file (handles atomic writes from editors)
    if err := fsw.Add(w.dir); err != nil {
        _ = fsw.Close()
        return nil, fmt.Errorf("failed to watch config directory %s: %w", w.dir, err)
    }

    return w, nil
}

// OnReload registers a callback to be invoked when config file changes.
// Callbacks are invoked in registration order with the newly loaded config.
func (w *Watcher) OnReload(cb ReloadCallback) {
    w.mu.Lock()
    defer w.mu.Unlock()
    w.callbacks = append(w.callbacks, cb)
}

// Start begins watching for config file changes in a background goroutine.
// The watcher runs until the context is cancelled.
func (w *Watcher) Start(ctx context.Context) {
    go w.watchLoop(ctx)
}

// Close stops the watcher and releases resources.
func (w *Watcher) Close() error {
    return w.watcher.Close()
}

// Path returns the absolute path being watched.
func (w *Watcher) Path() string {
    return w.path
}

// watchLoop is the main event loop for the watcher.
func (w *Watcher) watchLoop(ctx context.Context) {
    var debounceTimer *time.Timer
    const debounceDelay = 100 * time.Millisecond

    for {
        select {
        case <-ctx.Done():
            w.stopDebounceTimer(debounceTimer)
            return

        case event, ok := <-w.watcher.Events:
            if !ok {
                return
            }
            debounceTimer = w.handleEvent(event, debounceTimer, debounceDelay)

        case err, ok := <-w.watcher.Errors:
            if !ok {
                return
            }
            w.logger.Error().Err(err).Msg("config watcher error")
        }
    }
}

// handleEvent processes a single fsnotify event.
func (w *Watcher) handleEvent(event fsnotify.Event, timer *time.Timer, delay time.Duration) *time.Timer {
    // Filter: only our config file
    if filepath.Base(event.Name) != w.filename {
        return timer
    }

    // Filter: only Write or Create events (ignore Chmod, Remove, Rename)
    if !event.Has(fsnotify.Write) && !event.Has(fsnotify.Create) {
        return timer
    }

    w.logger.Debug().
        Str("event", event.Op.String()).
        Str("file", event.Name).
        Msg("config file change detected")

    // Debounce: reset timer on each event
    w.stopDebounceTimer(timer)
    return time.AfterFunc(delay, w.triggerReload)
}

// stopDebounceTimer safely stops a timer if it exists.
func (w *Watcher) stopDebounceTimer(timer *time.Timer) {
    if timer != nil {
        timer.Stop()
    }
}

// triggerReload loads the config and invokes all callbacks.
func (w *Watcher) triggerReload() {
    cfg, err := Load(w.path)
    if err != nil {
        w.logger.Error().Err(err).Str("path", w.path).Msg("failed to reload config, keeping current")
        return
    }

    w.mu.RLock()
    callbacks := w.callbacks
    w.mu.RUnlock()

    for _, cb := range callbacks {
        if err := cb(cfg); err != nil {
            w.logger.Error().Err(err).Msg("config reload callback failed")
        }
    }

    w.logger.Info().Str("path", w.path).Msg("configuration reloaded successfully")
}
```

**Key design decisions:**
- Watch parent directory, not file directly (handles atomic writes from editors)
- Debounce with 100ms delay (editors may trigger multiple events per save)
- Filter to only Write/Create events (ignore Chmod from Spotlight/antivirus)
- Extract helper functions to meet funlen/gocognit limits
- RWMutex protects callbacks slice
  </action>
  <verify>
`go build ./internal/config/...` succeeds
`grep -c 'fsnotify' internal/config/watcher.go` shows imports
  </verify>
  <done>
Watcher type created with debounce, directory watching, event filtering
  </done>
</task>

<task type="auto">
  <name>Task 2: Add watcher tests</name>
  <files>internal/config/watcher_test.go</files>
  <action>
Create comprehensive tests for the config watcher.

**Create internal/config/watcher_test.go:**

```go
package config

import (
    "context"
    "os"
    "path/filepath"
    "sync/atomic"
    "testing"
    "time"

    "github.com/rs/zerolog"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestNewWatcher(t *testing.T) {
    tmpDir := t.TempDir()
    configPath := filepath.Join(tmpDir, "config.yaml")
    writeTestConfig(t, configPath)

    logger := zerolog.Nop()
    w, err := NewWatcher(configPath, &logger)
    require.NoError(t, err)
    defer w.Close()

    assert.Equal(t, configPath, w.Path())
}

func TestNewWatcher_InvalidPath(t *testing.T) {
    logger := zerolog.Nop()
    _, err := NewWatcher("/nonexistent/directory/config.yaml", &logger)
    require.Error(t, err)
    assert.Contains(t, err.Error(), "watch config directory")
}

func TestWatcher_OnReload(t *testing.T) {
    tmpDir := t.TempDir()
    configPath := filepath.Join(tmpDir, "config.yaml")
    writeTestConfig(t, configPath)

    logger := zerolog.Nop()
    w, err := NewWatcher(configPath, &logger)
    require.NoError(t, err)
    defer w.Close()

    var callCount atomic.Int32
    w.OnReload(func(cfg *Config) error {
        callCount.Add(1)
        return nil
    })

    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    w.Start(ctx)

    // Modify the file
    time.Sleep(50 * time.Millisecond)
    writeTestConfig(t, configPath)

    // Wait for debounce + processing
    time.Sleep(200 * time.Millisecond)
    assert.GreaterOrEqual(t, callCount.Load(), int32(1))
}

func TestWatcher_Debouncing(t *testing.T) {
    tmpDir := t.TempDir()
    configPath := filepath.Join(tmpDir, "config.yaml")
    writeTestConfig(t, configPath)

    logger := zerolog.Nop()
    w, err := NewWatcher(configPath, &logger)
    require.NoError(t, err)
    defer w.Close()

    var callCount atomic.Int32
    w.OnReload(func(cfg *Config) error {
        callCount.Add(1)
        return nil
    })

    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    w.Start(ctx)

    // Rapid writes (simulating editor atomic saves)
    time.Sleep(50 * time.Millisecond)
    for i := 0; i < 5; i++ {
        writeTestConfig(t, configPath)
        time.Sleep(20 * time.Millisecond) // Less than debounce delay
    }

    // Wait for debounce window to close
    time.Sleep(200 * time.Millisecond)

    // Should have debounced to 1 or 2 reloads (not 5)
    count := callCount.Load()
    assert.LessOrEqual(t, count, int32(2), "expected debouncing to reduce reload count")
    assert.GreaterOrEqual(t, count, int32(1), "expected at least one reload")
}

func TestWatcher_ContextCancellation(t *testing.T) {
    tmpDir := t.TempDir()
    configPath := filepath.Join(tmpDir, "config.yaml")
    writeTestConfig(t, configPath)

    logger := zerolog.Nop()
    w, err := NewWatcher(configPath, &logger)
    require.NoError(t, err)
    defer w.Close()

    var callCount atomic.Int32
    w.OnReload(func(cfg *Config) error {
        callCount.Add(1)
        return nil
    })

    ctx, cancel := context.WithCancel(context.Background())
    w.Start(ctx)

    // Cancel context
    cancel()
    time.Sleep(50 * time.Millisecond)

    // Writes after cancel should not trigger callback
    initial := callCount.Load()
    writeTestConfig(t, configPath)
    time.Sleep(200 * time.Millisecond)

    assert.Equal(t, initial, callCount.Load(), "callbacks should not fire after cancel")
}

func TestWatcher_IgnoresChmodEvents(t *testing.T) {
    tmpDir := t.TempDir()
    configPath := filepath.Join(tmpDir, "config.yaml")
    writeTestConfig(t, configPath)

    logger := zerolog.Nop()
    w, err := NewWatcher(configPath, &logger)
    require.NoError(t, err)
    defer w.Close()

    var callCount atomic.Int32
    w.OnReload(func(cfg *Config) error {
        callCount.Add(1)
        return nil
    })

    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    w.Start(ctx)

    time.Sleep(50 * time.Millisecond)

    // Only chmod the file (no write)
    err = os.Chmod(configPath, 0o644)
    require.NoError(t, err)

    time.Sleep(200 * time.Millisecond)
    assert.Equal(t, int32(0), callCount.Load(), "chmod should not trigger reload")
}

func TestWatcher_IgnoresOtherFiles(t *testing.T) {
    tmpDir := t.TempDir()
    configPath := filepath.Join(tmpDir, "config.yaml")
    otherPath := filepath.Join(tmpDir, "other.yaml")
    writeTestConfig(t, configPath)

    logger := zerolog.Nop()
    w, err := NewWatcher(configPath, &logger)
    require.NoError(t, err)
    defer w.Close()

    var callCount atomic.Int32
    w.OnReload(func(cfg *Config) error {
        callCount.Add(1)
        return nil
    })

    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    w.Start(ctx)

    time.Sleep(50 * time.Millisecond)

    // Write to a different file in same directory
    writeTestConfig(t, otherPath)

    time.Sleep(200 * time.Millisecond)
    assert.Equal(t, int32(0), callCount.Load(), "changes to other files should not trigger reload")
}

func TestWatcher_InvalidConfigNotReloaded(t *testing.T) {
    tmpDir := t.TempDir()
    configPath := filepath.Join(tmpDir, "config.yaml")
    writeTestConfig(t, configPath)

    logger := zerolog.Nop()
    w, err := NewWatcher(configPath, &logger)
    require.NoError(t, err)
    defer w.Close()

    var callCount atomic.Int32
    w.OnReload(func(cfg *Config) error {
        callCount.Add(1)
        return nil
    })

    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    w.Start(ctx)

    time.Sleep(50 * time.Millisecond)

    // Write invalid YAML
    err = os.WriteFile(configPath, []byte("invalid: [yaml"), 0o644)
    require.NoError(t, err)

    time.Sleep(200 * time.Millisecond)
    // Callback should NOT be called for invalid config
    assert.Equal(t, int32(0), callCount.Load(), "invalid config should not trigger callback")
}

func TestWatcher_MultipleCallbacks(t *testing.T) {
    tmpDir := t.TempDir()
    configPath := filepath.Join(tmpDir, "config.yaml")
    writeTestConfig(t, configPath)

    logger := zerolog.Nop()
    w, err := NewWatcher(configPath, &logger)
    require.NoError(t, err)
    defer w.Close()

    var count1, count2 atomic.Int32
    w.OnReload(func(cfg *Config) error {
        count1.Add(1)
        return nil
    })
    w.OnReload(func(cfg *Config) error {
        count2.Add(1)
        return nil
    })

    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    w.Start(ctx)

    time.Sleep(50 * time.Millisecond)
    writeTestConfig(t, configPath)
    time.Sleep(200 * time.Millisecond)

    assert.GreaterOrEqual(t, count1.Load(), int32(1))
    assert.GreaterOrEqual(t, count2.Load(), int32(1))
}

// writeTestConfig writes a minimal valid config to the given path.
func writeTestConfig(t *testing.T, path string) {
    t.Helper()
    content := `
server:
  listen: ":8787"

providers:
  - name: test
    type: anthropic
    enabled: true
    keys:
      - key: test-key

cache:
  mode: single
  ristretto:
    max_cost: 104857600
    num_counters: 1000000
`
    err := os.WriteFile(path, []byte(content), 0o644)
    require.NoError(t, err)
}
```

**Test coverage:**
- Basic watcher creation and path resolution
- Callback invocation on file change
- Debouncing (5 rapid writes -> 1-2 reloads)
- Context cancellation stops watcher
- Chmod events ignored
- Changes to other files in directory ignored
- Invalid config prevents callback invocation
- Multiple callbacks all invoked
  </action>
  <verify>
`go test ./internal/config/... -v -run TestWatcher` passes all tests
`go test ./internal/config/... -v -run TestNewWatcher` passes
  </verify>
  <done>
Watcher tests pass, covering debounce, event filtering, context cancellation
  </done>
</task>

</tasks>

<verification>
Run all checks to verify plan completion:

```bash
# Build succeeds
go build ./internal/config/...

# All watcher tests pass
go test ./internal/config/... -v -run "Watcher"

# Linters pass
task lint

# Full test suite passes
task test
```
</verification>

<success_criteria>
1. Watcher detects file changes and triggers OnReload callbacks
2. Debouncing reduces multiple rapid saves to single reload
3. Only Write/Create events trigger reload (not Chmod)
4. Changes to other files in same directory are ignored
5. Invalid config does not invoke callbacks
6. Context cancellation cleanly stops watcher
7. All tests pass, linters pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-configuration-management/07-03-SUMMARY.md`
</output>
