---
phase: 07-configuration-management
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - internal/config/loader.go
  - internal/config/loader_test.go
  - internal/config/validator.go
  - internal/config/validator_test.go
  - internal/config/errors.go
autonomous: true

must_haves:
  truths:
    - "YAML config file loads successfully"
    - "TOML config file loads successfully"
    - "Invalid config causes clear error message on startup"
    - "Unsupported file extension returns descriptive error"
  artifacts:
    - path: "internal/config/loader.go"
      provides: "Format detection and multi-format loading"
      contains: "toml.Unmarshal"
    - path: "internal/config/validator.go"
      provides: "Comprehensive configuration validation"
      exports: ["Validate", "ValidationError"]
    - path: "internal/config/errors.go"
      provides: "Validation error types"
      contains: "ValidationError"
  key_links:
    - from: "internal/config/loader.go"
      to: "internal/config/validator.go"
      via: "Validate() call after parsing"
      pattern: "cfg\\.Validate\\(\\)"
---

<objective>
Implement multi-format config loading with format detection and comprehensive validation.

Purpose: Enable YAML and TOML config support (CONF-01, CONF-02) with clear error messages on invalid configuration (CONF-04, CONF-06). This plan extends the existing loader.go to detect file format from extension and adds comprehensive validation.

Output:
- loader.go detects format from .yaml/.yml/.toml extension
- validator.go provides comprehensive Validate() method
- errors.go provides ValidationError type with clear messages
- All existing tests pass, new tests cover TOML loading
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-configuration-management/07-RESEARCH.md
@internal/config/loader.go
@internal/config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add format detection to loader.go</name>
  <files>internal/config/loader.go, internal/config/loader_test.go</files>
  <action>
Update loader.go to detect config format from file extension and parse accordingly.

**Update internal/config/loader.go:**

```go
package config

import (
    "fmt"
    "io"
    "os"
    "path/filepath"
    "strings"

    toml "github.com/pelletier/go-toml/v2"
    "gopkg.in/yaml.v3"
)

// Load reads and parses a configuration file from the given path.
// Format is detected from file extension: .yaml, .yml for YAML, .toml for TOML.
// Environment variables in ${VAR_NAME} syntax are expanded before parsing.
// Returns error if file cannot be read, has unsupported extension, or fails validation.
func Load(path string) (*Config, error) {
    content, err := os.ReadFile(path)
    if err != nil {
        return nil, fmt.Errorf("failed to read config file %s: %w", path, err)
    }

    // Expand environment variables before parsing
    expanded := os.ExpandEnv(string(content))

    // Detect format from extension
    ext := strings.ToLower(filepath.Ext(path))
    cfg, err := parseConfig([]byte(expanded), ext)
    if err != nil {
        return nil, err
    }

    // Validate configuration
    if err := cfg.Validate(); err != nil {
        return nil, fmt.Errorf("invalid configuration: %w", err)
    }

    return cfg, nil
}

// parseConfig parses config content based on format extension.
func parseConfig(content []byte, ext string) (*Config, error) {
    var cfg Config

    switch ext {
    case ".toml":
        if err := toml.Unmarshal(content, &cfg); err != nil {
            return nil, fmt.Errorf("failed to parse TOML config: %w", err)
        }
    case ".yaml", ".yml":
        if err := yaml.Unmarshal(content, &cfg); err != nil {
            return nil, fmt.Errorf("failed to parse YAML config: %w", err)
        }
    default:
        return nil, fmt.Errorf("unsupported config format %q (use .yaml, .yml, or .toml)", ext)
    }

    return &cfg, nil
}

// LoadFromReader reads and parses YAML configuration from an io.Reader.
// Environment variables in ${VAR_NAME} syntax are expanded before parsing.
// Deprecated: Use Load() with file path for format detection.
func LoadFromReader(r io.Reader) (*Config, error) {
    content, err := io.ReadAll(r)
    if err != nil {
        return nil, fmt.Errorf("failed to read config: %w", err)
    }

    expanded := os.ExpandEnv(string(content))

    var cfg Config
    if err := yaml.Unmarshal([]byte(expanded), &cfg); err != nil {
        return nil, fmt.Errorf("failed to parse config YAML: %w", err)
    }

    return &cfg, nil
}
```

**Add tests in internal/config/loader_test.go:**

```go
func TestLoad_TOMLFormat(t *testing.T) {
    // Create temp TOML file
    content := `
[server]
listen = ":8787"

[[providers]]
name = "anthropic"
type = "anthropic"
enabled = true

[[providers.keys]]
key = "test-key"

[cache]
mode = "single"
[cache.ristretto]
max_cost = 104857600
num_counters = 1000000
`
    tmpFile, err := os.CreateTemp("", "config-*.toml")
    require.NoError(t, err)
    defer os.Remove(tmpFile.Name())

    _, err = tmpFile.WriteString(content)
    require.NoError(t, err)
    tmpFile.Close()

    cfg, err := Load(tmpFile.Name())
    require.NoError(t, err)
    assert.Equal(t, ":8787", cfg.Server.Listen)
    assert.Len(t, cfg.Providers, 1)
    assert.Equal(t, "anthropic", cfg.Providers[0].Name)
}

func TestLoad_UnsupportedFormat(t *testing.T) {
    tmpFile, err := os.CreateTemp("", "config-*.json")
    require.NoError(t, err)
    defer os.Remove(tmpFile.Name())

    _, err = tmpFile.WriteString(`{"server": {"listen": ":8787"}}`)
    require.NoError(t, err)
    tmpFile.Close()

    _, err = Load(tmpFile.Name())
    require.Error(t, err)
    assert.Contains(t, err.Error(), "unsupported config format")
    assert.Contains(t, err.Error(), ".json")
}

func TestLoad_EnvExpansionInTOML(t *testing.T) {
    t.Setenv("TEST_API_KEY", "expanded-key-value")

    content := `
[server]
listen = ":8787"

[[providers]]
name = "test"
type = "anthropic"
enabled = true

[[providers.keys]]
key = "${TEST_API_KEY}"

[cache]
mode = "single"
[cache.ristretto]
max_cost = 104857600
num_counters = 1000000
`
    tmpFile, err := os.CreateTemp("", "config-*.toml")
    require.NoError(t, err)
    defer os.Remove(tmpFile.Name())

    _, err = tmpFile.WriteString(content)
    require.NoError(t, err)
    tmpFile.Close()

    cfg, err := Load(tmpFile.Name())
    require.NoError(t, err)
    assert.Equal(t, "expanded-key-value", cfg.Providers[0].Keys[0].Key)
}
```

Keep parseConfig as helper to meet funlen limit (80 lines).
  </action>
  <verify>
`go build ./internal/config/...` succeeds
`go test ./internal/config/... -run TestLoad_TOMLFormat` passes
`go test ./internal/config/... -run TestLoad_UnsupportedFormat` passes
`go test ./internal/config/... -run TestLoad_EnvExpansionInTOML` passes
  </verify>
  <done>
loader.go detects format from extension, parses YAML and TOML, rejects unsupported formats
  </done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive validator</name>
  <files>internal/config/validator.go, internal/config/validator_test.go, internal/config/errors.go</files>
  <action>
Create comprehensive configuration validation with clear error messages.

**Create internal/config/errors.go:**

```go
package config

import (
    "fmt"
    "strings"
)

// ValidationError contains all validation failures.
// Implements error interface with detailed multi-error reporting.
type ValidationError struct {
    Errors []error
}

// Error returns a formatted string of all validation errors.
func (e *ValidationError) Error() string {
    if len(e.Errors) == 0 {
        return "no validation errors"
    }
    if len(e.Errors) == 1 {
        return e.Errors[0].Error()
    }

    var b strings.Builder
    b.WriteString(fmt.Sprintf("%d validation errors:\n", len(e.Errors)))
    for _, err := range e.Errors {
        b.WriteString("  - ")
        b.WriteString(err.Error())
        b.WriteString("\n")
    }
    return b.String()
}

// Unwrap returns the first error for errors.Is/As compatibility.
func (e *ValidationError) Unwrap() error {
    if len(e.Errors) > 0 {
        return e.Errors[0]
    }
    return nil
}
```

**Create internal/config/validator.go:**

```go
package config

import (
    "errors"
    "fmt"
    "net"
    "strings"
)

// Validate performs comprehensive validation of the configuration.
// Returns ValidationError with all validation failures for clear error messages.
func (c *Config) Validate() error {
    var errs []error

    errs = append(errs, c.validateServer()...)
    errs = append(errs, c.validateProviders()...)
    errs = append(errs, c.validateRouting()...)
    errs = append(errs, c.validateLogging()...)
    errs = append(errs, c.validateCache()...)

    if len(errs) > 0 {
        return &ValidationError{Errors: errs}
    }
    return nil
}

// validateServer validates server configuration.
func (c *Config) validateServer() []error {
    var errs []error

    if c.Server.Listen == "" {
        errs = append(errs, errors.New("server.listen is required"))
    } else if _, _, err := net.SplitHostPort(c.Server.Listen); err != nil {
        errs = append(errs, fmt.Errorf("server.listen %q is not valid host:port: %w", c.Server.Listen, err))
    }

    if c.Server.TimeoutMS < 0 {
        errs = append(errs, errors.New("server.timeout_ms must be >= 0"))
    }

    if c.Server.MaxConcurrent < 0 {
        errs = append(errs, errors.New("server.max_concurrent must be >= 0"))
    }

    return errs
}

// validateProviders validates all provider configurations.
func (c *Config) validateProviders() []error {
    var errs []error

    if len(c.Providers) == 0 {
        errs = append(errs, errors.New("at least one provider is required"))
        return errs
    }

    providerNames := make(map[string]bool)
    for i, p := range c.Providers {
        prefix := fmt.Sprintf("providers[%d]", i)
        errs = append(errs, validateProvider(&p, prefix, providerNames)...)
    }

    return errs
}

// validateProvider validates a single provider configuration.
func validateProvider(p *ProviderConfig, prefix string, names map[string]bool) []error {
    var errs []error

    if p.Name == "" {
        errs = append(errs, fmt.Errorf("%s.name is required", prefix))
    } else if names[p.Name] {
        errs = append(errs, fmt.Errorf("%s.name %q is duplicate", prefix, p.Name))
    } else {
        names[p.Name] = true
    }

    if p.Type == "" {
        errs = append(errs, fmt.Errorf("%s.type is required", prefix))
    } else if !isValidProviderType(p.Type) {
        errs = append(errs, fmt.Errorf("%s.type %q is invalid (use: anthropic, zai, ollama, bedrock, vertex, azure)", prefix, p.Type))
    }

    if p.Enabled && len(p.Keys) == 0 {
        errs = append(errs, fmt.Errorf("%s: enabled provider must have at least one key", prefix))
    }

    for j, k := range p.Keys {
        if err := k.Validate(); err != nil {
            errs = append(errs, fmt.Errorf("%s.keys[%d]: %w", prefix, j, err))
        }
    }

    if err := p.ValidateCloudConfig(); err != nil {
        errs = append(errs, fmt.Errorf("%s: %w", prefix, err))
    }

    return errs
}

// validateRouting validates routing configuration.
func (c *Config) validateRouting() []error {
    var errs []error

    if c.Routing.Strategy != "" && !isValidRoutingStrategy(c.Routing.Strategy) {
        errs = append(errs, fmt.Errorf("routing.strategy %q is invalid (use: round_robin, weighted_round_robin, shuffle, failover, model_based)", c.Routing.Strategy))
    }

    if c.Routing.FailoverTimeout < 0 {
        errs = append(errs, errors.New("routing.failover_timeout must be >= 0"))
    }

    return errs
}

// validateLogging validates logging configuration.
func (c *Config) validateLogging() []error {
    var errs []error

    if c.Logging.Level != "" && !isValidLogLevel(c.Logging.Level) {
        errs = append(errs, fmt.Errorf("logging.level %q is invalid (use: debug, info, warn, error)", c.Logging.Level))
    }

    if c.Logging.Format != "" && !isValidLogFormat(c.Logging.Format) {
        errs = append(errs, fmt.Errorf("logging.format %q is invalid (use: json, console)", c.Logging.Format))
    }

    return errs
}

// validateCache validates cache configuration by delegating to cache.Config.Validate().
func (c *Config) validateCache() []error {
    if err := c.Cache.Validate(); err != nil {
        return []error{fmt.Errorf("cache: %w", err)}
    }
    return nil
}

// Helper functions for validation

func isValidProviderType(t string) bool {
    switch t {
    case "anthropic", "zai", "ollama", "bedrock", "vertex", "azure":
        return true
    }
    return false
}

func isValidRoutingStrategy(s string) bool {
    switch s {
    case "round_robin", "weighted_round_robin", "shuffle", "failover", "model_based":
        return true
    }
    return false
}

func isValidLogLevel(l string) bool {
    switch strings.ToLower(l) {
    case "debug", "info", "warn", "error":
        return true
    }
    return false
}

func isValidLogFormat(f string) bool {
    switch strings.ToLower(f) {
    case "json", "console":
        return true
    }
    return false
}
```

**Create internal/config/validator_test.go:**

```go
package config

import (
    "testing"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"

    "github.com/omarluq/cc-relay/internal/cache"
)

func TestConfig_Validate_MinimalValid(t *testing.T) {
    cfg := &Config{
        Server: ServerConfig{Listen: ":8787"},
        Providers: []ProviderConfig{
            {Name: "test", Type: "anthropic", Enabled: true, Keys: []KeyConfig{{Key: "k"}}},
        },
        Cache: cache.Config{Mode: cache.ModeSingle, Ristretto: cache.RistrettoConfig{MaxCost: 100, NumCounters: 1000}},
    }
    err := cfg.Validate()
    assert.NoError(t, err)
}

func TestConfig_Validate_MissingServerListen(t *testing.T) {
    cfg := &Config{
        Providers: []ProviderConfig{
            {Name: "test", Type: "anthropic", Enabled: true, Keys: []KeyConfig{{Key: "k"}}},
        },
        Cache: cache.Config{Mode: cache.ModeSingle, Ristretto: cache.RistrettoConfig{MaxCost: 100, NumCounters: 1000}},
    }
    err := cfg.Validate()
    require.Error(t, err)
    assert.Contains(t, err.Error(), "server.listen is required")
}

func TestConfig_Validate_InvalidServerListen(t *testing.T) {
    cfg := &Config{
        Server: ServerConfig{Listen: "invalid"},
        Providers: []ProviderConfig{
            {Name: "test", Type: "anthropic", Enabled: true, Keys: []KeyConfig{{Key: "k"}}},
        },
        Cache: cache.Config{Mode: cache.ModeSingle, Ristretto: cache.RistrettoConfig{MaxCost: 100, NumCounters: 1000}},
    }
    err := cfg.Validate()
    require.Error(t, err)
    assert.Contains(t, err.Error(), "not valid host:port")
}

func TestConfig_Validate_NoProviders(t *testing.T) {
    cfg := &Config{
        Server: ServerConfig{Listen: ":8787"},
        Cache:  cache.Config{Mode: cache.ModeSingle, Ristretto: cache.RistrettoConfig{MaxCost: 100, NumCounters: 1000}},
    }
    err := cfg.Validate()
    require.Error(t, err)
    assert.Contains(t, err.Error(), "at least one provider is required")
}

func TestConfig_Validate_DuplicateProviderName(t *testing.T) {
    cfg := &Config{
        Server: ServerConfig{Listen: ":8787"},
        Providers: []ProviderConfig{
            {Name: "dupe", Type: "anthropic", Enabled: true, Keys: []KeyConfig{{Key: "k1"}}},
            {Name: "dupe", Type: "zai", Enabled: true, Keys: []KeyConfig{{Key: "k2"}}},
        },
        Cache: cache.Config{Mode: cache.ModeSingle, Ristretto: cache.RistrettoConfig{MaxCost: 100, NumCounters: 1000}},
    }
    err := cfg.Validate()
    require.Error(t, err)
    assert.Contains(t, err.Error(), "duplicate")
}

func TestConfig_Validate_InvalidProviderType(t *testing.T) {
    cfg := &Config{
        Server: ServerConfig{Listen: ":8787"},
        Providers: []ProviderConfig{
            {Name: "test", Type: "invalid_type", Enabled: true, Keys: []KeyConfig{{Key: "k"}}},
        },
        Cache: cache.Config{Mode: cache.ModeSingle, Ristretto: cache.RistrettoConfig{MaxCost: 100, NumCounters: 1000}},
    }
    err := cfg.Validate()
    require.Error(t, err)
    assert.Contains(t, err.Error(), "invalid")
    assert.Contains(t, err.Error(), "anthropic, zai, ollama, bedrock, vertex, azure")
}

func TestConfig_Validate_EnabledProviderNoKeys(t *testing.T) {
    cfg := &Config{
        Server: ServerConfig{Listen: ":8787"},
        Providers: []ProviderConfig{
            {Name: "test", Type: "anthropic", Enabled: true, Keys: []KeyConfig{}},
        },
        Cache: cache.Config{Mode: cache.ModeSingle, Ristretto: cache.RistrettoConfig{MaxCost: 100, NumCounters: 1000}},
    }
    err := cfg.Validate()
    require.Error(t, err)
    assert.Contains(t, err.Error(), "enabled provider must have at least one key")
}

func TestConfig_Validate_InvalidRoutingStrategy(t *testing.T) {
    cfg := &Config{
        Server:  ServerConfig{Listen: ":8787"},
        Routing: RoutingConfig{Strategy: "invalid_strategy"},
        Providers: []ProviderConfig{
            {Name: "test", Type: "anthropic", Enabled: true, Keys: []KeyConfig{{Key: "k"}}},
        },
        Cache: cache.Config{Mode: cache.ModeSingle, Ristretto: cache.RistrettoConfig{MaxCost: 100, NumCounters: 1000}},
    }
    err := cfg.Validate()
    require.Error(t, err)
    assert.Contains(t, err.Error(), "routing.strategy")
    assert.Contains(t, err.Error(), "invalid")
}

func TestConfig_Validate_InvalidLogLevel(t *testing.T) {
    cfg := &Config{
        Server:  ServerConfig{Listen: ":8787"},
        Logging: LoggingConfig{Level: "verbose"},
        Providers: []ProviderConfig{
            {Name: "test", Type: "anthropic", Enabled: true, Keys: []KeyConfig{{Key: "k"}}},
        },
        Cache: cache.Config{Mode: cache.ModeSingle, Ristretto: cache.RistrettoConfig{MaxCost: 100, NumCounters: 1000}},
    }
    err := cfg.Validate()
    require.Error(t, err)
    assert.Contains(t, err.Error(), "logging.level")
}

func TestConfig_Validate_MultipleErrors(t *testing.T) {
    cfg := &Config{
        // Missing server.listen
        Routing: RoutingConfig{Strategy: "bad"},
        Logging: LoggingConfig{Level: "bad"},
        // No providers
    }
    err := cfg.Validate()
    require.Error(t, err)

    validationErr, ok := err.(*ValidationError)
    require.True(t, ok)
    assert.GreaterOrEqual(t, len(validationErr.Errors), 3)
}

func TestValidationError_Error(t *testing.T) {
    ve := &ValidationError{
        Errors: []error{
            assert.AnError,
        },
    }
    assert.Contains(t, ve.Error(), assert.AnError.Error())

    ve2 := &ValidationError{
        Errors: []error{
            assert.AnError,
            assert.AnError,
        },
    }
    assert.Contains(t, ve2.Error(), "2 validation errors")
}
```

Validation helper functions are small and meet gocyclo/gocognit limits.
  </action>
  <verify>
`go build ./internal/config/...` succeeds
`go test ./internal/config/... -run TestConfig_Validate` passes all tests
`task lint` passes
  </verify>
  <done>
Comprehensive validation with clear error messages, all tests pass, linters pass
  </done>
</task>

</tasks>

<verification>
Run all checks to verify plan completion:

```bash
# Build succeeds
go build ./internal/config/...

# All loader tests pass (including new TOML tests)
go test ./internal/config/... -v -run "TestLoad"

# All validation tests pass
go test ./internal/config/... -v -run "TestConfig_Validate"

# Linters pass
task lint

# Full test suite passes
task test
```
</verification>

<success_criteria>
1. Load() detects format from .yaml/.yml/.toml extensions
2. TOML config files parse correctly with environment variable expansion
3. Unsupported extensions return clear error message
4. Validation catches missing required fields (server.listen, provider name/type)
5. Validation catches invalid values (bad provider type, bad routing strategy)
6. ValidationError reports all errors, not just the first one
7. All tests pass, linters pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-configuration-management/07-02-SUMMARY.md`
</output>
