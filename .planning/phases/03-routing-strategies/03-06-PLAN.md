---
phase: 03-routing-strategies
plan: 06
type: execute
wave: 4
depends_on: ["03-01", "03-02", "03-03", "03-04", "03-05"]
files_modified:
  - cmd/cc-relay/di/providers.go
  - cmd/cc-relay/di/container_test.go
  - internal/proxy/handler.go
  - internal/proxy/handler_test.go
autonomous: true

must_haves:
  truths:
    - "RouterService is registered in DI container"
    - "Proxy handler uses ProviderRouter for provider selection"
    - "Debug headers added when routing.debug is enabled"
    - "Strategy name logged with each request"
  artifacts:
    - path: "cmd/cc-relay/di/providers.go"
      provides: "RouterService DI registration"
      contains: "type RouterService struct"
    - path: "internal/proxy/handler.go"
      provides: "Handler integration with ProviderRouter"
      contains: "ProviderRouter"
  key_links:
    - from: "cmd/cc-relay/di/providers.go"
      to: "internal/router/router.go"
      via: "RouterService wraps ProviderRouter"
      pattern: "router\\.ProviderRouter"
    - from: "internal/proxy/handler.go"
      to: "internal/router/router.go"
      via: "Handler.router field"
      pattern: "router\\.ProviderRouter"
---

<objective>
Integrate routing strategies with DI container and proxy handler

Purpose: Wire the routing strategies into the application by registering RouterService in the DI container and updating the proxy handler to use ProviderRouter for provider selection. Add debug headers when enabled.

Output:
- RouterService registered in DI container
- Handler updated to accept and use ProviderRouter
- Debug headers (X-CC-Relay-Strategy, X-CC-Relay-Provider) added conditionally
- Integration tests verifying wiring
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-routing-strategies/03-RESEARCH.md
@.planning/phases/03-routing-strategies/03-CONTEXT.md
@.planning/phases/03-routing-strategies/03-01-SUMMARY.md
@.planning/phases/03-routing-strategies/03-05-SUMMARY.md

# Integration points
@cmd/cc-relay/di/providers.go
@internal/proxy/handler.go
@internal/config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RouterService to DI container</name>
  <files>cmd/cc-relay/di/providers.go, cmd/cc-relay/di/container_test.go</files>
  <action>
Update cmd/cc-relay/di/providers.go:

1. Add RouterService wrapper type:
   ```go
   // RouterService wraps the provider router for DI.
   type RouterService struct {
       Router router.ProviderRouter
   }
   ```

2. Add import for internal/router package

3. Add NewRouter provider function:
   ```go
   // NewRouter creates the provider router based on configuration.
   func NewRouter(i do.Injector) (*RouterService, error) {
       cfgSvc := do.MustInvoke[*ConfigService](i)
       routingCfg := cfgSvc.Config.Routing

       // Get timeout with default fallback
       timeout := routingCfg.GetFailoverTimeoutOption().OrElse(5 * time.Second)

       r, err := router.NewRouter(routingCfg.GetEffectiveStrategy(), timeout)
       if err != nil {
           return nil, fmt.Errorf("failed to create router: %w", err)
       }

       return &RouterService{Router: r}, nil
   }
   ```

4. Update RegisterSingletons to include router:
   ```go
   func RegisterSingletons(i do.Injector) {
       do.Provide(i, NewConfig)
       do.Provide(i, NewCache)
       do.Provide(i, NewProviderMap)
       do.Provide(i, NewKeyPool)
       do.Provide(i, NewRouter)  // ADD THIS
       do.Provide(i, NewProxyHandler)
       do.Provide(i, NewHTTPServer)
   }
   ```

Update cmd/cc-relay/di/container_test.go:
- Test RouterService is created with default strategy (failover)
- Test RouterService respects configured strategy
- Test dependency order (Router depends on Config)
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go build ./cmd/cc-relay/...
cd /home/omarluq/sandbox/go/cc-relay && go test ./cmd/cc-relay/di/... -v -run TestRouter
```
  </verify>
  <done>
- RouterService type defined
- NewRouter provider function creates router from config
- RegisterSingletons includes router registration
- DI tests verify router creation and dependency order
  </done>
</task>

<task type="auto">
  <name>Task 2: Update proxy handler to use ProviderRouter</name>
  <files>internal/proxy/handler.go, internal/proxy/handler_test.go</files>
  <action>
Update internal/proxy/handler.go:

1. Add import for internal/router package

2. Add router field to Handler struct:
   ```go
   type Handler struct {
       provider     providers.Provider   // Current provider (selected by router or static)
       providers    []router.ProviderInfo // All available providers for routing
       router       router.ProviderRouter // Provider router (nil for single-provider mode)
       proxy        *httputil.ReverseProxy
       keyPool      *keypool.KeyPool
       apiKey       string
       debugOpts    config.DebugOptions
       routingDebug bool  // Enable X-CC-Relay-* headers
   }
   ```

3. Update NewHandler to accept providers and router:
   ```go
   // NewHandler creates a new proxy handler.
   // If router is provided, it will be used for provider selection.
   // If router is nil, provider is used directly (single provider mode).
   func NewHandler(
       provider providers.Provider,
       providers []router.ProviderInfo,
       providerRouter router.ProviderRouter,
       apiKey string,
       pool *keypool.KeyPool,
       debugOpts config.DebugOptions,
       routingDebug bool,
   ) (*Handler, error) {
       // ... existing URL parsing ...

       h := &Handler{
           provider:     provider,
           providers:    providers,
           router:       providerRouter,
           apiKey:       apiKey,
           keyPool:      pool,
           debugOpts:    debugOpts,
           routingDebug: routingDebug,
       }
       // ... rest of implementation
   }
   ```

4. Add selectProvider method:
   ```go
   // selectProvider chooses a provider using the router or returns the static provider.
   func (h *Handler) selectProvider(ctx context.Context) (router.ProviderInfo, error) {
       if h.router == nil || len(h.providers) == 0 {
           // Single provider mode
           return router.ProviderInfo{
               Provider:  h.provider,
               IsHealthy: func() bool { return true },
           }, nil
       }
       return h.router.Select(ctx, h.providers)
   }
   ```

5. Add debug headers in ServeHTTP (after provider selection):
   ```go
   // In ServeHTTP, after selecting provider:
   if h.routingDebug {
       w.Header().Set("X-CC-Relay-Strategy", h.router.Name())
       w.Header().Set("X-CC-Relay-Provider", selectedProvider.Provider.Name())
   }
   ```

6. Update ServeHTTP to use selectProvider and log strategy:
   - Call selectProvider at start of request
   - Use selected provider instead of h.provider
   - Log strategy name with zerolog

Update internal/proxy/handler_test.go:
- Test single provider mode (router=nil) uses static provider
- Test multi-provider mode uses router for selection
- Test debug headers NOT added when routingDebug=false
- Test debug headers added when routingDebug=true
- Test strategy name logged
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go build ./internal/proxy/...
cd /home/omarluq/sandbox/go/cc-relay && go test ./internal/proxy/... -v -run TestHandler
cd /home/omarluq/sandbox/go/cc-relay && go test ./internal/proxy/... -v -run TestDebugHeaders
```
  </verify>
  <done>
- Handler has router and providers fields
- selectProvider method chooses provider via router
- Debug headers added when routingDebug=true
- Single provider mode preserved for backwards compatibility
- Strategy name logged with requests
- Tests verify routing integration and debug headers
  </done>
</task>

<task type="auto">
  <name>Task 3: Update DI NewProxyHandler to wire router</name>
  <files>cmd/cc-relay/di/providers.go</files>
  <action>
Update NewProxyHandler in cmd/cc-relay/di/providers.go:

1. Inject RouterService:
   ```go
   func NewProxyHandler(i do.Injector) (*HandlerService, error) {
       cfgSvc := do.MustInvoke[*ConfigService](i)
       poolSvc := do.MustInvoke[*KeyPoolService](i)
       provMapSvc := do.MustInvoke[*ProviderMapService](i)
       routerSvc := do.MustInvoke[*RouterService](i)  // ADD THIS

       // ... existing code ...
   }
   ```

2. Build ProviderInfo list from ProviderMapService:
   ```go
   // Build provider info list for router
   var providerInfos []router.ProviderInfo
   for name, prov := range provMapSvc.Providers {
       // Find config for this provider to get weight/priority
       var weight, priority int
       for _, pc := range cfgSvc.Config.Providers {
           if pc.Name == name {
               // Use first key's weight/priority as provider-level default
               if len(pc.Keys) > 0 {
                   weight = pc.Keys[0].Weight
                   priority = pc.Keys[0].Priority
               }
               break
           }
       }
       providerInfos = append(providerInfos, router.ProviderInfo{
           Provider:  prov,
           Weight:    weight,
           Priority:  priority,
           IsHealthy: func() bool { return true }, // Stub until Phase 4
       })
   }
   ```

3. Update proxy.NewHandler call:
   ```go
   handler, err := proxy.NewHandler(
       provMapSvc.PrimaryProvider,
       providerInfos,
       routerSvc.Router,
       provMapSvc.PrimaryKey,
       poolSvc.Pool,
       cfgSvc.Config.Logging.DebugOptions,
       cfgSvc.Config.Routing.IsDebugEnabled(),
   )
   ```
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go build ./cmd/cc-relay/...
cd /home/omarluq/sandbox/go/cc-relay && go test ./cmd/cc-relay/di/... -v
```
  </verify>
  <done>
- NewProxyHandler injects RouterService
- ProviderInfo list built from config and providers
- Handler wired with router and provider list
- Routing debug flag passed from config
- All DI wiring complete
  </done>
</task>

</tasks>

<verification>
```bash
# All packages build
cd /home/omarluq/sandbox/go/cc-relay && go build ./...

# All tests pass
cd /home/omarluq/sandbox/go/cc-relay && go test ./... -v

# Linters pass
cd /home/omarluq/sandbox/go/cc-relay && task lint

# Full CI passes
cd /home/omarluq/sandbox/go/cc-relay && task ci
```
</verification>

<success_criteria>
- RouterService registered in DI container
- Proxy handler uses ProviderRouter for selection
- Debug headers added when routing.debug=true
- Strategy name logged with requests
- Single-provider mode preserved (router=nil)
- All tests pass
- Full CI passes
- Linters pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-routing-strategies/03-06-SUMMARY.md`
</output>
