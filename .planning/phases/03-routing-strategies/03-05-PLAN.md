---
phase: 03-routing-strategies
plan: 05
type: execute
wave: 3
depends_on: ["03-01", "03-04"]
files_modified:
  - internal/router/failover.go
  - internal/router/failover_test.go
  - internal/router/router.go
autonomous: true

must_haves:
  truths:
    - "Failover tries primary provider first based on priority"
    - "On trigger condition, starts parallel retry with timeout"
    - "First successful response wins and cancels other attempts"
    - "After recovery, priority order naturally resumes"
    - "Configurable timeout defaults to 5 seconds"
  artifacts:
    - path: "internal/router/failover.go"
      provides: "FailoverRouter with parallel retry"
      exports: ["FailoverRouter", "NewFailoverRouter", "RoutingResult"]
      min_lines: 100
  key_links:
    - from: "internal/router/failover.go"
      to: "internal/router/triggers.go"
      via: "uses FailoverTrigger interface"
      pattern: "FailoverTrigger"
    - from: "internal/router/failover.go"
      to: "context"
      via: "context.WithTimeout for parallel retry"
      pattern: "context\\.WithTimeout"
---

<objective>
Implement FailoverRouter with smart parallel retry

Purpose: Provide reliability-focused routing where a primary provider is tried first, and on failure (per trigger conditions), parallel retry begins with both primary and fallbacks competing - first success wins. This is the default strategy per CONTEXT.md.

Output:
- internal/router/failover.go with parallel retry implementation
- RoutingResult type for parallel race results
- Unit tests including parallel race scenarios
- NewRouter factory updated for failover
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-routing-strategies/03-RESEARCH.md
@.planning/phases/03-routing-strategies/03-CONTEXT.md
@.planning/phases/03-routing-strategies/03-01-SUMMARY.md
@.planning/phases/03-routing-strategies/03-04-SUMMARY.md

# Pattern references
@internal/router/router.go
@internal/router/triggers.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement FailoverRouter with parallel retry</name>
  <files>internal/router/failover.go, internal/router/failover_test.go</files>
  <action>
Create internal/router/failover.go:

1. RoutingResult type for parallel race:
   ```go
   // RoutingResult contains the result of a routing attempt.
   type RoutingResult struct {
       Provider ProviderInfo
       Err      error
   }
   ```

2. FailoverRouter struct:
   ```go
   type FailoverRouter struct {
       triggers []FailoverTrigger
       timeout  time.Duration
   }
   ```

3. NewFailoverRouter constructor:
   ```go
   // NewFailoverRouter creates a failover router with the given timeout.
   // If timeout is 0, defaults to 5 seconds.
   // If triggers is empty, uses DefaultTriggers().
   func NewFailoverRouter(timeout time.Duration, triggers ...FailoverTrigger) *FailoverRouter {
       if timeout == 0 {
           timeout = 5 * time.Second
       }
       if len(triggers) == 0 {
           triggers = DefaultTriggers()
       }
       return &FailoverRouter{
           triggers: triggers,
           timeout:  timeout,
       }
   }
   ```

4. Select method - simple selection by priority:
   ```go
   // Select returns the highest priority healthy provider.
   // For retry with parallel racing, use SelectWithRetry instead.
   func (r *FailoverRouter) Select(ctx context.Context, providers []ProviderInfo) (ProviderInfo, error) {
       if len(providers) == 0 {
           return ProviderInfo{}, ErrNoProviders
       }

       healthy := FilterHealthy(providers)
       if len(healthy) == 0 {
           return ProviderInfo{}, ErrAllProvidersUnhealthy
       }

       // Sort by priority descending, return highest
       sorted := sortByPriority(healthy)
       return sorted[0], nil
   }
   ```

5. sortByPriority helper using lo.SortStable:
   ```go
   func sortByPriority(providers []ProviderInfo) []ProviderInfo {
       // Make a copy to avoid mutating input
       sorted := make([]ProviderInfo, len(providers))
       copy(sorted, providers)
       slices.SortStableFunc(sorted, func(a, b ProviderInfo) int {
           return b.Priority - a.Priority // Descending
       })
       return sorted
   }
   ```

6. SelectWithRetry for smart parallel retry:
   ```go
   // SelectWithRetry implements smart parallel retry:
   // 1. Try primary (highest priority healthy) provider
   // 2. If fails with trigger condition, start parallel race
   // 3. All providers race - first success wins
   // 4. Cancel others on success or timeout
   //
   // tryProvider is called to actually attempt the request.
   // Returns the winning provider or the last error.
   func (r *FailoverRouter) SelectWithRetry(
       ctx context.Context,
       providers []ProviderInfo,
       tryProvider func(context.Context, ProviderInfo) (statusCode int, err error),
   ) (ProviderInfo, error) {
       if len(providers) == 0 {
           return ProviderInfo{}, ErrNoProviders
       }

       healthy := FilterHealthy(providers)
       if len(healthy) == 0 {
           return ProviderInfo{}, ErrAllProvidersUnhealthy
       }

       sorted := sortByPriority(healthy)

       // Simple case: only one provider
       if len(sorted) == 1 {
           _, err := tryProvider(ctx, sorted[0])
           return sorted[0], err
       }

       // Try primary first
       primary := sorted[0]
       statusCode, err := tryProvider(ctx, primary)

       if err == nil {
           return primary, nil // Primary succeeded
       }

       // Check if we should failover
       if !ShouldFailover(r.triggers, err, statusCode) {
           return primary, err // Don't failover for this error type
       }

       // Start parallel race
       return r.parallelRace(ctx, sorted, tryProvider)
   }
   ```

7. parallelRace helper:
   ```go
   func (r *FailoverRouter) parallelRace(
       ctx context.Context,
       providers []ProviderInfo,
       tryProvider func(context.Context, ProviderInfo) (int, error),
   ) (ProviderInfo, error) {
       raceCtx, cancel := context.WithTimeout(ctx, r.timeout)
       defer cancel()

       resultCh := make(chan RoutingResult, len(providers))

       // Launch all attempts in parallel
       var wg sync.WaitGroup
       for _, p := range providers {
           wg.Add(1)
           go func(provider ProviderInfo) {
               defer wg.Done()

               _, err := tryProvider(raceCtx, provider)
               select {
               case resultCh <- RoutingResult{Provider: provider, Err: err}:
               case <-raceCtx.Done():
               }
           }(p)
       }

       // Close result channel when all done
       go func() {
           wg.Wait()
           close(resultCh)
       }()

       // Wait for first success or all failures
       var lastErr error
       for result := range resultCh {
           if result.Err == nil {
               cancel() // Cancel other attempts
               return result.Provider, nil
           }
           lastErr = result.Err
       }

       return ProviderInfo{}, lastErr
   }
   ```

8. Name() returns StrategyFailover

Create internal/router/failover_test.go:
- Test Select returns highest priority healthy provider
- Test Select returns ErrNoProviders for empty slice
- Test Select returns ErrAllProvidersUnhealthy when all unhealthy
- Test SelectWithRetry returns immediately on primary success
- Test SelectWithRetry tries fallbacks on primary failure with trigger
- Test SelectWithRetry does NOT failover on non-trigger errors (e.g., 400)
- Test SelectWithRetry first success wins (use sleep in tryProvider)
- Test SelectWithRetry respects timeout
- Test concurrent safety
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go build ./internal/router/...
cd /home/omarluq/sandbox/go/cc-relay && go test ./internal/router/... -v -run TestFailover
cd /home/omarluq/sandbox/go/cc-relay && go test ./internal/router/... -race -run TestFailover
```
  </verify>
  <done>
- FailoverRouter implements ProviderRouter
- Select returns highest priority healthy provider
- SelectWithRetry tries primary first
- SelectWithRetry starts parallel race on trigger conditions
- First success cancels other attempts
- Timeout limits parallel race
- Thread-safe under concurrent load
- Tests cover success, failure, and race scenarios
  </done>
</task>

<task type="auto">
  <name>Task 2: Update NewRouter factory for failover</name>
  <files>internal/router/router.go, internal/router/router_test.go</files>
  <action>
Update internal/router/router.go NewRouter factory:

```go
func NewRouter(strategy string, timeout time.Duration) (ProviderRouter, error) {
    switch strategy {
    case StrategyRoundRobin:
        return NewRoundRobinRouter(), nil
    case StrategyShuffle:
        return NewShuffleRouter(), nil
    case StrategyWeightedRoundRobin:
        return NewWeightedRoundRobinRouter(), nil
    case StrategyFailover, "":  // Default strategy
        return NewFailoverRouter(timeout), nil
    default:
        return nil, fmt.Errorf("router: unknown strategy %q", strategy)
    }
}
```

Update internal/router/router_test.go:
- Test NewRouter("failover", 5*time.Second) returns FailoverRouter
- Test NewRouter("", 0) returns FailoverRouter (default)
- Verify timeout is passed correctly
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go build ./internal/router/...
cd /home/omarluq/sandbox/go/cc-relay && go test ./internal/router/... -v -run TestNewRouter
```
  </verify>
  <done>
- NewRouter creates FailoverRouter for "failover"
- NewRouter creates FailoverRouter for "" (empty = default)
- Timeout is passed to FailoverRouter
- All strategy types now have implementations
  </done>
</task>

</tasks>

<verification>
```bash
# All packages build
cd /home/omarluq/sandbox/go/cc-relay && go build ./...

# All router tests pass
cd /home/omarluq/sandbox/go/cc-relay && go test ./internal/router/... -v

# Race detector passes
cd /home/omarluq/sandbox/go/cc-relay && go test ./internal/router/... -race

# Linters pass
cd /home/omarluq/sandbox/go/cc-relay && task lint
```
</verification>

<success_criteria>
- FailoverRouter is the default strategy
- Primary provider tried first based on priority
- Parallel race starts on trigger conditions
- First success wins and cancels others
- Timeout limits parallel race
- Thread-safe under concurrent load
- All strategy implementations complete
- All tests pass including race detector
- Linters pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-routing-strategies/03-05-SUMMARY.md`
</output>
