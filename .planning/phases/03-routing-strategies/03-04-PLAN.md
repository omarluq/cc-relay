---
phase: 03-routing-strategies
plan: 04
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - internal/router/triggers.go
  - internal/router/triggers_test.go
autonomous: true

must_haves:
  truths:
    - "FailoverTrigger interface allows extensible failover conditions"
    - "5xx status codes trigger failover"
    - "429 rate limit errors trigger failover"
    - "Timeout errors (context.DeadlineExceeded) trigger failover"
    - "Network connection errors trigger failover"
  artifacts:
    - path: "internal/router/triggers.go"
      provides: "FailoverTrigger interface and default implementations"
      exports: ["FailoverTrigger", "StatusCodeTrigger", "TimeoutTrigger", "ConnectionTrigger", "DefaultTriggers"]
      min_lines: 80
  key_links:
    - from: "internal/router/triggers.go"
      to: "context"
      via: "TimeoutTrigger checks context.DeadlineExceeded"
      pattern: "context\\.DeadlineExceeded"
    - from: "internal/router/triggers.go"
      to: "net"
      via: "ConnectionTrigger checks net.Error"
      pattern: "net\\.Error"
---

<objective>
Create the extensible failover trigger system

Purpose: Define conditions that trigger failover to alternate providers. The trigger system is pluggable so new conditions can be added without modifying core failover logic. This follows CONTEXT.md requirement for extensible triggers.

Output:
- internal/router/triggers.go with FailoverTrigger interface and implementations
- StatusCodeTrigger for 5xx and 429 errors
- TimeoutTrigger for context deadline exceeded
- ConnectionTrigger for network errors
- DefaultTriggers() function returning default trigger set
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-routing-strategies/03-RESEARCH.md
@.planning/phases/03-routing-strategies/03-CONTEXT.md
@.planning/phases/03-routing-strategies/03-01-SUMMARY.md

# Pattern reference
@internal/router/router.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FailoverTrigger interface and implementations</name>
  <files>internal/router/triggers.go, internal/router/triggers_test.go</files>
  <action>
Create internal/router/triggers.go:

1. FailoverTrigger interface:
   ```go
   // FailoverTrigger defines conditions that trigger failover to alternate providers.
   // Implementations check specific failure conditions and return true if failover should occur.
   type FailoverTrigger interface {
       // ShouldFailover returns true if the error/status warrants trying another provider.
       // statusCode is the HTTP status code (0 if not applicable).
       ShouldFailover(err error, statusCode int) bool

       // Name returns the trigger name for logging.
       Name() string
   }
   ```

2. StatusCodeTrigger - triggers on specific HTTP status codes:
   ```go
   type StatusCodeTrigger struct {
       codes []int
   }

   func NewStatusCodeTrigger(codes ...int) *StatusCodeTrigger {
       return &StatusCodeTrigger{codes: codes}
   }

   func (t *StatusCodeTrigger) ShouldFailover(_ error, statusCode int) bool {
       for _, code := range t.codes {
           if statusCode == code {
               return true
           }
       }
       return false
   }

   func (t *StatusCodeTrigger) Name() string {
       return "status_code"
   }
   ```

3. TimeoutTrigger - triggers on context deadline exceeded:
   ```go
   type TimeoutTrigger struct{}

   func NewTimeoutTrigger() *TimeoutTrigger {
       return &TimeoutTrigger{}
   }

   func (t *TimeoutTrigger) ShouldFailover(err error, _ int) bool {
       return errors.Is(err, context.DeadlineExceeded)
   }

   func (t *TimeoutTrigger) Name() string {
       return "timeout"
   }
   ```

4. ConnectionTrigger - triggers on network errors:
   ```go
   type ConnectionTrigger struct{}

   func NewConnectionTrigger() *ConnectionTrigger {
       return &ConnectionTrigger{}
   }

   func (t *ConnectionTrigger) ShouldFailover(err error, _ int) bool {
       if err == nil {
           return false
       }
       var netErr net.Error
       return errors.As(err, &netErr)
   }

   func (t *ConnectionTrigger) Name() string {
       return "connection"
   }
   ```

5. DefaultTriggers function:
   ```go
   // DefaultTriggers returns the standard set of failover triggers:
   // - 429 (rate limit), 500, 502, 503, 504 status codes
   // - Timeout errors (context deadline exceeded)
   // - Network connection errors
   func DefaultTriggers() []FailoverTrigger {
       return []FailoverTrigger{
           NewStatusCodeTrigger(429, 500, 502, 503, 504),
           NewTimeoutTrigger(),
           NewConnectionTrigger(),
       }
   }
   ```

6. Helper to check if any trigger fires:
   ```go
   // ShouldFailover checks if any trigger fires for the given error/status.
   func ShouldFailover(triggers []FailoverTrigger, err error, statusCode int) bool {
       for _, trigger := range triggers {
           if trigger.ShouldFailover(err, statusCode) {
               return true
           }
       }
       return false
   }
   ```

Create internal/router/triggers_test.go:
- Test StatusCodeTrigger fires on 429
- Test StatusCodeTrigger fires on 500, 502, 503, 504
- Test StatusCodeTrigger does NOT fire on 200, 400, 401, 404
- Test TimeoutTrigger fires on context.DeadlineExceeded
- Test TimeoutTrigger does NOT fire on other errors
- Test ConnectionTrigger fires on net.Error
- Test ConnectionTrigger does NOT fire on non-network errors
- Test DefaultTriggers returns all three trigger types
- Test ShouldFailover helper returns true when any trigger fires
- Test ShouldFailover helper returns false when no triggers fire
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go build ./internal/router/...
cd /home/omarluq/sandbox/go/cc-relay && go test ./internal/router/... -v -run TestTrigger
cd /home/omarluq/sandbox/go/cc-relay && go test ./internal/router/... -v -run TestShouldFailover
cd /home/omarluq/sandbox/go/cc-relay && go test ./internal/router/... -v -run TestDefault
```
  </verify>
  <done>
- FailoverTrigger interface defined with ShouldFailover and Name methods
- StatusCodeTrigger fires on configured status codes
- TimeoutTrigger fires on context.DeadlineExceeded
- ConnectionTrigger fires on net.Error
- DefaultTriggers includes 429, 5xx, timeout, and connection triggers
- ShouldFailover helper checks all triggers
- All tests pass
  </done>
</task>

</tasks>

<verification>
```bash
# All packages build
cd /home/omarluq/sandbox/go/cc-relay && go build ./...

# All trigger tests pass
cd /home/omarluq/sandbox/go/cc-relay && go test ./internal/router/... -v

# Linters pass
cd /home/omarluq/sandbox/go/cc-relay && task lint
```
</verification>

<success_criteria>
- FailoverTrigger interface is extensible
- StatusCodeTrigger handles 429, 5xx codes
- TimeoutTrigger checks context.DeadlineExceeded
- ConnectionTrigger checks net.Error
- DefaultTriggers returns complete default set
- All tests pass
- Linters pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-routing-strategies/03-04-SUMMARY.md`
</output>
