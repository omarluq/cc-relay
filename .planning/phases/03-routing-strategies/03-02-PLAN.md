---
phase: 03-routing-strategies
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - internal/router/round_robin.go
  - internal/router/round_robin_test.go
  - internal/router/shuffle.go
  - internal/router/shuffle_test.go
  - internal/router/router.go
autonomous: true

must_haves:
  truths:
    - "Round-robin distributes requests evenly across healthy providers in sequence"
    - "Shuffle deals providers like cards - everyone gets one before anyone gets seconds"
    - "Both strategies skip unhealthy providers"
    - "NewRouter can create round_robin and shuffle routers"
  artifacts:
    - path: "internal/router/round_robin.go"
      provides: "RoundRobinRouter with atomic counter"
      exports: ["RoundRobinRouter", "NewRoundRobinRouter"]
      min_lines: 40
    - path: "internal/router/shuffle.go"
      provides: "ShuffleRouter with shuffled queue"
      exports: ["ShuffleRouter", "NewShuffleRouter"]
      min_lines: 50
  key_links:
    - from: "internal/router/round_robin.go"
      to: "internal/router/router.go"
      via: "implements ProviderRouter interface"
      pattern: "func.*Select.*ProviderInfo"
    - from: "internal/router/shuffle.go"
      to: "github.com/samber/lo/mutable"
      via: "lo/mutable.Shuffle for Fisher-Yates"
      pattern: "lom\\.Shuffle"
---

<objective>
Implement RoundRobinRouter and ShuffleRouter strategies

Purpose: Provide basic load distribution strategies - round-robin for predictable sequential distribution and shuffle for randomized but fair distribution (like dealing cards).

Output:
- internal/router/round_robin.go with atomic counter implementation
- internal/router/shuffle.go with shuffled queue implementation
- Unit tests for both strategies
- NewRouter factory updated to create these strategies
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-routing-strategies/03-RESEARCH.md
@.planning/phases/03-routing-strategies/03-CONTEXT.md
@.planning/phases/03-routing-strategies/03-01-SUMMARY.md

# Pattern to follow
@internal/keypool/round_robin.go
@internal/router/router.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement RoundRobinRouter</name>
  <files>internal/router/round_robin.go, internal/router/round_robin_test.go</files>
  <action>
Create internal/router/round_robin.go mirroring internal/keypool/round_robin.go pattern:

1. RoundRobinRouter struct:
   - `index uint64` - atomic counter for current position

2. NewRoundRobinRouter() constructor

3. Select method:
   - Return ErrNoProviders if providers slice is empty
   - Filter to healthy providers using FilterHealthy helper
   - Return ErrAllProvidersUnhealthy if no healthy providers
   - Use atomic.AddUint64 for thread-safe index increment
   - Use modulo to wrap around: `idx := int(nextIdx % uint64(len(healthy)))`
   - Add nolint:gosec comment for the int conversion (safe: modulo ensures range)
   - Return healthy[idx]

4. Name() returns StrategyRoundRobin

Create internal/router/round_robin_test.go:
- Test returns ErrNoProviders for empty slice
- Test returns ErrAllProvidersUnhealthy when all unhealthy
- Test distributes evenly across N providers over N*3 requests
- Test skips unhealthy providers
- Test concurrent safety (10 goroutines, 100 requests each)
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go build ./internal/router/...
cd /home/omarluq/sandbox/go/cc-relay && go test ./internal/router/... -v -run TestRoundRobin
cd /home/omarluq/sandbox/go/cc-relay && go test ./internal/router/... -race -run TestRoundRobin
```
  </verify>
  <done>
- RoundRobinRouter uses atomic counter
- Select filters unhealthy providers
- Distribution is sequential and even
- Thread-safe under concurrent load
- Tests pass including race detector
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement ShuffleRouter</name>
  <files>internal/router/shuffle.go, internal/router/shuffle_test.go</files>
  <action>
Create internal/router/shuffle.go implementing "dealing cards" pattern:

1. ShuffleRouter struct:
   - `mu sync.Mutex` - protects state
   - `shuffledOrder []int` - indices into provider list
   - `position int` - current position in shuffled order
   - `lastLen int` - track if provider list changed

2. NewShuffleRouter() constructor

3. Select method:
   - Return ErrNoProviders if providers slice is empty
   - Filter to healthy providers using FilterHealthy helper
   - Return ErrAllProvidersUnhealthy if no healthy providers
   - Lock mutex for state access
   - Reshuffle if: first time OR provider count changed OR exhausted (position >= len)
   - On reshuffle:
     - Create index slice [0, 1, 2, ..., len-1]
     - Use `lom.Shuffle(shuffledOrder)` from github.com/samber/lo/mutable
     - Reset position to 0
     - Update lastLen
   - Return healthy[shuffledOrder[position++]]

4. Name() returns StrategyShuffle

Import alias: `lom "github.com/samber/lo/mutable"`

Create internal/router/shuffle_test.go:
- Test returns ErrNoProviders for empty slice
- Test returns ErrAllProvidersUnhealthy when all unhealthy
- Test each provider gets exactly one request before any gets second (dealing cards)
- Test reshuffles when exhausted
- Test reshuffles when provider count changes
- Test skips unhealthy providers
- Test concurrent safety
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go build ./internal/router/...
cd /home/omarluq/sandbox/go/cc-relay && go test ./internal/router/... -v -run TestShuffle
cd /home/omarluq/sandbox/go/cc-relay && go test ./internal/router/... -race -run TestShuffle
```
  </verify>
  <done>
- ShuffleRouter uses sync.Mutex for state protection
- Uses lo/mutable.Shuffle for Fisher-Yates
- Reshuffles when exhausted or provider count changes
- Each provider gets one request before any gets second
- Thread-safe under concurrent load
- Tests pass including race detector
  </done>
</task>

<task type="auto">
  <name>Task 3: Update NewRouter factory</name>
  <files>internal/router/router.go, internal/router/router_test.go</files>
  <action>
Update internal/router/router.go NewRouter factory:

```go
func NewRouter(strategy string, timeout time.Duration) (ProviderRouter, error) {
    switch strategy {
    case StrategyRoundRobin:
        return NewRoundRobinRouter(), nil
    case StrategyShuffle:
        return NewShuffleRouter(), nil
    case StrategyFailover, "":
        // Failover implemented in Plan 05
        return nil, fmt.Errorf("router: %s strategy not yet implemented", strategy)
    case StrategyWeightedRoundRobin:
        // Weighted implemented in Plan 03
        return nil, fmt.Errorf("router: %s strategy not yet implemented", strategy)
    default:
        return nil, fmt.Errorf("router: unknown strategy %q", strategy)
    }
}
```

Update internal/router/router_test.go:
- Test NewRouter("round_robin", 0) returns RoundRobinRouter
- Test NewRouter("shuffle", 0) returns ShuffleRouter
- Test NewRouter("unknown", 0) returns error
  </action>
  <verify>
```bash
cd /home/omarluq/sandbox/go/cc-relay && go build ./internal/router/...
cd /home/omarluq/sandbox/go/cc-relay && go test ./internal/router/... -v -run TestNewRouter
```
  </verify>
  <done>
- NewRouter creates RoundRobinRouter for "round_robin"
- NewRouter creates ShuffleRouter for "shuffle"
- NewRouter returns descriptive error for unimplemented strategies
- NewRouter returns error for unknown strategies
  </done>
</task>

</tasks>

<verification>
```bash
# All packages build
cd /home/omarluq/sandbox/go/cc-relay && go build ./...

# All router tests pass
cd /home/omarluq/sandbox/go/cc-relay && go test ./internal/router/... -v

# Race detector passes
cd /home/omarluq/sandbox/go/cc-relay && go test ./internal/router/... -race

# Linters pass
cd /home/omarluq/sandbox/go/cc-relay && task lint
```
</verification>

<success_criteria>
- RoundRobinRouter distributes requests sequentially with atomic counter
- ShuffleRouter shuffles like dealing cards with Fisher-Yates
- Both strategies skip unhealthy providers
- Both strategies are thread-safe
- NewRouter creates correct strategy instances
- All tests pass including race detector
- Linters pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-routing-strategies/03-02-SUMMARY.md`
</output>
