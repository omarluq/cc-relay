# Phase 1.2: Cache Documentation - Research

**Researched:** 2026-01-21
**Domain:** Technical documentation for cc-relay cache subsystem
**Confidence:** HIGH

## Summary

This research investigates what documentation is needed for the cc-relay cache system implemented in Phase 1.1. The cache subsystem supports three modes (single/Ristretto, HA/Olric, disabled/noop), provides a unified interface, and includes HA clustering capabilities via embedded Olric nodes.

**Key findings:**
- The cache implementation is well-structured with clear interfaces (`Cache`, `StatsProvider`, `Pinger`, `ClusterInfo`, `MultiGetter`, `MultiSetter`)
- Configuration is comprehensive with `OlricConfig` fields for clustering (Environment, ReplicaCount, ReadQuorum, WriteQuorum, MemberCountQuorum)
- Example.yaml already has basic cache documentation but lacks HA clustering examples
- No dedicated cache documentation file exists - only inline code comments and example.yaml
- Documentation should follow existing DEVELOPMENT.md patterns (markdown, code examples, tables)

**Primary recommendation:** Create a dedicated `docs/cache.md` file covering key naming, busting strategies, adapter interface, extensibility, HA clustering, and troubleshooting.

## Standard Stack

The documentation should cover these existing components:

### Core Components to Document
| Component | File | Purpose | Documentation Priority |
|-----------|------|---------|----------------------|
| Cache interface | cache.go | Primary API contract | HIGH - entry point for users |
| Config types | config.go | Mode/OlricConfig/RistrettoConfig | HIGH - setup guide |
| Factory | factory.go | Cache initialization | MEDIUM - simple usage |
| Olric adapter | olric.go | HA distributed cache | HIGH - complex setup |
| Ristretto adapter | ristretto.go | Local cache | MEDIUM - simpler setup |
| Errors | errors.go | Error types | MEDIUM - troubleshooting |
| Logging | logging.go | Observability | LOW - simple API |

### Supporting Interfaces to Document
| Interface | Purpose | When to Document |
|-----------|---------|------------------|
| StatsProvider | Cache metrics | Operations/monitoring |
| Pinger | Health checks | Load balancer integration |
| ClusterInfo | HA cluster status | Multi-node deployments |
| MultiGetter/MultiSetter | Batch operations | Performance optimization |

## Architecture Patterns

### Recommended Documentation Structure

```
docs/
└── cache.md                 # Main cache documentation

# Table of Contents:
# 1. Overview
# 2. Quick Start
# 3. Cache Modes
# 4. Cache Key Conventions
# 5. Cache Busting Strategies
# 6. Configuration Reference
# 7. HA Clustering Guide
# 8. Extending with New Backends
# 9. Troubleshooting
# 10. API Reference
```

### Pattern 1: Key Naming Convention Documentation

**What:** Document cache key structure for maintainability and debugging
**Why critical:** Keys appear in logs, stats, and debugging - clear conventions essential
**Example content:**
```markdown
## Cache Key Conventions

cc-relay uses structured cache keys for organization and debugging:

### Key Format
```
{domain}:{type}:{identifier}
```

### Examples
| Domain | Type | Example Key | What It Caches |
|--------|------|-------------|----------------|
| provider | health | `provider:health:anthropic` | Provider health status |
| provider | config | `provider:config:zai` | Provider configuration |
| response | hash | `response:hash:abc123...` | Cached API response |
| model | list | `model:list:global` | Aggregated model list |

### Best Practices
- Use lowercase, colon-separated segments
- Keep identifiers deterministic and collision-free
- Include version/hash for response caching
```

### Pattern 2: Cache Busting Strategy Documentation

**What:** Document TTL, manual invalidation, and cluster event triggers
**Why critical:** Users need to understand when cache entries expire/invalidate
**Example content:**
```markdown
## Cache Busting Strategies

### 1. TTL-Based Expiration
- Use `SetWithTTL()` for time-sensitive data
- Default TTLs by use case:
  - Health status: 10s
  - Model lists: 5m
  - API responses: varies by header

### 2. Manual Invalidation
- Call `Delete(ctx, key)` to remove specific entries
- Idempotent - safe to call on non-existent keys

### 3. Cluster Events (HA Mode)
- Node leave: Olric redistributes partitions automatically
- Node join: New node picks up partition ownership
- Network partition: MemberCountQuorum prevents split-brain
```

### Pattern 3: Adapter Implementation Guide

**What:** Document how to implement the Cache interface for new backends
**Why critical:** Extensibility is a stated success criteria
**Example content:**
```markdown
## Implementing a New Cache Backend

### Required Interface
```go
type Cache interface {
    Get(ctx context.Context, key string) ([]byte, error)
    Set(ctx context.Context, key string, value []byte) error
    SetWithTTL(ctx context.Context, key string, value []byte, ttl time.Duration) error
    Delete(ctx context.Context, key string) error
    Exists(ctx context.Context, key string) (bool, error)
    Close() error
}
```

### Implementation Checklist
- [ ] Return ErrNotFound on cache miss
- [ ] Return ErrClosed after Close() called
- [ ] Be safe for concurrent use
- [ ] Copy byte slices (don't share references)
- [ ] Respect context cancellation

### Optional Interfaces
- `StatsProvider` - For metrics/observability
- `Pinger` - For health checks
- `ClusterInfo` - For distributed caches
- `MultiGetter`/`MultiSetter` - For batch operations
```

### Anti-Patterns to Avoid in Documentation

- **Missing code examples:** Every configuration option should have a working example
- **Outdated example.yaml comments:** Keep inline config comments in sync with docs
- **No troubleshooting section:** Users will hit common issues - document solutions
- **Assuming Olric knowledge:** Document Olric concepts (DMap, memberlist, quorum) for users unfamiliar with it

## Don't Hand-Roll

Documentation should reference existing content:

| Topic | Don't Write From Scratch | Reference Instead |
|-------|--------------------------|-------------------|
| Go doc comments | Duplicate in markdown | Link to godoc or inline `go doc cache` |
| Configuration structure | Describe manually | Reference example.yaml with annotations |
| Olric internals | Explain Olric architecture | Link to Olric docs, focus on cc-relay config |
| Error handling | List all error codes | Reference errors.go, show usage patterns |

**Key insight:** The code already has good documentation in comments. The markdown docs should provide usage guidance and examples, not repeat API specs.

## Common Pitfalls

### Pitfall 1: Inconsistent Configuration Documentation

**What goes wrong:** example.yaml comments drift from actual behavior
**Why it happens:** Code changes, config comments don't get updated
**How to avoid:**
- Keep example.yaml as source of truth for basic config
- Document advanced/HA config in dedicated docs with tested examples
- Add CI test that validates example.yaml parses correctly
**Warning signs:** User reports "config X doesn't work" for documented option

### Pitfall 2: Missing HA Prerequisites

**What goes wrong:** Users try HA mode without understanding requirements
**Why it happens:** HA setup has prerequisites not obvious from config alone
**How to avoid:** Document explicitly:
- Nodes must be able to reach each other on bind_addr
- Memberlist port = Olric port + 2 (document this!)
- Environment must match across all nodes
- Peers list should include at least one existing node
**Warning signs:** "nodes can't join cluster" support requests

### Pitfall 3: Unclear Error Messages

**What goes wrong:** Users don't understand error semantics
**Why it happens:** Generic errors without context
**How to avoid:** Troubleshooting section mapping errors to causes:
- `ErrNotFound` - Normal cache miss, not an error condition
- `ErrClosed` - Using cache after Close(), check lifecycle
- Connection errors - Check bind_addr, firewall, peers list
**Warning signs:** Issues asking "what does X error mean"

### Pitfall 4: No Migration Path Documentation

**What goes wrong:** Users can't switch modes without data loss
**Why it happens:** Cache data isn't persistent by design
**How to avoid:** Document explicitly:
- Switching modes clears all cached data (expected behavior)
- Restart always starts with empty cache (by design)
- This is a cache, not a database - ephemeral is correct
**Warning signs:** Users expecting cache persistence

## Code Examples

### Verified Configuration Examples to Document

```yaml
# Source: internal/cache/config.go + example.yaml
# Single-node (development/simple deployments)
cache:
  mode: single
  ristretto:
    num_counters: 1000000  # 10x expected items
    max_cost: 104857600    # 100 MB
    buffer_items: 64

# HA mode - 2-node cluster
cache:
  mode: ha
  olric:
    embedded: true
    bind_addr: "0.0.0.0:3320"
    dmap_name: "cc-relay"
    environment: lan           # "local", "lan", or "wan"
    peers:
      - "cc-relay-2:3322"      # Note: memberlist port = 3320 + 2
    replica_count: 2
    read_quorum: 1
    write_quorum: 1
    member_count_quorum: 2
    leave_timeout: 5s

# Disabled (passthrough, no caching)
cache:
  mode: disabled
```

### Verified Code Usage Examples

```go
// Source: internal/cache/cache.go - interface documentation
import (
    "context"
    "errors"
    "time"

    "github.com/omarluq/cc-relay/internal/cache"
)

// Basic usage
func example() {
    cfg := &cache.Config{
        Mode: cache.ModeSingle,
        Ristretto: cache.DefaultRistrettoConfig(),
    }

    c, err := cache.New(context.Background(), cfg)
    if err != nil {
        log.Fatal(err)
    }
    defer c.Close()

    // Set with TTL
    err = c.SetWithTTL(ctx, "key", []byte("value"), 5*time.Minute)

    // Get (handle miss)
    data, err := c.Get(ctx, "key")
    if errors.Is(err, cache.ErrNotFound) {
        // Cache miss - fetch from source
    }
}

// Optional interface usage
func statsExample(c cache.Cache) {
    if sp, ok := c.(cache.StatsProvider); ok {
        stats := sp.Stats()
        log.Info().
            Uint64("hits", stats.Hits).
            Uint64("misses", stats.Misses).
            Msg("cache stats")
    }
}

// HA cluster info
func clusterExample(c cache.Cache) {
    if ci, ok := c.(cache.ClusterInfo); ok {
        if ci.IsEmbedded() {
            log.Info().
                Str("memberlist_addr", ci.MemberlistAddr()).
                Int("members", ci.ClusterMembers()).
                Msg("cluster status")
        }
    }
}
```

### HA Clustering Deployment Example

```yaml
# Source: Phase 1.1 research + olric_cluster_test.go patterns
# docker-compose.yaml for 3-node HA cluster

version: '3.8'
services:
  cc-relay-1:
    image: cc-relay:latest
    environment:
      - CC_RELAY_CONFIG=/config/config.yaml
    volumes:
      - ./config-node1.yaml:/config/config.yaml
    ports:
      - "8787:8787"   # HTTP proxy
      - "3320:3320"   # Olric client port
      - "3322:3322"   # Memberlist gossip port
    networks:
      - cc-relay-net

  cc-relay-2:
    image: cc-relay:latest
    environment:
      - CC_RELAY_CONFIG=/config/config.yaml
    volumes:
      - ./config-node2.yaml:/config/config.yaml
    ports:
      - "8788:8787"
      - "3330:3320"
      - "3332:3322"
    networks:
      - cc-relay-net

  cc-relay-3:
    image: cc-relay:latest
    environment:
      - CC_RELAY_CONFIG=/config/config.yaml
    volumes:
      - ./config-node3.yaml:/config/config.yaml
    ports:
      - "8789:8787"
      - "3340:3320"
      - "3342:3322"
    networks:
      - cc-relay-net

networks:
  cc-relay-net:
    driver: bridge

---
# config-node1.yaml
cache:
  mode: ha
  olric:
    embedded: true
    bind_addr: "0.0.0.0:3320"
    environment: lan
    peers:
      - "cc-relay-2:3322"
      - "cc-relay-3:3322"
    replica_count: 2
    write_quorum: 1
    member_count_quorum: 2
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Inline example.yaml comments only | Dedicated docs file | Phase 1.2 | Better discoverability |
| No HA examples | Full clustering guide | Phase 1.2 | HA deployments supported |
| No extensibility docs | Adapter implementation guide | Phase 1.2 | Community contributions |

**Current documentation state:**
- `example.yaml` - Basic config with comments (exists, but HA section is commented out)
- Code comments in `cache.go` - Good godoc comments (exists)
- No dedicated cache documentation markdown file (gap)
- No troubleshooting guide (gap)
- No adapter implementation guide (gap)

## Open Questions

Things that couldn't be fully resolved:

1. **Stats API limitations in embedded mode**
   - What we know: ClusterMembers()/MemberlistAddr() return 0/"" in embedded test mode
   - What's unclear: Is this a test-only limitation or affects production?
   - Recommendation: Document as known limitation, recommend using Ping() for health checks

2. **Optimal TTL recommendations**
   - What we know: TTL is configurable via SetWithTTL()
   - What's unclear: What are recommended TTLs for different use cases?
   - Recommendation: Document use-case-specific recommendations based on actual cc-relay usage patterns

3. **Metrics/Prometheus integration**
   - What we know: StatsProvider interface exists
   - What's unclear: How stats integrate with Prometheus endpoint mentioned in README
   - Recommendation: Document how to expose cache stats via metrics endpoint

## Sources

### Primary (HIGH confidence)
- `/home/omarluq/sandbox/go/cc-relay/internal/cache/*.go` - Source code with godoc comments
- `/home/omarluq/sandbox/go/cc-relay/example.yaml` - Current configuration reference
- `/home/omarluq/sandbox/go/cc-relay/.planning/phases/01.1-embedded-ha-cache-clustering/01.1-RESEARCH.md` - Phase 1.1 research

### Secondary (MEDIUM confidence)
- `/home/omarluq/sandbox/go/cc-relay/DEVELOPMENT.md` - Documentation style reference
- `/home/omarluq/sandbox/go/cc-relay/README.md` - Project documentation patterns

### Tertiary (LOW confidence)
- Olric documentation (for advanced Olric configuration details)

## Metadata

**Confidence breakdown:**
- Documentation structure: HIGH - Based on existing repo patterns and success criteria
- Code examples: HIGH - Derived directly from source code
- HA configuration: HIGH - Based on Phase 1.1 research and test patterns
- Troubleshooting: MEDIUM - Based on known pitfalls, not actual support tickets

**Research date:** 2026-01-21
**Valid until:** ~90 days (cache implementation is stable after Phase 1.1)

## Appendix: Documentation Success Criteria Mapping

| Success Criteria | Documentation Section | Source Content |
|-----------------|----------------------|----------------|
| Cache key naming conventions documented | Section 4 | Key pattern examples |
| Cache busting strategies documented | Section 5 | TTL, manual, cluster events |
| Cache adapter interface documented | Section 8 | Interface definitions + checklist |
| How to extend with new backends | Section 8 | Step-by-step guide |
| HA clustering configuration documented | Section 7 | Full YAML examples, docker-compose |
| Troubleshooting guide | Section 9 | Error mapping, common issues |

## Appendix: OlricConfig Field Documentation Reference

| Field | Type | Default | Description |
|-------|------|---------|-------------|
| DMapName | string | "cc-relay" | Name of the distributed map |
| BindAddr | string | required | Address for Olric client connections |
| Environment | string | "local" | Memberlist preset: "local", "lan", "wan" |
| Addresses | []string | - | External cluster addresses (client mode) |
| Peers | []string | - | Memberlist addresses for peer discovery |
| ReplicaCount | int | 1 | Number of copies per key (1 = no replication) |
| ReadQuorum | int | 1 | Minimum reads for response (must be <= ReplicaCount) |
| WriteQuorum | int | 1 | Minimum writes for response (must be <= ReplicaCount) |
| MemberCountQuorum | int32 | 1 | Minimum cluster members to operate |
| LeaveTimeout | time.Duration | 5s | Time to broadcast leave message |
| Embedded | bool | false | Run embedded Olric node vs. client mode |

## Appendix: Port Usage Reference

| Port | Purpose | Notes |
|------|---------|-------|
| 3320 (default) | Olric client connections | Configurable via bind_addr |
| 3322 (default) | Memberlist gossip | Always bind_addr port + 2 |

**Example:** If `bind_addr: "0.0.0.0:3320"`, memberlist uses port 3322 automatically.
