---
phase: 01.1-embedded-ha-cache-clustering
plan: 02
type: execute
wave: 2
depends_on: ["01.1-01"]
files_modified:
  - internal/cache/olric.go
autonomous: true

must_haves:
  truths:
    - "Embedded Olric nodes use Environment setting to select memberlist preset"
    - "Embedded Olric nodes configure ReplicaCount for data replication"
    - "Embedded Olric nodes configure ReadQuorum and WriteQuorum for consistency"
    - "Embedded Olric nodes configure MemberCountQuorum for split-brain prevention"
    - "Embedded Olric nodes configure LeaveTimeout for graceful shutdown"
    - "Zero/default values use Olric's internal defaults (not overwritten)"
  artifacts:
    - path: "internal/cache/olric.go"
      provides: "buildOlricConfig helper function"
      contains: "func buildOlricConfig"
  key_links:
    - from: "internal/cache/olric.go"
      to: "olricconfig.New(env)"
      via: "Environment field selects preset"
      pattern: "olricconfig\\.New\\(.*Environment"
    - from: "internal/cache/olric.go"
      to: "olric config fields"
      via: "Direct field assignment"
      pattern: "c\\.ReplicaCount|c\\.WriteQuorum|c\\.MemberCountQuorum"
---

<objective>
Update newEmbeddedOlricCache to use HA clustering configuration fields

Purpose: Apply the new OlricConfig HA fields (Environment, ReplicaCount, quorum settings, LeaveTimeout) when creating embedded Olric nodes, enabling proper cluster formation and data replication.

Output: Updated olric.go that creates properly configured HA-capable embedded nodes
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01.1-embedded-ha-cache-clustering/01.1-RESEARCH.md
@.planning/phases/01.1-embedded-ha-cache-clustering/01.1-01-SUMMARY.md

# Existing implementation
@internal/cache/olric.go
@internal/cache/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract buildOlricConfig helper function</name>
  <files>internal/cache/olric.go</files>
  <action>
Create a new helper function `buildOlricConfig` that creates an Olric config from OlricConfig.

This extracts and extends the config building logic from newEmbeddedOlricCache:

```go
// buildOlricConfig creates an Olric config from the cache OlricConfig.
// It applies environment presets and HA clustering settings.
func buildOlricConfig(cfg *OlricConfig) *olricconfig.Config {
    // Select environment preset - determines memberlist timeouts, gossip intervals
    env := cfg.Environment
    if env == "" {
        env = "local"
    }

    c := olricconfig.New(env)

    // Parse bind address - may contain host:port or just host
    bindAddr, bindPort := parseBindAddr(cfg.BindAddr)
    c.BindAddr = bindAddr
    if bindPort > 0 {
        c.BindPort = bindPort
    }

    // Set peers for cluster discovery
    if len(cfg.Peers) > 0 {
        c.Peers = cfg.Peers
    }

    // Apply HA clustering settings (only if non-zero to preserve Olric defaults)
    if cfg.ReplicaCount > 0 {
        c.ReplicaCount = cfg.ReplicaCount
    }
    if cfg.ReadQuorum > 0 {
        c.ReadQuorum = cfg.ReadQuorum
    }
    if cfg.WriteQuorum > 0 {
        c.WriteQuorum = cfg.WriteQuorum
    }
    if cfg.MemberCountQuorum > 0 {
        c.MemberCountQuorum = cfg.MemberCountQuorum
    }
    if cfg.LeaveTimeout > 0 {
        c.LeaveTimeout = cfg.LeaveTimeout
    }

    // Suppress verbose Olric logging
    c.LogOutput = io.Discard
    c.Logger = log.New(io.Discard, "", 0)

    return c
}
```

Key points:
- Use `olricconfig.New(env)` with cfg.Environment (not hardcoded "local")
- Only set non-zero values to preserve Olric's internal defaults
- Keep existing bind address parsing and peer configuration
- Keep log suppression for clean output
  </action>
  <verify>go build ./internal/cache/...</verify>
  <done>buildOlricConfig function exists and compiles successfully</done>
</task>

<task type="auto">
  <name>Task 2: Update newEmbeddedOlricCache to use buildOlricConfig</name>
  <files>internal/cache/olric.go</files>
  <action>
Refactor newEmbeddedOlricCache to use the new buildOlricConfig helper:

1. Replace the inline config creation with a call to buildOlricConfig:
   ```go
   // Create embedded config with HA settings
   c := buildOlricConfig(cfg)
   ```

2. Remove the now-duplicated code:
   - Remove: `c := olricconfig.New("local")`
   - Remove: bind address parsing (moved to helper)
   - Remove: peers setting (moved to helper)
   - Remove: log suppression (moved to helper)

3. Keep the remaining logic:
   - Ready channel setup (`c.Started = func() { ... }`)
   - Olric instance creation (`olric.New(c)`)
   - Background start goroutine
   - Startup wait logic
   - Embedded client and DMap creation

4. Update the debug log to include HA settings:
   ```go
   lg.Info().
       Str("bind_addr", bindAddr).
       Int("bind_port", bindPort).
       Str("dmap", dmapName).
       Int("peers", len(cfg.Peers)).
       Str("environment", cfg.Environment).
       Int("replica_count", cfg.ReplicaCount).
       Int("write_quorum", cfg.WriteQuorum).
       Msg("olric embedded cache created")
   ```

Note: The bindAddr and bindPort variables are still needed for logging - you can either:
- Call parseBindAddr again for logging, or
- Store the values from buildOlricConfig (add return values), or
- Log cfg.BindAddr directly (simpler)
  </action>
  <verify>go build ./internal/cache/...</verify>
  <done>newEmbeddedOlricCache uses buildOlricConfig and logs HA settings</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for HA configuration</name>
  <files>internal/cache/olric_test.go</files>
  <action>
Add tests to verify HA configuration is applied correctly:

```go
func TestOlricCache_HAConfiguration(t *testing.T) {
    port := getNextPort()
    cfg := OlricConfig{
        DMapName:          fmt.Sprintf("ha-test-dmap-%d", port),
        Embedded:          true,
        BindAddr:          fmt.Sprintf("127.0.0.1:%d", port),
        Environment:       "local",
        ReplicaCount:      2,
        ReadQuorum:        1,
        WriteQuorum:       1,
        MemberCountQuorum: 1,
        LeaveTimeout:      3 * time.Second,
    }

    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    cache, err := newOlricCache(ctx, &cfg)
    if err != nil {
        t.Fatalf("failed to create olric cache with HA config: %v", err)
    }
    defer cache.Close()

    // Verify cache is functional with HA settings
    testKey := "ha-test-key"
    testValue := []byte("ha-test-value")

    err = cache.Set(ctx, testKey, testValue)
    if err != nil {
        t.Fatalf("Set with HA config failed: %v", err)
    }

    got, err := cache.Get(ctx, testKey)
    if err != nil {
        t.Fatalf("Get with HA config failed: %v", err)
    }

    if !bytes.Equal(got, testValue) {
        t.Errorf("Get returned %q, want %q", got, testValue)
    }
}

func TestOlricCache_EnvironmentPresets(t *testing.T) {
    testCases := []struct {
        name        string
        environment string
    }{
        {"default (empty)", ""},
        {"local", "local"},
        {"lan", "lan"},
        // Note: "wan" has longer timeouts, may make test slower
    }

    for _, tc := range testCases {
        t.Run(tc.name, func(t *testing.T) {
            port := getNextPort()
            cfg := OlricConfig{
                DMapName:    fmt.Sprintf("env-test-dmap-%d", port),
                Embedded:    true,
                BindAddr:    fmt.Sprintf("127.0.0.1:%d", port),
                Environment: tc.environment,
            }

            ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
            defer cancel()

            cache, err := newOlricCache(ctx, &cfg)
            if err != nil {
                t.Fatalf("failed to create cache with environment %q: %v", tc.environment, err)
            }
            defer cache.Close()

            // Basic functionality check
            err = cache.Set(ctx, "key", []byte("value"))
            if err != nil {
                t.Fatalf("Set failed with environment %q: %v", tc.environment, err)
            }
        })
    }
}
```

Add import for "bytes" if not present (it should already be there from existing tests).
  </action>
  <verify>go test -v -run "TestOlricCache_HA|TestOlricCache_Environment" ./internal/cache/...</verify>
  <done>New tests verify HA configuration is applied and cache functions correctly with HA settings</done>
</task>

</tasks>

<verification>
```bash
# Build succeeds
go build ./internal/cache/...

# All tests pass including new HA tests
go test -v -short ./internal/cache/...

# Verify buildOlricConfig function exists
grep "func buildOlricConfig" internal/cache/olric.go

# Verify environment is used (not hardcoded "local")
grep -n 'olricconfig.New(' internal/cache/olric.go
```
</verification>

<success_criteria>
- buildOlricConfig helper function exists and creates config with all HA fields
- newEmbeddedOlricCache uses buildOlricConfig instead of inline config creation
- Environment field is used to select memberlist preset (not hardcoded "local")
- Non-zero ReplicaCount, ReadQuorum, WriteQuorum, MemberCountQuorum, LeaveTimeout are applied
- Zero values preserve Olric's internal defaults
- New tests verify HA configuration works correctly
- All existing tests continue to pass
- Logging includes HA settings for observability
</success_criteria>

<output>
After completion, create `.planning/phases/01.1-embedded-ha-cache-clustering/01.1-02-SUMMARY.md`
</output>
