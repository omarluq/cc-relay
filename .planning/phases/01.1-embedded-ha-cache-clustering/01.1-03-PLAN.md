---
phase: 01.1-embedded-ha-cache-clustering
plan: 03
type: execute
wave: 2
depends_on: ["01.1-01"]
files_modified:
  - internal/cache/olric.go
autonomous: true

must_haves:
  truths:
    - "olricCache exposes cluster member information for observability"
    - "olricCache can report its memberlist address for peer discovery"
    - "Close() gracefully leaves cluster before shutdown"
    - "Graceful shutdown uses configured LeaveTimeout"
  artifacts:
    - path: "internal/cache/olric.go"
      provides: "MemberlistAddr and ClusterInfo methods"
      contains: "func (o *olricCache) MemberlistAddr"
  key_links:
    - from: "internal/cache/olric.go"
      to: "olric.Olric"
      via: "db field for embedded node info"
      pattern: "o\\.db\\..*"
---

<objective>
Add cluster membership helpers and verify graceful shutdown behavior

Purpose: Provide methods to expose cluster membership information for peer discovery and observability. Verify that Close() properly handles cluster leave (Olric handles this internally, but we need to verify and document the behavior).

Output: olricCache with cluster info methods and verified graceful shutdown
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01.1-embedded-ha-cache-clustering/01.1-RESEARCH.md
@.planning/phases/01.1-embedded-ha-cache-clustering/01.1-01-SUMMARY.md

# Existing implementation
@internal/cache/olric.go
@internal/cache/cache.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ClusterInfo interface and implementation</name>
  <files>internal/cache/cache.go</files>
  <action>
Add a new optional interface for cluster-aware caches:

```go
// ClusterInfo is an optional interface for distributed caches that support clustering.
// Use type assertion to check if a cache implements this interface:
//
//	if ci, ok := c.(cache.ClusterInfo); ok {
//		addr := ci.MemberlistAddr()
//		members := ci.ClusterMembers()
//	}
type ClusterInfo interface {
    // MemberlistAddr returns the memberlist address of this node.
    // This is the address other nodes should use in their Peers list to join.
    // Returns empty string if not in embedded mode or not yet started.
    MemberlistAddr() string

    // ClusterMembers returns the number of members in the cluster.
    // Returns 0 if not in embedded mode or unable to get stats.
    ClusterMembers() int

    // IsEmbedded returns true if this cache is running an embedded Olric node.
    // Client mode caches return false.
    IsEmbedded() bool
}
```

This interface allows tests and operators to inspect cluster state without reaching into internal implementation details.
  </action>
  <verify>go build ./internal/cache/...</verify>
  <done>ClusterInfo interface defined in cache.go with MemberlistAddr, ClusterMembers, and IsEmbedded methods</done>
</task>

<task type="auto">
  <name>Task 2: Implement ClusterInfo on olricCache</name>
  <files>internal/cache/olric.go</files>
  <action>
Implement the ClusterInfo interface on olricCache:

```go
// Ensure olricCache implements ClusterInfo
var _ ClusterInfo = (*olricCache)(nil)

// MemberlistAddr returns the memberlist address of this node.
// Other nodes should use this address in their Peers list to join the cluster.
// Returns empty string if not in embedded mode.
func (o *olricCache) MemberlistAddr() string {
    if o.db == nil {
        return "" // Not embedded mode
    }

    o.mu.RLock()
    defer o.mu.RUnlock()

    if o.closed.Load() {
        return ""
    }

    // Get the runtime to access this node's address
    // The memberlist port is typically BindPort + 2 (Olric default offset)
    // But we can get the actual address from the embedded client stats
    client := o.db.NewEmbeddedClient()
    defer client.Close(context.Background())

    // Get this node's address from stats
    // Stats requires a member address - for embedded, we can use localhost
    // This is a simplified approach - for production, consider caching this value
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()

    // Try to get stats to find our address
    // If this fails, return empty string (node may not be ready)
    stats, err := client.Stats(ctx, "")
    if err != nil {
        return ""
    }

    // Return the member address from stats
    // Note: This returns the Olric address, memberlist is typically +2 port
    return stats.Member.String()
}

// ClusterMembers returns the number of members in the cluster.
func (o *olricCache) ClusterMembers() int {
    if o.db == nil {
        return 0 // Not embedded mode
    }

    o.mu.RLock()
    defer o.mu.RUnlock()

    if o.closed.Load() {
        return 0
    }

    client := o.db.NewEmbeddedClient()
    defer client.Close(context.Background())

    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()

    stats, err := client.Stats(ctx, "")
    if err != nil {
        o.log.Debug().Err(err).Msg("olric: failed to get cluster stats")
        return 0
    }

    return len(stats.ClusterMembers)
}

// IsEmbedded returns true if this cache is running an embedded Olric node.
func (o *olricCache) IsEmbedded() bool {
    return o.db != nil
}
```

Note: The Stats() call with empty string returns stats for the local node. This is the simplest way to get member info without storing additional state.
  </action>
  <verify>go build ./internal/cache/...</verify>
  <done>olricCache implements ClusterInfo interface with all three methods</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for cluster info and graceful shutdown</name>
  <files>internal/cache/olric_test.go</files>
  <action>
Add tests to verify ClusterInfo implementation and graceful shutdown:

```go
func TestOlricCache_ClusterInfo(t *testing.T) {
    cache := newTestOlricCache(t)

    // Type assert to ClusterInfo
    ci, ok := cache.(ClusterInfo)
    if !ok {
        t.Fatal("olricCache should implement ClusterInfo")
    }

    // Test IsEmbedded
    if !ci.IsEmbedded() {
        t.Error("IsEmbedded should return true for embedded cache")
    }

    // Test ClusterMembers - single node cluster should have 1 member
    members := ci.ClusterMembers()
    if members != 1 {
        t.Errorf("ClusterMembers returned %d, want 1 for single node", members)
    }

    // Test MemberlistAddr - should return non-empty for embedded
    addr := ci.MemberlistAddr()
    if addr == "" {
        t.Log("MemberlistAddr returned empty (may be expected if stats unavailable)")
        // Not a hard failure - stats may not be immediately available
    } else {
        t.Logf("MemberlistAddr: %s", addr)
    }
}

func TestOlricCache_ClusterInfo_ClientMode(t *testing.T) {
    // Skip this test in CI - requires external Olric cluster
    // This documents expected behavior for client mode
    t.Skip("Skipping client mode test - requires external Olric cluster")

    // In client mode (db == nil), all ClusterInfo methods should return zero/empty values
    // This is intentional - client doesn't know about memberlist details
}

func TestOlricCache_GracefulShutdown(t *testing.T) {
    port := getNextPort()
    cfg := OlricConfig{
        DMapName:     fmt.Sprintf("shutdown-test-%d", port),
        Embedded:     true,
        BindAddr:     fmt.Sprintf("127.0.0.1:%d", port),
        LeaveTimeout: 2 * time.Second, // Short timeout for test
    }

    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    cache, err := newOlricCache(ctx, &cfg)
    if err != nil {
        t.Fatalf("failed to create cache: %v", err)
    }

    // Set some data
    err = cache.Set(ctx, "key", []byte("value"))
    if err != nil {
        t.Fatalf("Set failed: %v", err)
    }

    // Time the shutdown - should complete within LeaveTimeout + overhead
    start := time.Now()
    err = cache.Close()
    duration := time.Since(start)

    if err != nil {
        t.Errorf("Close returned error: %v", err)
    }

    // Shutdown should complete reasonably quickly for single node
    // (no leave broadcast needed when no other members)
    if duration > 5*time.Second {
        t.Errorf("Close took %v, expected < 5s for single node", duration)
    }

    t.Logf("Graceful shutdown completed in %v", duration)
}
```

Import `ClusterInfo` interface reference - since it's in the same package, no import needed.
  </action>
  <verify>go test -v -run "TestOlricCache_ClusterInfo|TestOlricCache_GracefulShutdown" ./internal/cache/...</verify>
  <done>Tests verify ClusterInfo interface and graceful shutdown behavior</done>
</task>

</tasks>

<verification>
```bash
# Build succeeds
go build ./internal/cache/...

# All tests pass
go test -v -short ./internal/cache/...

# Verify ClusterInfo interface exists
grep "type ClusterInfo interface" internal/cache/cache.go

# Verify olricCache implements it
grep "var _ ClusterInfo = (\*olricCache)(nil)" internal/cache/olric.go
```
</verification>

<success_criteria>
- ClusterInfo interface defined in cache.go with MemberlistAddr, ClusterMembers, IsEmbedded
- olricCache implements ClusterInfo interface (compile-time check)
- MemberlistAddr() returns address for embedded mode, empty for client mode
- ClusterMembers() returns member count for embedded mode, 0 for client mode
- IsEmbedded() returns true for embedded mode, false for client mode
- Close() completes gracefully within reasonable time
- Tests verify ClusterInfo methods and shutdown behavior
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/01.1-embedded-ha-cache-clustering/01.1-03-SUMMARY.md`
</output>
