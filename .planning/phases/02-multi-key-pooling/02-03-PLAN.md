---
phase: 02-multi-key-pooling
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - internal/keypool/pool.go
  - internal/keypool/pool_test.go
autonomous: true
user_setup: []

must_haves:
  truths:
    - "KeyPool manages multiple keys for a single provider"
    - "GetKey selects a key using configured strategy"
    - "GetKey returns ErrAllKeysExhausted when no capacity remains"
    - "UpdateKeyFromHeaders updates key state from response headers"
    - "Pool is thread-safe for concurrent access"
  artifacts:
    - path: "internal/keypool/pool.go"
      provides: "KeyPool struct coordinating rate limiters and selectors"
      exports: ["KeyPool", "NewKeyPool", "PoolConfig"]
    - path: "internal/keypool/pool_test.go"
      provides: "Unit tests for key pool"
      min_lines: 100
  key_links:
    - from: "internal/keypool/pool.go"
      to: "internal/keypool/selector.go"
      via: "KeySelector.Select() call in GetKey"
      pattern: "selector\\.Select"
    - from: "internal/keypool/pool.go"
      to: "internal/ratelimit/limiter.go"
      via: "RateLimiter.Allow() call in GetKey"
      pattern: "limiter\\.Allow"
---

<objective>
Create KeyPool that coordinates rate limiters and key selectors.

Purpose: Central pool manager that selects the best available key for each request, enforces rate limits, and tracks key state from response headers. This is the main API that the proxy handler will use.

Output:
- `internal/keypool/pool.go` - KeyPool implementation
- `internal/keypool/pool_test.go` - Unit tests
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-multi-key-pooling/02-RESEARCH.md
@.planning/phases/02-multi-key-pooling/02-CONTEXT.md
@.planning/phases/02-multi-key-pooling/02-01-SUMMARY.md
@.planning/phases/02-multi-key-pooling/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create KeyPool struct and configuration</name>
  <files>internal/keypool/pool.go</files>
  <action>
Create `internal/keypool/pool.go` with:

1. Package imports including:
   - `internal/ratelimit`
   - `sync`
   - `net/http`
   - `time`
   - `context`

2. PoolConfig struct:
   ```go
   type PoolConfig struct {
       Strategy   string        // Selection strategy name
       Keys       []KeyConfig   // Key configurations
   }

   type KeyConfig struct {
       APIKey   string
       RPMLimit int  // 0 = unlimited (learn from headers)
       ITPMLimit int
       OTPMLimit int
       Priority int  // 0=low, 1=normal, 2=high
       Weight   int  // For weighted strategy
   }
   ```

3. KeyPool struct:
   ```go
   type KeyPool struct {
       provider string                         // Provider name for logging
       keys     []*KeyMetadata                 // All keys in pool
       keyMap   map[string]*KeyMetadata        // ID -> key lookup
       limiters map[string]ratelimit.RateLimiter // ID -> rate limiter
       selector KeySelector                    // Selection strategy
       mu       sync.RWMutex                   // Protects keys, keyMap, limiters
   }
   ```

4. Constructor `NewKeyPool(provider string, cfg PoolConfig) (*KeyPool, error)`:
   - Validate at least one key configured
   - Create KeySelector using NewSelector(cfg.Strategy)
   - Create KeyMetadata for each key in cfg.Keys
   - Create TokenBucketLimiter for each key
   - Build keyMap for O(1) lookup by ID
   - Return initialized pool

5. Implement zerolog logging for pool operations (match existing proxy patterns).
  </action>
  <verify>
```bash
go build ./internal/keypool/...
```
  </verify>
  <done>KeyPool struct and PoolConfig compile with proper structure</done>
</task>

<task type="auto">
  <name>Task 2: Implement pool methods</name>
  <files>internal/keypool/pool.go</files>
  <action>
Add methods to KeyPool in `internal/keypool/pool.go`:

1. `GetKey(ctx context.Context) (string, string, error)`:
   - Returns (keyID, apiKey, error)
   - RLock pool, get available keys
   - Call selector.Select(keys) to choose key
   - Check rate limiter with limiter.Allow(ctx)
   - If limiter denies, mark key capacity and try next (loop through selector)
   - If all keys exhausted, return "", "", ErrAllKeysExhausted
   - Return keyID and apiKey for successful selection
   - Log selection at Debug level

2. `UpdateKeyFromHeaders(keyID string, headers http.Header) error`:
   - Lock pool for write
   - Find key by ID in keyMap
   - Call key.UpdateFromHeaders(headers)
   - Update rate limiter with key.SetLimit() if limits changed
   - Log update at Debug level
   - Return nil or ErrKeyNotFound

3. `MarkKeyExhausted(keyID string, retryAfter time.Duration)`:
   - Lock pool for write
   - Find key by ID
   - Call key.SetCooldown(time.Now().Add(retryAfter))
   - Log at Warn level

4. `GetEarliestResetTime() time.Duration`:
   - RLock pool
   - Find key with earliest RPMResetAt
   - Return time.Until(earliest) or 60s default

5. `GetStats() PoolStats`:
   ```go
   type PoolStats struct {
       TotalKeys      int
       AvailableKeys  int
       ExhaustedKeys  int
       TotalRPM       int
       RemainingRPM   int
   }
   ```
   - RLock pool, aggregate stats from all keys

6. `Keys() []*KeyMetadata`:
   - RLock pool
   - Return copy of keys slice (for external iteration)

Implementation notes:
- Use RLock for read operations (GetKey, GetStats, GetEarliestResetTime)
- Use Lock for write operations (UpdateKeyFromHeaders, MarkKeyExhausted)
- Rate limiter has internal mutex, don't hold pool lock during limiter.Allow()
  </action>
  <verify>
```bash
go build ./internal/keypool/...
```
  </verify>
  <done>KeyPool methods compile and implement the coordination logic</done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive unit tests</name>
  <files>internal/keypool/pool_test.go</files>
  <action>
Create `internal/keypool/pool_test.go` with tests:

1. `TestNewKeyPool`:
   - Creates pool with valid config
   - Returns error with no keys
   - Creates selector matching strategy
   - Initializes all keys with limiters

2. `TestGetKey_Success`:
   - Returns key when capacity available
   - Returns keyID and apiKey
   - Selector strategy is respected (least-loaded picks highest capacity)

3. `TestGetKey_AllExhausted`:
   - All keys at capacity -> ErrAllKeysExhausted
   - All keys unhealthy -> ErrAllKeysExhausted
   - All keys in cooldown -> ErrAllKeysExhausted

4. `TestGetKey_SkipsUnavailable`:
   - Skips unhealthy keys, returns healthy one
   - Skips cooldown keys, returns available one
   - Skips rate-limited keys, returns one with capacity

5. `TestUpdateKeyFromHeaders`:
   - Updates key limits from headers
   - Updates remaining capacity from headers
   - Updates reset time from headers
   - Returns error for unknown keyID

6. `TestMarkKeyExhausted`:
   - Sets cooldown period
   - Key becomes unavailable during cooldown
   - Key becomes available after cooldown expires

7. `TestGetEarliestResetTime`:
   - Returns time to earliest reset
   - Returns 60s default when no reset times set

8. `TestGetStats`:
   - Returns correct counts
   - Updates after key state changes

9. `TestConcurrency`:
   - Multiple goroutines calling GetKey
   - Multiple goroutines calling UpdateKeyFromHeaders
   - No race conditions (run with -race)
   - Fair distribution under load

Create test helpers:
- `newTestPool(numKeys int, strategy string)` - Creates pool for testing
- `newTestHeaders(rpm, remaining int, reset time.Time)` - Creates mock headers
  </action>
  <verify>
```bash
go test -race -v ./internal/keypool/...
```
  </verify>
  <done>All tests pass including race detector, pool correctly coordinates rate limiting</done>
</task>

</tasks>

<verification>
```bash
# Build passes
go build ./internal/keypool/...

# Tests pass with race detector
go test -race -v ./internal/keypool/...

# All packages vet clean
go vet ./internal/keypool/... ./internal/ratelimit/...

# Lint passes
golangci-lint run ./internal/keypool/... ./internal/ratelimit/...
```
</verification>

<success_criteria>
1. KeyPool.GetKey selects best available key using configured strategy
2. KeyPool.GetKey respects rate limits (returns error when exceeded)
3. KeyPool.UpdateKeyFromHeaders updates key state from Anthropic headers
4. KeyPool.MarkKeyExhausted sets cooldown period
5. Pool is thread-safe for concurrent GetKey and Update calls
6. GetEarliestResetTime returns duration for 429 retry-after header
7. All tests pass including race detector
</success_criteria>

<output>
After completion, create `.planning/phases/02-multi-key-pooling/02-03-SUMMARY.md`
</output>
