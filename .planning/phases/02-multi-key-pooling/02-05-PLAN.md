---
phase: 02-multi-key-pooling
plan: 05
type: execute
wave: 3
depends_on: ["02-03", "02-04"]
files_modified:
  - internal/proxy/handler.go
  - internal/proxy/handler_test.go
  - internal/proxy/errors.go
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Handler uses KeyPool to select API key for each request"
    - "Handler updates key state from response headers"
    - "Handler returns 429 with retry-after when all keys exhausted"
    - "429 response matches Anthropic error format"
    - "x-cc-relay-* headers expose capacity information"
  artifacts:
    - path: "internal/proxy/handler.go"
      provides: "Handler integrated with KeyPool"
      contains: "keyPool"
    - path: "internal/proxy/handler_test.go"
      provides: "Tests for key pool integration"
      min_lines: 50
    - path: "internal/proxy/errors.go"
      provides: "Rate limit error response helper"
      contains: "WriteRateLimitError"
  key_links:
    - from: "internal/proxy/handler.go"
      to: "internal/keypool/pool.go"
      via: "KeyPool.GetKey() call in ServeHTTP"
      pattern: "keyPool\\.GetKey"
    - from: "internal/proxy/handler.go"
      to: "internal/keypool/pool.go"
      via: "KeyPool.UpdateKeyFromHeaders() in response handler"
      pattern: "UpdateKeyFromHeaders"
---

<objective>
Integrate KeyPool with proxy handler for multi-key routing.

Purpose: Connect the rate limiting and key selection infrastructure to the actual HTTP proxy handler. Requests will be routed through the key pool, and responses will update key state.

Output:
- Updated `internal/proxy/handler.go` with KeyPool integration
- Updated `internal/proxy/handler_test.go` with pool tests
- Extended `internal/proxy/errors.go` with 429 helper
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-multi-key-pooling/02-RESEARCH.md
@.planning/phases/02-multi-key-pooling/02-CONTEXT.md
@.planning/phases/02-multi-key-pooling/02-03-SUMMARY.md
@.planning/phases/02-multi-key-pooling/02-04-SUMMARY.md
@internal/proxy/handler.go
@internal/proxy/errors.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add 429 rate limit error helper</name>
  <files>internal/proxy/errors.go</files>
  <action>
Update `internal/proxy/errors.go` to add rate limit error response:

1. Add WriteRateLimitError function:
   ```go
   // WriteRateLimitError writes a 429 Too Many Requests response in Anthropic format.
   // The retryAfter parameter specifies when capacity will be available.
   func WriteRateLimitError(w http.ResponseWriter, retryAfter time.Duration) {
       // Set Retry-After header (RFC 6585)
       seconds := int(retryAfter.Seconds())
       if seconds < 1 {
           seconds = 1  // Minimum 1 second
       }
       w.Header().Set("Retry-After", strconv.Itoa(seconds))

       WriteError(w, http.StatusTooManyRequests, ErrorResponse{
           Type: "error",
           Error: ErrorDetail{
               Type:    "rate_limit_error",
               Message: "All API keys are currently at rate limit capacity. Please retry after the specified time.",
           },
       })
   }
   ```

2. Add constants for x-cc-relay-* headers:
   ```go
   const (
       HeaderRelayKeyID       = "X-CC-Relay-Key-ID"        // Selected key ID (first 8 chars)
       HeaderRelayCapacity    = "X-CC-Relay-Capacity"      // Remaining capacity %
       HeaderRelayKeysTotal   = "X-CC-Relay-Keys-Total"    // Total keys in pool
       HeaderRelayKeysAvail   = "X-CC-Relay-Keys-Available" // Available keys
   )
   ```

3. Ensure WriteRateLimitError logs at Warn level with retryAfter duration.
  </action>
  <verify>
```bash
go build ./internal/proxy/...
```
  </verify>
  <done>WriteRateLimitError compiles and follows Anthropic error format</done>
</task>

<task type="auto">
  <name>Task 2: Integrate KeyPool into Handler</name>
  <files>internal/proxy/handler.go</files>
  <action>
Update `internal/proxy/handler.go` to use KeyPool:

1. Update Handler struct:
   ```go
   type Handler struct {
       provider  providers.Provider
       proxy     *httputil.ReverseProxy
       keyPool   *keypool.KeyPool    // NEW: Key pool for multi-key routing
       apiKey    string              // Kept for backwards compatibility (single key)
       debugOpts config.DebugOptions
   }
   ```

2. Update NewHandler signature:
   ```go
   // NewHandler creates a new proxy handler.
   // If pool is provided, it will be used for key selection.
   // If pool is nil, apiKey is used directly (single key mode).
   func NewHandler(
       provider providers.Provider,
       apiKey string,
       pool *keypool.KeyPool,  // NEW parameter (can be nil)
       debugOpts config.DebugOptions,
   ) (*Handler, error)
   ```

3. Update key selection in ServeHTTP:
   ```go
   func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
       // ... existing start/logger code ...

       // Select API key
       var selectedKey string
       var keyID string

       if h.keyPool != nil {
           var err error
           keyID, selectedKey, err = h.keyPool.GetKey(r.Context())
           if errors.Is(err, keypool.ErrAllKeysExhausted) {
               retryAfter := h.keyPool.GetEarliestResetTime()
               WriteRateLimitError(w, retryAfter)
               logger.Warn().
                   Dur("retry_after", retryAfter).
                   Msg("all keys exhausted, returning 429")
               return
           }
           if err != nil {
               WriteError(w, http.StatusInternalServerError, ...)
               return
           }

           // Add relay headers
           w.Header().Set(HeaderRelayKeyID, keyID)
           stats := h.keyPool.GetStats()
           w.Header().Set(HeaderRelayKeysTotal, strconv.Itoa(stats.TotalKeys))
           w.Header().Set(HeaderRelayKeysAvail, strconv.Itoa(stats.AvailableKeys))
       } else {
           selectedKey = h.apiKey  // Single key mode
       }

       // Use selectedKey for authentication
       // ... rest of handler ...
   }
   ```

4. Add response header interception in ReverseProxy.ModifyResponse:
   ```go
   h.proxy = &httputil.ReverseProxy{
       // ... existing Rewrite ...
       ModifyResponse: func(resp *http.Response) error {
           // Update key pool from rate limit headers
           if h.keyPool != nil && keyID != "" {
               if err := h.keyPool.UpdateKeyFromHeaders(keyID, resp.Header); err != nil {
                   logger.Debug().Err(err).Msg("failed to update key from headers")
               }

               // Handle 429 from backend
               if resp.StatusCode == http.StatusTooManyRequests {
                   retryAfter := parseRetryAfter(resp.Header)
                   h.keyPool.MarkKeyExhausted(keyID, retryAfter)
                   logger.Warn().
                       Str("key_id", keyID).
                       Dur("cooldown", retryAfter).
                       Msg("key hit rate limit, marking cooldown")
               }
           }
           return nil
       },
       // ... existing ErrorHandler ...
   }
   ```

5. Add helper to parse Retry-After header:
   ```go
   func parseRetryAfter(headers http.Header) time.Duration {
       val := headers.Get("Retry-After")
       if val == "" {
           return 60 * time.Second  // Default 1 minute
       }
       // Try seconds format
       if seconds, err := strconv.Atoi(val); err == nil {
           return time.Duration(seconds) * time.Second
       }
       // Try HTTP-date format
       if t, err := http.ParseTime(val); err == nil {
           return time.Until(t)
       }
       return 60 * time.Second
   }
   ```

6. Store keyID in request context for ModifyResponse access:
   ```go
   type contextKey string
   const keyIDContextKey contextKey = "keyID"

   // In ServeHTTP after GetKey:
   r = r.WithContext(context.WithValue(r.Context(), keyIDContextKey, keyID))

   // In ModifyResponse:
   keyID, _ := resp.Request.Context().Value(keyIDContextKey).(string)
   ```

Note: Keep h.apiKey for backwards compatibility with single-key mode.
  </action>
  <verify>
```bash
go build ./internal/proxy/...
```
  </verify>
  <done>Handler compiles with KeyPool integration</done>
</task>

<task type="auto">
  <name>Task 3: Add handler tests for key pool integration</name>
  <files>internal/proxy/handler_test.go</files>
  <action>
Add tests to `internal/proxy/handler_test.go`:

1. `TestHandler_WithKeyPool`:
   - Create handler with mock key pool
   - Verify GetKey is called on request
   - Verify correct key is used for authentication
   - Verify x-cc-relay-* headers are set in response

2. `TestHandler_AllKeysExhausted`:
   - Create pool where all keys are exhausted
   - Verify 429 response with Retry-After header
   - Verify response body matches Anthropic error format
   - Verify error type is "rate_limit_error"

3. `TestHandler_KeyPoolUpdate`:
   - Mock backend returns rate limit headers
   - Verify UpdateKeyFromHeaders is called
   - Verify key state is updated

4. `TestHandler_Backend429`:
   - Mock backend returns 429
   - Verify MarkKeyExhausted is called
   - Verify Retry-After is parsed correctly

5. `TestHandler_SingleKeyMode`:
   - Create handler with nil pool
   - Verify apiKey is used directly (backwards compatible)
   - No x-cc-relay-* headers in response

6. `TestParseRetryAfter`:
   - Parses integer seconds "60" -> 60s
   - Parses HTTP-date format
   - Returns 60s default for missing header
   - Returns 60s default for invalid format

Create mock KeyPool for testing:
```go
type mockKeyPool struct {
    getKeyFunc    func(ctx context.Context) (string, string, error)
    updateFunc    func(keyID string, headers http.Header) error
    exhaustedFunc func(keyID string, retryAfter time.Duration)
    resetTimeFunc func() time.Duration
    statsFunc     func() keypool.PoolStats
}
```

Or use actual KeyPool with controlled configuration.
  </action>
  <verify>
```bash
go test -race -v ./internal/proxy/... -run "KeyPool|Exhausted|Backend429|SingleKey|RetryAfter"
```
  </verify>
  <done>All handler tests pass including key pool integration</done>
</task>

</tasks>

<verification>
```bash
# Build passes
go build ./internal/proxy/...

# All proxy tests pass
go test -race -v ./internal/proxy/...

# All packages vet clean
go vet ./internal/proxy/... ./internal/keypool/... ./internal/ratelimit/...

# Lint passes
golangci-lint run ./internal/proxy/... ./internal/keypool/... ./internal/ratelimit/...

# Full test suite
go test -race ./...
```
</verification>

<success_criteria>
1. Handler uses KeyPool.GetKey() when pool is configured
2. Handler returns 429 with Retry-After when all keys exhausted
3. 429 response matches Anthropic error format (type: rate_limit_error)
4. x-cc-relay-* headers expose key ID and capacity info
5. Handler updates key state from response headers
6. Handler marks key exhausted when backend returns 429
7. Single-key mode (nil pool) works for backwards compatibility
8. All tests pass including race detector
</success_criteria>

<output>
After completion, create `.planning/phases/02-multi-key-pooling/02-05-SUMMARY.md`
</output>
