---
phase: 02-multi-key-pooling
plan: 04
type: execute
wave: 2
depends_on: ["02-02"]
files_modified:
  - internal/config/config.go
  - internal/config/config_test.go
  - config/example.yaml
autonomous: true
user_setup: []

must_haves:
  truths:
    - "ProviderConfig.Keys is an array of KeyConfig structs"
    - "KeyConfig includes key, rpm_limit, tpm_limit, priority, weight fields"
    - "Rate limits are optional (default to 0 = unlimited/learn from headers)"
    - "Selection strategy is configurable per provider with global default"
    - "Example config demonstrates multi-key pooling"
  artifacts:
    - path: "internal/config/config.go"
      provides: "Extended KeyConfig with rate limits and priority"
      contains: "Priority int"
    - path: "internal/config/config_test.go"
      provides: "Tests for new config fields"
      min_lines: 20
    - path: "config/example.yaml"
      provides: "Example multi-key configuration"
      contains: "keys:"
  key_links:
    - from: "internal/config/config.go"
      to: "internal/keypool/pool.go"
      via: "KeyConfig struct used by keypool.PoolConfig"
      pattern: "KeyConfig"
---

<objective>
Extend configuration to support multiple keys per provider with rate limits.

Purpose: Enable users to configure multiple API keys with optional rate limits. Keys work without specifying limits (learn from headers), but can be configured for predictable behavior.

Output:
- Extended `internal/config/config.go` with new KeyConfig fields
- Updated `internal/config/config_test.go` with tests for new fields
- Updated `config/example.yaml` demonstrating multi-key config
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-multi-key-pooling/02-RESEARCH.md
@.planning/phases/02-multi-key-pooling/02-CONTEXT.md
@internal/config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend config structs for multi-key pooling</name>
  <files>internal/config/config.go</files>
  <action>
Update `internal/config/config.go`:

1. Extend KeyConfig struct (currently has Key, RPMLimit, TPMLimit):
   ```go
   // KeyConfig defines an API key with rate limits and selection metadata.
   type KeyConfig struct {
       Key       string `yaml:"key"`         // API key value (supports ${ENV_VAR})
       RPMLimit  int    `yaml:"rpm_limit"`   // Requests per minute (0 = unlimited/learn)
       ITPMLimit int    `yaml:"itpm_limit"`  // Input tokens per minute (0 = unlimited/learn)
       OTPMLimit int    `yaml:"otpm_limit"`  // Output tokens per minute (0 = unlimited/learn)
       Priority  int    `yaml:"priority"`    // Selection priority: 0=low, 1=normal (default), 2=high
       Weight    int    `yaml:"weight"`      // For weighted selection strategy (default: 1)

       // Deprecated: Use ITPMLimit + OTPMLimit instead
       TPMLimit int `yaml:"tpm_limit"`
   }
   ```

2. Add method to KeyConfig for TPM backwards compatibility:
   ```go
   // GetEffectiveTPM returns the combined TPM limit for backwards compatibility.
   // Prefers ITPMLimit + OTPMLimit if set, falls back to TPMLimit.
   func (k *KeyConfig) GetEffectiveTPM() (itpm, otpm int) {
       if k.ITPMLimit > 0 || k.OTPMLimit > 0 {
           return k.ITPMLimit, k.OTPMLimit
       }
       // Legacy: split TPMLimit equally between input/output
       if k.TPMLimit > 0 {
           return k.TPMLimit / 2, k.TPMLimit / 2
       }
       return 0, 0
   }
   ```

3. Add PoolingConfig to ProviderConfig:
   ```go
   type ProviderConfig struct {
       // ... existing fields ...
       Keys         []KeyConfig   `yaml:"keys"`
       Pooling      PoolingConfig `yaml:"pooling"`  // NEW
   }

   // PoolingConfig defines key pool behavior for a provider.
   type PoolingConfig struct {
       Strategy string `yaml:"strategy"` // least_loaded (default), round_robin, random, weighted
       Enabled  bool   `yaml:"enabled"`  // Enable pooling (default: true if multiple keys)
   }
   ```

4. Add method to ProviderConfig:
   ```go
   // GetEffectiveStrategy returns the selection strategy with default fallback.
   func (p *ProviderConfig) GetEffectiveStrategy() string {
       if p.Pooling.Strategy != "" {
           return p.Pooling.Strategy
       }
       return "least_loaded"  // Default strategy
   }

   // IsPoolingEnabled returns true if key pooling should be used.
   func (p *ProviderConfig) IsPoolingEnabled() bool {
       // Explicit setting takes precedence
       if p.Pooling.Enabled {
           return true
       }
       // Default: enable if multiple keys
       return len(p.Keys) > 1
   }
   ```

5. Add validation for KeyConfig in a Validate method:
   ```go
   // Validate checks KeyConfig for errors.
   func (k *KeyConfig) Validate() error {
       if k.Key == "" {
           return errors.New("config: key is required")
       }
       if k.Priority < 0 || k.Priority > 2 {
           return fmt.Errorf("config: priority must be 0-2, got %d", k.Priority)
       }
       if k.Weight < 0 {
           return fmt.Errorf("config: weight must be >= 0, got %d", k.Weight)
       }
       return nil
   }
   ```
  </action>
  <verify>
```bash
go build ./internal/config/...
```
  </verify>
  <done>Config structs compile with new fields for multi-key pooling</done>
</task>

<task type="auto">
  <name>Task 2: Add tests for new config fields</name>
  <files>internal/config/config_test.go</files>
  <action>
Add tests to `internal/config/config_test.go`:

1. `TestKeyConfig_GetEffectiveTPM`:
   - Returns ITPM/OTPM when set
   - Returns split TPMLimit when legacy field used
   - Returns 0, 0 when no limits set

2. `TestKeyConfig_Validate`:
   - Valid key passes
   - Empty key fails
   - Invalid priority (3) fails
   - Negative weight fails

3. `TestProviderConfig_GetEffectiveStrategy`:
   - Returns configured strategy
   - Returns "least_loaded" when not set

4. `TestProviderConfig_IsPoolingEnabled`:
   - Returns true when explicitly enabled
   - Returns true when multiple keys
   - Returns false when single key and not enabled

5. `TestLoadConfig_MultiKey` (integration):
   - Load config with multiple keys
   - Verify all key fields parsed correctly
   - Verify pooling config parsed

Example test YAML:
```yaml
providers:
  - name: anthropic
    type: anthropic
    base_url: https://api.anthropic.com
    pooling:
      strategy: least_loaded
    keys:
      - key: ${ANTHROPIC_KEY_1}
        rpm_limit: 50
        itpm_limit: 30000
        otpm_limit: 10000
        priority: 2
      - key: ${ANTHROPIC_KEY_2}
        rpm_limit: 50
        priority: 1
```
  </action>
  <verify>
```bash
go test -v ./internal/config/... -run "KeyConfig|ProviderConfig|MultiKey"
```
  </verify>
  <done>All new config tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Update example config with multi-key pooling</name>
  <files>config/example.yaml</files>
  <action>
Update `config/example.yaml` to demonstrate multi-key pooling:

1. Add comprehensive example under anthropic provider:
   ```yaml
   providers:
     - name: anthropic
       type: anthropic
       base_url: https://api.anthropic.com
       enabled: true
       models:
         - claude-sonnet-4-20250514
         - claude-opus-4-20250514

       # Multi-key pooling configuration
       pooling:
         strategy: least_loaded  # Options: least_loaded, round_robin, random, weighted
         # enabled: true  # Implicit when multiple keys

       # Multiple API keys for rate limit pooling
       keys:
         # Primary key (high priority)
         - key: ${ANTHROPIC_API_KEY}
           rpm_limit: 50          # Requests per minute (0 = learn from headers)
           itpm_limit: 30000      # Input tokens per minute
           otpm_limit: 10000      # Output tokens per minute
           priority: 2            # 0=low, 1=normal, 2=high

         # Secondary key (normal priority)
         - key: ${ANTHROPIC_API_KEY_2}
           rpm_limit: 50
           priority: 1

         # Backup key (low priority, no limits = learn from headers)
         - key: ${ANTHROPIC_API_KEY_3}
           priority: 0
   ```

2. Add comments explaining:
   - Rate limits are optional (0 = unlimited, learn from response headers)
   - Priority affects selection when multiple keys have capacity
   - Strategy options and when to use each
   - Environment variable expansion with ${VAR}

3. Add simpler single-key example for users who don't need pooling:
   ```yaml
     # Single key example (pooling not used)
     - name: anthropic-simple
       type: anthropic
       base_url: https://api.anthropic.com
       keys:
         - key: ${ANTHROPIC_API_KEY}
   ```

4. Ensure existing config structure remains valid (backwards compatible).
  </action>
  <verify>
```bash
# Validate YAML syntax
python3 -c "import yaml; yaml.safe_load(open('config/example.yaml'))"

# Build still works
go build ./...
```
  </verify>
  <done>Example config demonstrates multi-key pooling with clear documentation</done>
</task>

</tasks>

<verification>
```bash
# Build passes
go build ./internal/config/...

# Config tests pass
go test -v ./internal/config/...

# Example YAML is valid
python3 -c "import yaml; yaml.safe_load(open('config/example.yaml'))"

# Lint passes
golangci-lint run ./internal/config/...
```
</verification>

<success_criteria>
1. KeyConfig has rpm_limit, itpm_limit, otpm_limit, priority, weight fields
2. KeyConfig.Validate() rejects invalid configurations
3. ProviderConfig.GetEffectiveStrategy() returns strategy with default
4. Backwards compatible (tpm_limit still works via GetEffectiveTPM)
5. Example config demonstrates multi-key pooling clearly
6. All config tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-multi-key-pooling/02-04-SUMMARY.md`
</output>
