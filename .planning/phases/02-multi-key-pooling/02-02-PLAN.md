---
phase: 02-multi-key-pooling
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/keypool/key.go
  - internal/keypool/selector.go
  - internal/keypool/least_loaded.go
  - internal/keypool/round_robin.go
  - internal/keypool/selector_test.go
autonomous: true
user_setup: []

must_haves:
  truths:
    - "KeyMetadata struct tracks API key, limits, remaining capacity, and reset times"
    - "KeySelector interface defines Select method for choosing keys"
    - "Least-loaded selector picks key with most remaining capacity"
    - "Round-robin selector cycles through keys in order"
    - "Selectors skip unhealthy keys"
  artifacts:
    - path: "internal/keypool/key.go"
      provides: "KeyMetadata struct with rate limit tracking"
      exports: ["KeyMetadata", "NewKeyMetadata"]
    - path: "internal/keypool/selector.go"
      provides: "KeySelector interface and errors"
      exports: ["KeySelector", "ErrAllKeysExhausted"]
    - path: "internal/keypool/least_loaded.go"
      provides: "Least-loaded selection strategy"
      exports: ["NewLeastLoadedSelector"]
    - path: "internal/keypool/round_robin.go"
      provides: "Round-robin selection strategy"
      exports: ["NewRoundRobinSelector"]
    - path: "internal/keypool/selector_test.go"
      provides: "Unit tests for selectors"
      min_lines: 80
  key_links:
    - from: "internal/keypool/least_loaded.go"
      to: "internal/keypool/key.go"
      via: "KeyMetadata.GetCapacityScore()"
      pattern: "GetCapacityScore"
---

<objective>
Create key metadata struct and pluggable key selector interface with two strategies.

Purpose: Enable intelligent key selection based on remaining capacity (least-loaded) or fair distribution (round-robin). This decouples selection strategy from pool management.

Output:
- `internal/keypool/key.go` - KeyMetadata struct
- `internal/keypool/selector.go` - KeySelector interface
- `internal/keypool/least_loaded.go` - Least-loaded strategy
- `internal/keypool/round_robin.go` - Round-robin strategy
- `internal/keypool/selector_test.go` - Unit tests
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-multi-key-pooling/02-RESEARCH.md
@.planning/phases/02-multi-key-pooling/02-CONTEXT.md
@internal/cache/cache.go (for interface pattern reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create KeyMetadata struct</name>
  <files>internal/keypool/key.go</files>
  <action>
Create `internal/keypool/key.go` with:

1. Package declaration: `package keypool`

2. KeyMetadata struct tracking all rate limit state:
   ```go
   type KeyMetadata struct {
       // Identity
       ID      string  // Unique identifier (first 8 chars of key hash)
       APIKey  string  // The actual API key

       // Configured limits (from config or learned from headers)
       RPMLimit  int  // Requests per minute limit
       ITPMLimit int  // Input tokens per minute limit
       OTPMLimit int  // Output tokens per minute limit

       // Current state (updated from response headers)
       RPMRemaining  int        // Remaining requests this window
       ITPMRemaining int        // Remaining input tokens
       OTPMRemaining int        // Remaining output tokens
       RPMResetAt    time.Time  // When RPM resets
       ITPMResetAt   time.Time  // When ITPM resets
       OTPMResetAt   time.Time  // When OTPM resets

       // Health state
       Healthy       bool       // Whether key is usable
       LastError     error      // Last error encountered
       LastErrorAt   time.Time  // When last error occurred
       CooldownUntil time.Time  // Don't use until this time (429 retry-after)

       // Priority (from config)
       Priority int  // 0=low, 1=normal (default), 2=high
       Weight   int  // For weighted selection strategy

       mu sync.RWMutex
   }
   ```

3. Constructor `NewKeyMetadata(apiKey string, rpm, itpm, otpm int) *KeyMetadata`:
   - Generate ID from first 8 chars of SHA-256 hash of key
   - Set limits from parameters
   - Initialize remaining = limit (full capacity)
   - Set Healthy = true, Priority = 1 (normal)

4. Methods:
   - `GetCapacityScore() float64` - Returns 0-1 score (higher = more capacity)
     - Score = (rpmRemaining/rpmLimit + tpmRemaining/tpmLimit) / 2
     - Returns 0 if unhealthy or in cooldown
   - `IsAvailable() bool` - Returns true if healthy and not in cooldown
   - `UpdateFromHeaders(headers http.Header) error` - Parse anthropic-ratelimit-* headers
   - `SetCooldown(until time.Time)` - Mark key as cooling down (after 429)
   - `MarkUnhealthy(err error)` - Set Healthy=false with error
   - `MarkHealthy()` - Set Healthy=true, clear error

5. Header parsing in UpdateFromHeaders (from research):
   - `anthropic-ratelimit-requests-limit` -> RPMLimit
   - `anthropic-ratelimit-requests-remaining` -> RPMRemaining
   - `anthropic-ratelimit-requests-reset` -> RPMResetAt (RFC3339)
   - `anthropic-ratelimit-input-tokens-limit` -> ITPMLimit
   - `anthropic-ratelimit-input-tokens-remaining` -> ITPMRemaining
   - `anthropic-ratelimit-output-tokens-limit` -> OTPMLimit
   - `anthropic-ratelimit-output-tokens-remaining` -> OTPMRemaining

All methods must be thread-safe using mu.RLock/Lock.
  </action>
  <verify>
```bash
go build ./internal/keypool/...
```
  </verify>
  <done>KeyMetadata struct compiles with all rate limit tracking fields and thread-safe methods</done>
</task>

<task type="auto">
  <name>Task 2: Create KeySelector interface and implementations</name>
  <files>internal/keypool/selector.go, internal/keypool/least_loaded.go, internal/keypool/round_robin.go</files>
  <action>
Create three files:

**internal/keypool/selector.go:**

1. KeySelector interface:
   ```go
   type KeySelector interface {
       // Select chooses a key from the pool based on strategy.
       // Returns ErrAllKeysExhausted if no keys are available.
       Select(keys []*KeyMetadata) (*KeyMetadata, error)

       // Name returns the strategy name for logging/config.
       Name() string
   }
   ```

2. Error variables:
   - `ErrAllKeysExhausted = errors.New("keypool: all keys exhausted")`
   - `ErrNoKeys = errors.New("keypool: no keys configured")`

3. Strategy constants:
   ```go
   const (
       StrategyLeastLoaded = "least_loaded"
       StrategyRoundRobin  = "round_robin"
       StrategyRandom      = "random"
       StrategyWeighted    = "weighted"
   )
   ```

4. Factory function:
   ```go
   func NewSelector(strategy string) (KeySelector, error) {
       switch strategy {
       case StrategyLeastLoaded, "":  // Default
           return NewLeastLoadedSelector(), nil
       case StrategyRoundRobin:
           return NewRoundRobinSelector(), nil
       default:
           return nil, fmt.Errorf("keypool: unknown strategy %q", strategy)
       }
   }
   ```

**internal/keypool/least_loaded.go:**

1. LeastLoadedSelector struct (stateless):
   ```go
   type LeastLoadedSelector struct{}
   ```

2. `NewLeastLoadedSelector() *LeastLoadedSelector`

3. `Select(keys []*KeyMetadata) (*KeyMetadata, error)`:
   - Iterate through keys
   - Skip unavailable keys (IsAvailable() == false)
   - Track key with highest GetCapacityScore()
   - Return best key or ErrAllKeysExhausted if none available

4. `Name() string` returns "least_loaded"

**internal/keypool/round_robin.go:**

1. RoundRobinSelector struct (stateful):
   ```go
   type RoundRobinSelector struct {
       index uint64  // atomic counter
   }
   ```

2. `NewRoundRobinSelector() *RoundRobinSelector`

3. `Select(keys []*KeyMetadata) (*KeyMetadata, error)`:
   - Use atomic.AddUint64 to get next index
   - Start from index, wrap around, find first available key
   - Return ErrAllKeysExhausted if full loop with no available keys

4. `Name() string` returns "round_robin"

Use sync/atomic for round-robin index to avoid mutex overhead.
  </action>
  <verify>
```bash
go build ./internal/keypool/...
```
  </verify>
  <done>KeySelector interface and two strategies compile and implement the interface correctly</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for key metadata and selectors</name>
  <files>internal/keypool/selector_test.go</files>
  <action>
Create `internal/keypool/selector_test.go` with tests:

**KeyMetadata tests:**

1. `TestNewKeyMetadata`:
   - Creates metadata with correct limits
   - ID is 8 char hex string
   - Starts healthy with full capacity

2. `TestGetCapacityScore`:
   - Returns 1.0 when at full capacity
   - Returns 0.5 when at half capacity
   - Returns 0.0 when unhealthy
   - Returns 0.0 when in cooldown

3. `TestIsAvailable`:
   - Returns true when healthy and not in cooldown
   - Returns false when unhealthy
   - Returns false when in cooldown
   - Returns true after cooldown expires

4. `TestUpdateFromHeaders`:
   - Parses all anthropic-ratelimit-* headers correctly
   - Handles missing headers gracefully
   - Parses RFC3339 reset times
   - Validates parsed values (no negative limits)

5. `TestSetCooldown`:
   - Sets cooldown time
   - IsAvailable returns false during cooldown

**Selector tests:**

6. `TestLeastLoadedSelector`:
   - Selects key with most capacity
   - Skips unhealthy keys
   - Skips keys in cooldown
   - Returns error when all keys exhausted

7. `TestRoundRobinSelector`:
   - Cycles through keys in order
   - Skips unavailable keys
   - Wraps around correctly
   - Returns error when all keys exhausted
   - Thread-safe (concurrent selects)

8. `TestNewSelector`:
   - Creates correct selector for each strategy name
   - Returns error for unknown strategy
   - Defaults to least_loaded when empty string

Use table-driven tests. Create helper function to build test keys with specific capacities.
  </action>
  <verify>
```bash
go test -race -v ./internal/keypool/...
```
  </verify>
  <done>All tests pass including race detector, selectors correctly implement strategies</done>
</task>

</tasks>

<verification>
```bash
# Build passes
go build ./internal/keypool/...

# Tests pass with race detector
go test -race -v ./internal/keypool/...

# Interface is implemented correctly
go vet ./internal/keypool/...

# Lint passes
golangci-lint run ./internal/keypool/...
```
</verification>

<success_criteria>
1. KeyMetadata struct tracks all rate limit state (RPM, ITPM, OTPM, reset times)
2. KeyMetadata.UpdateFromHeaders parses Anthropic response headers correctly
3. KeySelector interface exists with Select and Name methods
4. LeastLoadedSelector picks key with highest capacity score
5. RoundRobinSelector cycles through available keys fairly
6. Both selectors skip unhealthy/cooldown keys
7. All tests pass including race detector
</success_criteria>

<output>
After completion, create `.planning/phases/02-multi-key-pooling/02-02-SUMMARY.md`
</output>
