---
phase: 02-multi-key-pooling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/ratelimit/limiter.go
  - internal/ratelimit/token_bucket.go
  - internal/ratelimit/token_bucket_test.go
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Rate limiter interface exists with Allow, Wait, SetLimit, GetUsage methods"
    - "Token bucket implementation tracks RPM (requests per minute)"
    - "Token bucket implementation tracks TPM (tokens per minute)"
    - "Rate limiter allows requests when under limit"
    - "Rate limiter blocks requests when at capacity"
  artifacts:
    - path: "internal/ratelimit/limiter.go"
      provides: "RateLimiter interface definition"
      exports: ["RateLimiter"]
    - path: "internal/ratelimit/token_bucket.go"
      provides: "Token bucket implementation using golang.org/x/time/rate"
      exports: ["NewTokenBucketLimiter"]
    - path: "internal/ratelimit/token_bucket_test.go"
      provides: "Unit tests for token bucket"
      min_lines: 50
  key_links:
    - from: "internal/ratelimit/token_bucket.go"
      to: "golang.org/x/time/rate"
      via: "rate.NewLimiter import"
      pattern: "rate\\.NewLimiter"
---

<objective>
Create the rate limiter interface and token bucket implementation.

Purpose: Foundation for per-key rate limiting that tracks RPM and TPM limits using the battle-tested golang.org/x/time/rate library.

Output:
- `internal/ratelimit/limiter.go` - RateLimiter interface
- `internal/ratelimit/token_bucket.go` - Token bucket implementation
- `internal/ratelimit/token_bucket_test.go` - Unit tests
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-multi-key-pooling/02-RESEARCH.md
@.planning/phases/02-multi-key-pooling/02-CONTEXT.md
@internal/cache/cache.go (for interface pattern reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RateLimiter interface</name>
  <files>internal/ratelimit/limiter.go</files>
  <action>
Create `internal/ratelimit/limiter.go` with:

1. Package declaration: `package ratelimit`

2. RateLimiter interface with methods:
   - `Allow(ctx context.Context) bool` - Check if request is allowed (non-blocking)
   - `Wait(ctx context.Context) error` - Block until request is allowed or context cancelled
   - `SetLimit(rpm, tpm int)` - Update rate limits dynamically (for header updates)
   - `GetUsage() (requestsUsed, tokensUsed int)` - Report current usage for key selection
   - `Reserve(tokens int) bool` - Reserve tokens for upcoming request (non-blocking)
   - `ConsumeTokens(ctx context.Context, tokens int) error` - Record actual token usage after response

3. Usage struct to return from GetUsage:
   ```go
   type Usage struct {
       RequestsUsed     int
       RequestsLimit    int
       TokensUsed       int
       TokensLimit      int
       RequestsRemaining int
       TokensRemaining   int
   }
   ```

4. Error variables:
   - `ErrRateLimitExceeded = errors.New("ratelimit: rate limit exceeded")`
   - `ErrContextCancelled = errors.New("ratelimit: context cancelled")`

Follow the pattern from `internal/cache/cache.go` - simple interface with clear method contracts.
  </action>
  <verify>
```bash
go build ./internal/ratelimit/...
```
  </verify>
  <done>RateLimiter interface compiles and defines all required methods for rate limiting</done>
</task>

<task type="auto">
  <name>Task 2: Implement token bucket rate limiter</name>
  <files>internal/ratelimit/token_bucket.go</files>
  <action>
Create `internal/ratelimit/token_bucket.go` with:

1. First run: `go get golang.org/x/time/rate`

2. TokenBucketLimiter struct:
   ```go
   type TokenBucketLimiter struct {
       requestLimiter *rate.Limiter  // RPM tracking
       tokenLimiter   *rate.Limiter  // TPM tracking
       rpmLimit       int
       tpmLimit       int
       mu             sync.Mutex
   }
   ```

3. Constructor `NewTokenBucketLimiter(rpm, tpm int) *TokenBucketLimiter`:
   - Convert per-minute to per-second: `rate.Limit(rpm/60.0)`
   - Set burst = limit (allows full minute's worth instantly, then refills)
   - Handle zero/negative values gracefully (unlimited = very high limit like 1_000_000)

4. Implement interface methods:
   - `Allow()`: Check `requestLimiter.Allow()` (non-blocking)
   - `Wait()`: Use `requestLimiter.Wait(ctx)` (blocking with context)
   - `SetLimit()`: Lock mutex, create new limiters with updated rates
   - `GetUsage()`: Return Usage struct with current state
   - `Reserve()`: Check if tokens available without consuming
   - `ConsumeTokens()`: Use `tokenLimiter.WaitN(ctx, tokens)`

5. Key implementation details from research:
   - Burst = limit (Pitfall 1: prevents legitimate burst rejection)
   - Use RWMutex for GetUsage (read-heavy), Mutex for SetLimit (writes)
   - rate.Limiter is already concurrent-safe internally
  </action>
  <verify>
```bash
go build ./internal/ratelimit/...
```
  </verify>
  <done>TokenBucketLimiter implements RateLimiter interface with golang.org/x/time/rate</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for token bucket</name>
  <files>internal/ratelimit/token_bucket_test.go</files>
  <action>
Create `internal/ratelimit/token_bucket_test.go` with tests:

1. `TestNewTokenBucketLimiter`:
   - Creates limiter with valid RPM/TPM
   - Handles zero values (becomes unlimited)

2. `TestAllow`:
   - Returns true when under limit
   - Returns false when at capacity
   - Respects RPM limit (burst then block)

3. `TestWait`:
   - Blocks until capacity available
   - Respects context cancellation
   - Returns error on context deadline

4. `TestSetLimit`:
   - Updates limits dynamically
   - New limit takes effect immediately
   - Thread-safe (test with goroutines)

5. `TestGetUsage`:
   - Returns correct remaining capacity
   - Updates after Allow/ConsumeTokens calls

6. `TestConsumeTokens`:
   - Records token usage correctly
   - Blocks if over TPM limit
   - Respects context cancellation

7. `TestConcurrency`:
   - Multiple goroutines calling Allow/Wait
   - No race conditions (run with -race)

Use table-driven tests where appropriate. Use short timeouts (100ms) for blocking tests.
  </action>
  <verify>
```bash
go test -race -v ./internal/ratelimit/...
```
  </verify>
  <done>All tests pass including race detector, token bucket correctly limits RPM and TPM</done>
</task>

</tasks>

<verification>
```bash
# Build passes
go build ./internal/ratelimit/...

# Tests pass with race detector
go test -race -v ./internal/ratelimit/...

# Interface is implemented correctly
go vet ./internal/ratelimit/...

# Lint passes
golangci-lint run ./internal/ratelimit/...
```
</verification>

<success_criteria>
1. RateLimiter interface exists with all specified methods
2. TokenBucketLimiter implements RateLimiter interface
3. Token bucket tracks RPM using golang.org/x/time/rate
4. Token bucket tracks TPM using separate limiter
5. All tests pass including race detector
6. SetLimit allows dynamic updates (for response header learning)
</success_criteria>

<output>
After completion, create `.planning/phases/02-multi-key-pooling/02-01-SUMMARY.md`
</output>
