---
phase: 02-multi-key-pooling
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - cmd/cc-relay/serve.go
  - internal/proxy/routes.go
  - internal/proxy/keypool_integration_test.go
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "KeyPool is initialized from config.Providers[].Keys in serve.go"
    - "KeyPool is passed to NewHandler in routes.go instead of nil"
    - "Requests distribute across available keys based on rate limit capacity"
    - "Integration test verifies key exhaustion -> fallback -> recovery flow"
  artifacts:
    - path: "cmd/cc-relay/serve.go"
      provides: "KeyPool initialization from provider config"
      contains: "keypool.NewKeyPool"
    - path: "internal/proxy/routes.go"
      provides: "KeyPool parameter passed to NewHandler"
      pattern: "NewHandler.*pool"
    - path: "internal/proxy/keypool_integration_test.go"
      provides: "Integration test for key rotation and exhaustion"
      min_lines: 80
  key_links:
    - from: "cmd/cc-relay/serve.go"
      to: "internal/keypool/pool.go"
      via: "keypool.NewKeyPool() call"
      pattern: "keypool\\.NewKeyPool"
    - from: "internal/proxy/routes.go"
      to: "internal/proxy/handler.go"
      via: "NewHandler with non-nil pool"
      pattern: "NewHandler\\(.*pool\\)"
---

<objective>
Wire KeyPool into production code path to close Phase 2 verification gaps.

Purpose: The multi-key pooling infrastructure (rate limiters, key metadata, selectors, pool coordinator) is fully implemented and unit-tested, but the handler always receives nil for the pool parameter. This plan wires the components together so requests actually use multi-key pooling in production.

Output: KeyPool initialized from config, passed to handler, with integration test proving the wiring works.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase verification gaps
@.planning/phases/02-multi-key-pooling/02-VERIFICATION.md

# Prior implementation context
@.planning/phases/02-multi-key-pooling/02-03-SUMMARY.md
@.planning/phases/02-multi-key-pooling/02-04-SUMMARY.md
@.planning/phases/02-multi-key-pooling/02-05-SUMMARY.md

# Key files to modify
@cmd/cc-relay/serve.go
@internal/proxy/routes.go
@internal/keypool/pool.go
@internal/config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire KeyPool initialization in serve.go</name>
  <files>cmd/cc-relay/serve.go</files>
  <action>
Add keypool initialization to serve.go after determining the primary provider:

1. Add import for `github.com/omarluq/cc-relay/internal/keypool`

2. After the provider loop (after line 128), add KeyPool creation logic:

```go
// Initialize KeyPool for primary provider if pooling is enabled
var pool *keypool.KeyPool
for i := range cfg.Providers {
    p := &cfg.Providers[i]
    if !p.Enabled {
        continue
    }
    // Only create pool for first enabled provider (primary)
    if p.IsPoolingEnabled() {
        poolCfg := keypool.PoolConfig{
            Strategy: p.GetEffectiveStrategy(),
            Keys:     make([]keypool.KeyConfig, len(p.Keys)),
        }
        for j, k := range p.Keys {
            itpm, otpm := k.GetEffectiveTPM()
            poolCfg.Keys[j] = keypool.KeyConfig{
                APIKey:    k.Key,
                RPMLimit:  k.RPMLimit,
                ITPMLimit: itpm,
                OTPMLimit: otpm,
                Priority:  k.Priority,
                Weight:    k.Weight,
            }
        }
        var err error
        pool, err = keypool.NewKeyPool(p.Name, poolCfg)
        if err != nil {
            log.Error().Err(err).Str("provider", p.Name).Msg("failed to create key pool")
            return err
        }
        log.Info().
            Str("provider", p.Name).
            Int("keys", len(p.Keys)).
            Str("strategy", p.GetEffectiveStrategy()).
            Msg("initialized key pool")
    }
    break // Only process first enabled provider
}
```

3. Modify the SetupRoutesWithProviders call to pass the pool:
   - Change the signature call to pass `pool` as an additional parameter
   - Note: routes.go also needs modification (Task 2)

4. Keep backwards compatibility: If pool is nil (single key mode), handler continues to work with apiKey.
  </action>
  <verify>
Run `go build ./cmd/cc-relay` - compiles without errors.
Run `go vet ./cmd/cc-relay` - no issues.
  </verify>
  <done>serve.go creates KeyPool from config.Providers[].Keys when pooling is enabled</done>
</task>

<task type="auto">
  <name>Task 2: Update routes.go to accept and pass KeyPool</name>
  <files>internal/proxy/routes.go</files>
  <action>
Modify routes.go to accept KeyPool and pass it to NewHandler:

1. Add import for `github.com/omarluq/cc-relay/internal/keypool`

2. Update SetupRoutes signature to accept pool:
```go
func SetupRoutes(cfg *config.Config, provider providers.Provider, providerKey string, pool *keypool.KeyPool) (http.Handler, error) {
    return SetupRoutesWithProviders(cfg, provider, providerKey, pool, nil)
}
```

3. Update SetupRoutesWithProviders signature to accept pool:
```go
func SetupRoutesWithProviders(
    cfg *config.Config,
    provider providers.Provider,
    providerKey string,
    pool *keypool.KeyPool,
    allProviders []providers.Provider,
) (http.Handler, error) {
```

4. Replace line 44 (the TODO comment and nil):
```go
// Use keypool for multi-key routing if provided
handler, err := NewHandler(provider, providerKey, pool, debugOpts)
```

5. Remove the TODO comment on line 43.

The handler already handles nil pool gracefully (uses apiKey directly), so this is backwards compatible.
  </action>
  <verify>
Run `go build ./...` - compiles without errors.
Run `go test ./internal/proxy/... -v -count=1` - existing tests pass (they use nil pool).
  </verify>
  <done>routes.go passes KeyPool to NewHandler; nil pool still works for single-key mode</done>
</task>

<task type="auto">
  <name>Task 3: Add integration test for key pool wiring</name>
  <files>internal/proxy/keypool_integration_test.go</files>
  <action>
Create integration test that verifies the full wiring works:

1. Create `internal/proxy/keypool_integration_test.go` with `//go:build integration` tag

2. Test scenario: "KeyPool selects different keys based on capacity"
   - Create mock backend that tracks which API key was used (from Authorization header)
   - Configure 2 keys with different RPM limits
   - Send multiple requests
   - Verify both keys are used (not just the first one)

3. Test scenario: "Key exhaustion triggers fallback"
   - Configure 2 keys, one with very low RPM (1)
   - Send 3 requests rapidly
   - Verify second key is used after first exhausts
   - Check x-cc-relay-key-exhausted header or similar indicator

4. Test scenario: "429 from pool when all keys exhausted"
   - Configure 1 key with RPM=1
   - Send 2 requests rapidly
   - First succeeds, second returns 429 from proxy (not backend)
   - Verify Retry-After header is present

5. Test scenario: "UpdateKeyFromHeaders updates pool state"
   - Send request that returns rate limit headers
   - Verify pool stats reflect the updated limits

Use httptest.Server for mock backend. Use SetupRoutesWithProviders directly to create handler with pool.

Test file structure:
```go
//go:build integration

package proxy_test

import (
    "testing"
    // imports
)

func TestKeyPoolIntegration(t *testing.T) {
    t.Run("distributes requests across keys", func(t *testing.T) {...})
    t.Run("falls back when key exhausted", func(t *testing.T) {...})
    t.Run("returns 429 when all keys exhausted", func(t *testing.T) {...})
    t.Run("updates pool from response headers", func(t *testing.T) {...})
}
```
  </action>
  <verify>
Run `go test -tags=integration ./internal/proxy/... -v -run TestKeyPoolIntegration` - all tests pass.
Run `go test -race -tags=integration ./internal/proxy/... -run TestKeyPoolIntegration` - no race conditions.
  </verify>
  <done>Integration tests prove key pool wiring works end-to-end: distribution, fallback, 429 handling, header updates</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build verification:
```bash
go build ./...
go vet ./...
golangci-lint run
```

2. Unit tests (existing):
```bash
go test ./... -v -count=1
```

3. Integration tests (new):
```bash
go test -tags=integration ./internal/proxy/... -v -run TestKeyPoolIntegration
```

4. Manual verification (optional):
```bash
# Start server with multi-key config
./bin/cc-relay serve --config config/example.yaml

# Check logs for "initialized key pool" message with key count
```
</verification>

<success_criteria>
1. `go build ./...` compiles successfully
2. `go test ./...` passes (existing tests)
3. `go test -tags=integration ./internal/proxy/... -run TestKeyPoolIntegration` passes (4 scenarios)
4. serve.go has `keypool.NewKeyPool` call with proper config mapping
5. routes.go passes non-nil pool to NewHandler when pooling enabled
6. No TODO comments about keypool wiring remain in routes.go
7. Logs show "initialized key pool" with key count on server startup (when config has multiple keys)
</success_criteria>

<output>
After completion, create `.planning/phases/02-multi-key-pooling/02-06-SUMMARY.md`
</output>
