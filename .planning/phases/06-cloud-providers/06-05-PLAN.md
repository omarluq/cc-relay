---
phase: 06-cloud-providers
plan: 05
type: execute
wave: 3
depends_on: ["06-02", "06-03", "06-04"]
files_modified:
  - cmd/cc-relay/di/providers.go
  - cmd/cc-relay/di/providers_test.go
  - internal/proxy/handler.go
  - internal/proxy/handler_test.go
  - docs-site/content/en/docs/providers.md
  - docs-site/content/de/docs/providers.md
  - docs-site/content/es/docs/providers.md
  - docs-site/content/ja/docs/providers.md
  - docs-site/content/zh-cn/docs/providers.md
  - docs-site/content/ko/docs/providers.md
autonomous: true

must_haves:
  truths:
    - "User can configure type: bedrock in config.yaml"
    - "User can configure type: vertex in config.yaml"
    - "User can configure type: foundry in config.yaml"
    - "DI container creates correct provider based on type"
    - "Proxy handler uses GetEndpointPath for cloud providers"
    - "Proxy handler calls TransformRequestBody for cloud providers"
    - "Provider documentation exists in all 6 languages"
  artifacts:
    - path: "cmd/cc-relay/di/providers.go"
      provides: "DI wiring for cloud providers"
      contains: "case \"bedrock\""
    - path: "internal/proxy/handler.go"
      provides: "Proxy handler with cloud provider support"
      contains: "GetEndpointPath"
    - path: "docs-site/content/en/docs/providers.md"
      provides: "Cloud provider documentation"
      contains: "AWS Bedrock"
  key_links:
    - from: "cmd/cc-relay/di/providers.go"
      to: "internal/providers/bedrock.go"
      via: "NewBedrockProvider call"
      pattern: "providers\\.NewBedrockProvider"
    - from: "cmd/cc-relay/di/providers.go"
      to: "internal/providers/vertex.go"
      via: "NewVertexProvider call"
      pattern: "providers\\.NewVertexProvider"
    - from: "cmd/cc-relay/di/providers.go"
      to: "internal/providers/foundry.go"
      via: "NewFoundryProvider call"
      pattern: "providers\\.NewFoundryProvider"
    - from: "internal/proxy/handler.go"
      to: "internal/providers"
      via: "GetEndpointPath and TransformRequestBody calls"
      pattern: "GetEndpointPath|TransformRequestBody"
---

<objective>
Wire cloud providers into the DI container, integrate endpoint path routing and body transformation into the proxy handler, and add comprehensive documentation for all supported languages.

Purpose: Enable users to configure and use cloud providers in production with proper documentation.
Output: Complete DI integration for Bedrock, Vertex, and Foundry providers, proxy handler integration, and 6-language documentation.
</objective>

<execution_context>
@.claude/get-shit-done/workflows/execute-plan.md
@.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-cloud-providers/06-RESEARCH.md
@cmd/cc-relay/di/providers.go
@internal/proxy/handler.go
@docs-site/content/en/docs/providers.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire cloud providers in DI container</name>
  <files>cmd/cc-relay/di/providers.go</files>
  <action>
Update NewProviderMap function to handle cloud provider types. In the switch statement (around line 242-250), add cases for bedrock, vertex, and foundry:

```go
case "bedrock":
    // AWS Bedrock requires region
    region := p.GetAWSRegion() // defaults to "us-east-1"
    ctx := context.Background()

    bedrockProv, err := providers.NewBedrockProvider(
        ctx,
        p.Name,
        region,
        p.AWSProfile,
        p.Models,
        p.ModelMapping,
    )
    if err != nil {
        // Log error but continue with other providers
        // This allows cc-relay to start even if AWS credentials aren't configured
        continue
    }
    prov = bedrockProv

case "vertex":
    // Vertex AI requires project ID and region
    if p.GCPProjectID == "" {
        // Log warning and skip - GCP project required
        continue
    }
    region := p.GetGCPRegion() // defaults to "global"
    ctx := context.Background()

    vertexProv, err := providers.NewVertexProvider(
        ctx,
        p.Name,
        p.GCPProjectID,
        region,
        p.Models,
        p.ModelMapping,
    )
    if err != nil {
        // Log error but continue with other providers
        continue
    }
    prov = vertexProv

case "foundry":
    // Azure Foundry requires resource name
    if p.AzureResource == "" {
        // Log warning and skip - Azure resource required
        continue
    }

    // Check if API key is configured
    if len(p.Keys) > 0 && p.Keys[0].Key != "" {
        prov = providers.NewFoundryProviderWithAPIKey(
            p.Name,
            p.AzureResource,
            p.Keys[0].Key,
            p.Models,
            p.ModelMapping,
        )
    } else {
        // Use Entra ID authentication
        foundryProv, err := providers.NewFoundryProvider(
            p.Name,
            p.AzureResource,
            p.Models,
            p.ModelMapping,
        )
        if err != nil {
            // Log error but continue with other providers
            continue
        }
        prov = foundryProv
    }
```

Also add logging for cloud provider initialization using the logger service. Import context package if needed.
  </action>
  <verify>go build ./... compiles</verify>
  <done>DI container handles bedrock, vertex, and foundry provider types</done>
</task>

<task type="auto">
  <name>Task 2: Integrate cloud provider routing in proxy handler</name>
  <files>internal/proxy/handler.go, internal/proxy/handler_test.go</files>
  <action>
Update the proxy handler to use cloud provider-specific endpoint paths and body transformation.

**In handler.go:**

1. Add interface check for cloud provider capabilities:
```go
// CloudProvider interface for providers that need special routing
type CloudProvider interface {
    GetEndpointPath(model string) string
    TransformRequestBody(body []byte) ([]byte, error)
}
```

2. In the request handling logic (where the upstream URL is constructed), check if provider implements CloudProvider:
```go
// Check if provider needs endpoint path routing (Bedrock, Vertex)
if cloudProv, ok := provider.(CloudProvider); ok {
    // Use provider-specific endpoint path instead of default /v1/messages
    endpointPath := cloudProv.GetEndpointPath(requestedModel)
    upstreamURL = provider.BaseURL() + endpointPath
} else {
    // Standard Anthropic-compatible endpoint
    upstreamURL = provider.BaseURL() + "/v1/messages"
}
```

3. In the request body handling, apply transformation if needed:
```go
// Transform request body for cloud providers (inject anthropic_version)
if cloudProv, ok := provider.(CloudProvider); ok {
    transformedBody, err := cloudProv.TransformRequestBody(bodyBytes)
    if err != nil {
        // Return error to client
        return
    }
    bodyBytes = transformedBody
}
```

**In handler_test.go:**

Add tests for cloud provider integration:

1. **TestHandler_CloudProvider_EndpointPath:**
   - Create mock provider implementing CloudProvider interface
   - Verify handler uses GetEndpointPath for URL construction

2. **TestHandler_CloudProvider_BodyTransformation:**
   - Create mock provider implementing CloudProvider interface
   - Verify handler calls TransformRequestBody before forwarding

3. **TestHandler_StandardProvider_NoTransformation:**
   - Verify non-cloud providers (Anthropic, Ollama) don't get transformed
  </action>
  <verify>go test ./internal/proxy/... -v passes</verify>
  <done>Proxy handler uses GetEndpointPath and TransformRequestBody for cloud providers</done>
</task>

<task type="auto">
  <name>Task 3: Add DI integration tests for cloud providers</name>
  <files>cmd/cc-relay/di/providers_test.go</files>
  <action>
Add tests for cloud provider DI wiring:

1. **TestNewProviderMap_Bedrock:**
   - Config with type: "bedrock", aws_region: "us-west-2"
   - Verify provider created (may fail if no AWS creds - that's OK)
   - Test with mock/skipped credential loading

2. **TestNewProviderMap_Vertex:**
   - Config with type: "vertex", gcp_project_id: "test-project", gcp_region: "global"
   - Verify provider created (may fail if no GCP creds - that's OK)
   - Test that missing gcp_project_id skips provider

3. **TestNewProviderMap_Foundry:**
   - Config with type: "foundry", azure_resource: "test-resource"
   - Test with API key: verify provider created
   - Test without API key and no Entra ID: provider skipped

4. **TestNewProviderMap_CloudProviderErrors:**
   - Verify that cloud provider errors don't crash startup
   - Verify other providers still load when one cloud provider fails

Note: Cloud provider tests may need to be skipped in CI without credentials. Use `t.Skip()` based on environment detection:
```go
func skipWithoutAWS(t *testing.T) {
    if os.Getenv("AWS_ACCESS_KEY_ID") == "" {
        t.Skip("AWS credentials not available")
    }
}
```
  </action>
  <verify>go test ./cmd/cc-relay/di/... -v passes</verify>
  <done>DI tests cover cloud provider wiring and error handling</done>
</task>

<task type="auto">
  <name>Task 4: Create English provider documentation</name>
  <files>docs-site/content/en/docs/providers.md</files>
  <action>
Add comprehensive cloud provider documentation after the existing Ollama section:

```markdown
## AWS Bedrock

AWS Bedrock provides access to Claude models through AWS infrastructure with SigV4 authentication.

### Configuration

```yaml
providers:
  - name: bedrock
    type: bedrock
    enabled: true
    aws_region: us-west-2    # Required: AWS region with Bedrock access
    aws_profile: ""          # Optional: AWS config profile name

    models:
      - "anthropic.claude-sonnet-4-5-20250929-v1:0"
      - "anthropic.claude-opus-4-5-20251101-v1:0"

    model_mapping:
      "claude-sonnet-4-5": "anthropic.claude-sonnet-4-5-20250929-v1:0"
```

### Authentication

Bedrock uses AWS credential chain (environment variables, shared credentials, IAM role). No API keys needed in config.

Required IAM permissions:
- `bedrock:InvokeModel`
- `bedrock:InvokeModelWithResponseStream`

## Google Vertex AI

Vertex AI provides Claude models through Google Cloud with OAuth authentication.

### Configuration

```yaml
providers:
  - name: vertex
    type: vertex
    enabled: true
    gcp_project_id: my-project  # Required: GCP project ID
    gcp_region: global          # Optional: defaults to "global"

    models:
      - "claude-sonnet-4-5@20250929"
      - "claude-opus-4-5@20251101"

    model_mapping:
      "claude-sonnet-4-5": "claude-sonnet-4-5@20250929"
```

### Authentication

Vertex uses Application Default Credentials (ADC). Set `GOOGLE_APPLICATION_CREDENTIALS` or use gcloud login.

Required API: Vertex AI API must be enabled in your project.

## Azure Foundry

Azure Foundry (Azure AI Foundry) provides Claude models with API key or Entra ID authentication.

### Configuration

```yaml
providers:
  - name: foundry
    type: foundry
    enabled: true
    azure_resource: my-resource  # Required: Azure resource name

    keys:
      - key: "${AZURE_FOUNDRY_API_KEY}"  # Optional: API key

    models:
      - "claude-sonnet-4-5"
      - "claude-opus-4-5"
```

### Authentication

- With API key: Set in `keys` array
- Without API key: Uses Azure Entra ID (DefaultAzureCredential)

Note: Azure requires content filter configuration before using Claude models.
```
  </action>
  <verify>cd docs-site && hugo --minify builds without errors</verify>
  <done>English cloud provider documentation complete</done>
</task>

<task type="auto">
  <name>Task 5: Translate provider documentation to other languages</name>
  <files>
    docs-site/content/de/docs/providers.md
    docs-site/content/es/docs/providers.md
    docs-site/content/ja/docs/providers.md
    docs-site/content/zh-cn/docs/providers.md
    docs-site/content/ko/docs/providers.md
  </files>
  <action>
Copy the cloud provider sections from English to each language file, then translate the prose while keeping code unchanged.

**Translation guidelines:**

1. **Keep unchanged (DO NOT translate):**
   - All YAML code blocks (copy exactly)
   - Technical terms: SigV4, OAuth, IAM, ADC, API key, Entra ID
   - Model names: claude-sonnet-4-5, anthropic.claude-sonnet-4-5-20250929-v1:0
   - Region names: us-west-2, global, us-central1
   - Permission names: bedrock:InvokeModel
   - Variable names: GOOGLE_APPLICATION_CREDENTIALS, AZURE_FOUNDRY_API_KEY

2. **Translate these phrases:**

| English | German (de) | Spanish (es) | Japanese (ja) | Chinese (zh-cn) | Korean (ko) |
|---------|-------------|--------------|---------------|-----------------|-------------|
| "Configuration" | "Konfiguration" | "Configuracion" | "設定" | "配置" | "설정" |
| "Authentication" | "Authentifizierung" | "Autenticacion" | "認証" | "身份验证" | "인증" |
| "Required" | "Erforderlich" | "Requerido" | "必須" | "必填" | "필수" |
| "Optional" | "Optional" | "Opcional" | "オプション" | "可选" | "선택사항" |
| "provides access to" | "bietet Zugang zu" | "proporciona acceso a" | "へのアクセスを提供します" | "提供访问" | "에 대한 액세스를 제공합니다" |
| "No API keys needed" | "Keine API-Schlussel erforderlich" | "No se necesitan claves API" | "APIキーは不要" | "无需API密钥" | "API 키가 필요하지 않습니다" |

3. **Section headers to translate:**
   - "## AWS Bedrock" -> Keep as-is (product name)
   - "## Google Vertex AI" -> Keep as-is (product name)
   - "## Azure Foundry" -> Keep as-is (product name)
   - "### Configuration" -> Translate
   - "### Authentication" -> Translate

4. **Process for each file:**
   a. Read existing file to understand its structure and style
   b. Find where Ollama section ends
   c. Add translated cloud provider sections after Ollama
   d. Match the writing style of existing translations in that file
  </action>
  <verify>cd docs-site && hugo --minify builds without errors</verify>
  <done>Cloud provider documentation exists in all 6 languages with consistent structure</done>
</task>

</tasks>

<verification>
1. `go build ./...` - compiles without errors
2. `go test ./cmd/cc-relay/di/... -v` - DI tests pass
3. `go test ./internal/proxy/... -v` - proxy handler tests pass
4. `cd docs-site && hugo --minify` - documentation builds
5. `task lint` - no linter errors
</verification>

<success_criteria>
- DI container creates BedrockProvider for type: "bedrock"
- DI container creates VertexProvider for type: "vertex"
- DI container creates FoundryProvider for type: "foundry"
- Proxy handler uses GetEndpointPath for cloud provider URL routing
- Proxy handler calls TransformRequestBody for cloud providers
- Cloud provider errors don't crash startup
- Documentation updated in all 6 languages
- Hugo site builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/06-cloud-providers/06-05-SUMMARY.md`
</output>
