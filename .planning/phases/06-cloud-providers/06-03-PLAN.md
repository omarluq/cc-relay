---
phase: 06-cloud-providers
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - internal/providers/vertex.go
  - internal/providers/vertex_test.go
  - go.mod
  - go.sum
autonomous: true

must_haves:
  truths:
    - "Vertex AI provider uses Google OAuth for authentication"
    - "Vertex AI provider puts model in URL path"
    - "Vertex AI provider adds anthropic_version to request body"
  artifacts:
    - path: "internal/providers/vertex.go"
      provides: "VertexProvider implementation with OAuth"
      exports: ["VertexProvider", "NewVertexProvider"]
    - path: "internal/providers/vertex_test.go"
      provides: "Unit tests for Vertex provider"
      min_lines: 150
  key_links:
    - from: "internal/providers/vertex.go"
      to: "internal/providers/transform.go"
      via: "uses TransformBodyForCloudProvider"
      pattern: "TransformBodyForCloudProvider"
    - from: "internal/providers/vertex.go"
      to: "golang.org/x/oauth2/google"
      via: "Google OAuth authentication"
      pattern: "oauth2.*google"
---

<objective>
Implement Google Vertex AI provider with OAuth token authentication and model-in-URL transformation.

Purpose: Vertex AI requires Google OAuth authentication and URL-based model specification. This validates the transformation architecture with a moderate-complexity provider before tackling Bedrock's Event Stream conversion.

Output: Working Vertex provider with OAuth token management, URL transformation, and body modification.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-cloud-providers/06-RESEARCH.md

# Prior plan output for interface extension
@.planning/phases/06-cloud-providers/06-01-SUMMARY.md

# Existing provider patterns
@internal/providers/base.go
@internal/providers/transform.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Google OAuth dependencies</name>
  <files>go.mod, go.sum</files>
  <action>
Install the required Google OAuth and metadata libraries:

```bash
go get golang.org/x/oauth2/google
go get cloud.google.com/go/compute/metadata
```

These are the official Google libraries for:
- OAuth token generation and refresh
- GCE metadata service access (for service accounts running in GCP)

Verify installation:
```bash
go mod tidy
grep "golang.org/x/oauth2" go.mod
grep "cloud.google.com/go/compute" go.mod
```
  </action>
  <verify>
- `go mod tidy` succeeds
- `golang.org/x/oauth2` appears in go.mod
- `cloud.google.com/go/compute` appears in go.mod
  </verify>
  <done>Google OAuth and metadata dependencies installed</done>
</task>

<task type="auto">
  <name>Task 2: Create VertexProvider implementation</name>
  <files>internal/providers/vertex.go</files>
  <action>
Create the Vertex AI provider with OAuth authentication and URL transformation:

```go
package providers

import (
    "context"
    "fmt"
    "net/http"
    "net/url"
    "sync"
    "time"

    "github.com/rs/zerolog/log"
    "golang.org/x/oauth2"
    "golang.org/x/oauth2/google"
)

const (
    // VertexOwner is the owner identifier for Vertex AI provider.
    VertexOwner = "google"

    // VertexAnthropicVersion is the anthropic_version for Vertex AI requests.
    // Must be in request body (not header) for Vertex AI.
    VertexAnthropicVersion = "vertex-2023-10-16"

    // vertexScope is the OAuth scope required for Vertex AI.
    vertexScope = "https://www.googleapis.com/auth/cloud-platform"
)

// DefaultVertexModels are the default models available from Vertex AI.
// Model IDs use Vertex format: publisher/model-name (no version date).
var DefaultVertexModels = []string{
    "claude-sonnet-4-5@20250514",
    "claude-opus-4-5@20250514",
    "claude-haiku-3-5@20241022",
}

// VertexProvider implements the Provider interface for Google Vertex AI.
// Vertex AI requires:
// - Model in URL path (not body)
// - anthropic_version in request body (not header)
// - OAuth Bearer token authentication
type VertexProvider struct {
    BaseProvider
    projectID   string
    region      string
    tokenSource oauth2.TokenSource
    tokenMu     sync.RWMutex
}

// VertexConfig holds Vertex AI-specific configuration.
type VertexConfig struct {
    Name         string
    ProjectID    string   // GCP project ID
    Region       string   // GCP region (e.g., "us-central1")
    Models       []string
    ModelMapping map[string]string
}

// NewVertexProvider creates a new Vertex AI provider instance.
// Uses Google Application Default Credentials for authentication.
// Token refresh is handled automatically by the TokenSource.
func NewVertexProvider(ctx context.Context, cfg VertexConfig) (*VertexProvider, error) {
    if cfg.ProjectID == "" {
        return nil, fmt.Errorf("vertex: project_id is required")
    }
    if cfg.Region == "" {
        return nil, fmt.Errorf("vertex: region is required")
    }

    if len(cfg.Models) == 0 {
        cfg.Models = DefaultVertexModels
    }

    // Construct base URL for Vertex AI
    // Format: https://{region}-aiplatform.googleapis.com
    baseURL := fmt.Sprintf("https://%s-aiplatform.googleapis.com", cfg.Region)

    // Get Google credentials with cloud-platform scope
    creds, err := google.FindDefaultCredentials(ctx, vertexScope)
    if err != nil {
        return nil, fmt.Errorf("vertex: failed to find credentials: %w", err)
    }

    return &VertexProvider{
        BaseProvider: NewBaseProviderWithMapping(cfg.Name, baseURL, VertexOwner, cfg.Models, cfg.ModelMapping),
        projectID:    cfg.ProjectID,
        region:       cfg.Region,
        tokenSource:  creds.TokenSource,
    }, nil
}

// NewVertexProviderWithTokenSource creates a Vertex provider with a custom token source.
// Useful for testing or when using explicit credentials.
func NewVertexProviderWithTokenSource(cfg VertexConfig, tokenSource oauth2.TokenSource) *VertexProvider {
    if len(cfg.Models) == 0 {
        cfg.Models = DefaultVertexModels
    }

    baseURL := fmt.Sprintf("https://%s-aiplatform.googleapis.com", cfg.Region)

    return &VertexProvider{
        BaseProvider: NewBaseProviderWithMapping(cfg.Name, baseURL, VertexOwner, cfg.Models, cfg.ModelMapping),
        projectID:    cfg.ProjectID,
        region:       cfg.Region,
        tokenSource:  tokenSource,
    }
}

// Authenticate adds OAuth Bearer token to the request.
// The key parameter is ignored - we use the TokenSource instead.
func (p *VertexProvider) Authenticate(req *http.Request, _ string) error {
    p.tokenMu.RLock()
    ts := p.tokenSource
    p.tokenMu.RUnlock()

    if ts == nil {
        return fmt.Errorf("vertex: no token source configured")
    }

    token, err := ts.Token()
    if err != nil {
        return fmt.Errorf("vertex: failed to get token: %w", err)
    }

    req.Header.Set("Authorization", "Bearer "+token.AccessToken)

    log.Ctx(req.Context()).Debug().
        Str("provider", p.name).
        Bool("token_valid", token.Valid()).
        Time("token_expiry", token.Expiry).
        Msg("added Vertex AI OAuth authentication")

    return nil
}

// ForwardHeaders returns headers to forward to Vertex AI.
// Note: anthropic_version goes in body for Vertex, not header.
func (p *VertexProvider) ForwardHeaders(originalHeaders http.Header) http.Header {
    headers := p.BaseProvider.ForwardHeaders(originalHeaders)

    // Remove anthropic-version from headers (it goes in body for Vertex)
    headers.Del("Anthropic-Version")

    return headers
}

// TransformRequest transforms the request for Vertex AI:
// 1. Extracts model from body
// 2. Removes model from body
// 3. Adds anthropic_version to body
// 4. Constructs URL with model in path
func (p *VertexProvider) TransformRequest(body []byte, endpoint string) ([]byte, string, error) {
    // Use shared transformation utility
    newBody, model, err := TransformBodyForCloudProvider(body, VertexAnthropicVersion)
    if err != nil {
        return nil, "", fmt.Errorf("vertex: transform failed: %w", err)
    }

    // Map model name to Vertex format if needed
    model = p.MapModel(model)

    // Determine if streaming based on endpoint
    isStreaming := endpoint == "/v1/messages" // All /v1/messages are potentially streaming

    // Construct Vertex AI URL with model in path
    // Format: /v1/projects/{project}/locations/{region}/publishers/anthropic/models/{model}:streamRawPredict
    //     or: /v1/projects/{project}/locations/{region}/publishers/anthropic/models/{model}:rawPredict
    action := "rawPredict"
    if isStreaming {
        action = "streamRawPredict"
    }

    targetURL := fmt.Sprintf("%s/v1/projects/%s/locations/%s/publishers/anthropic/models/%s:%s",
        p.baseURL,
        url.PathEscape(p.projectID),
        url.PathEscape(p.region),
        url.PathEscape(model),
        action)

    return newBody, targetURL, nil
}

// RequiresBodyTransform returns true for Vertex AI.
// Model is removed from body and added to URL path.
func (p *VertexProvider) RequiresBodyTransform() bool {
    return true
}

// RefreshToken forces a token refresh. Useful before long streaming requests.
// This is a proactive refresh to avoid token expiration mid-stream.
func (p *VertexProvider) RefreshToken(ctx context.Context) error {
    p.tokenMu.RLock()
    ts := p.tokenSource
    p.tokenMu.RUnlock()

    if ts == nil {
        return fmt.Errorf("vertex: no token source configured")
    }

    // TokenSource automatically handles refresh, just request a new token
    token, err := ts.Token()
    if err != nil {
        return fmt.Errorf("vertex: refresh failed: %w", err)
    }

    log.Ctx(ctx).Debug().
        Time("new_expiry", token.Expiry).
        Dur("valid_for", time.Until(token.Expiry)).
        Msg("refreshed Vertex AI OAuth token")

    return nil
}

// GetProjectID returns the configured GCP project ID.
func (p *VertexProvider) GetProjectID() string {
    return p.projectID
}

// GetRegion returns the configured GCP region.
func (p *VertexProvider) GetRegion() string {
    return p.region
}
```

Key implementation details from research:
- anthropic_version "vertex-2023-10-16" goes in body (not header)
- Model ID format: "claude-sonnet-4-5@20250514" (not hyphenated date)
- URL includes :streamRawPredict or :rawPredict action
- OAuth tokens auto-refresh via TokenSource
  </action>
  <verify>
- `go build ./internal/providers/...` succeeds
- VertexProvider implements all Provider interface methods
  </verify>
  <done>VertexProvider implementation complete with OAuth and URL transformation</done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive unit tests for VertexProvider</name>
  <files>internal/providers/vertex_test.go</files>
  <action>
Create thorough unit tests with a mock TokenSource:

```go
package providers

import (
    "context"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"
    "time"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
    "golang.org/x/oauth2"
)

// mockTokenSource provides a controllable token source for testing.
type mockTokenSource struct {
    token *oauth2.Token
    err   error
}

func (m *mockTokenSource) Token() (*oauth2.Token, error) {
    if m.err != nil {
        return nil, m.err
    }
    return m.token, nil
}

func newMockTokenSource(accessToken string) *mockTokenSource {
    return &mockTokenSource{
        token: &oauth2.Token{
            AccessToken: accessToken,
            TokenType:   "Bearer",
            Expiry:      time.Now().Add(1 * time.Hour),
        },
    }
}

func TestNewVertexProviderWithTokenSource(t *testing.T) {
    t.Run("creates provider with required config", func(t *testing.T) {
        cfg := VertexConfig{
            Name:      "test-vertex",
            ProjectID: "my-project",
            Region:    "us-central1",
        }
        ts := newMockTokenSource("test-token")
        p := NewVertexProviderWithTokenSource(cfg, ts)

        assert.Equal(t, "test-vertex", p.Name())
        assert.Equal(t, "https://us-central1-aiplatform.googleapis.com", p.BaseURL())
        assert.Equal(t, VertexOwner, p.Owner())
        assert.Equal(t, "my-project", p.GetProjectID())
        assert.Equal(t, "us-central1", p.GetRegion())
    })

    t.Run("uses default models when none specified", func(t *testing.T) {
        cfg := VertexConfig{
            Name:      "test-vertex",
            ProjectID: "my-project",
            Region:    "us-central1",
        }
        ts := newMockTokenSource("test-token")
        p := NewVertexProviderWithTokenSource(cfg, ts)

        models := p.ListModels()
        assert.Len(t, models, len(DefaultVertexModels))
    })

    t.Run("uses custom models when specified", func(t *testing.T) {
        cfg := VertexConfig{
            Name:      "test-vertex",
            ProjectID: "my-project",
            Region:    "us-central1",
            Models:    []string{"custom-model"},
        }
        ts := newMockTokenSource("test-token")
        p := NewVertexProviderWithTokenSource(cfg, ts)

        models := p.ListModels()
        assert.Len(t, models, 1)
        assert.Equal(t, "custom-model", models[0].ID)
    })
}

func TestVertexProvider_Authenticate(t *testing.T) {
    t.Run("adds Bearer token from TokenSource", func(t *testing.T) {
        cfg := VertexConfig{
            Name:      "test-vertex",
            ProjectID: "my-project",
            Region:    "us-central1",
        }
        ts := newMockTokenSource("gcp-oauth-token-xyz")
        p := NewVertexProviderWithTokenSource(cfg, ts)

        req := httptest.NewRequest(http.MethodPost, "/v1/messages", nil)
        err := p.Authenticate(req, "") // key param ignored

        require.NoError(t, err)
        assert.Equal(t, "Bearer gcp-oauth-token-xyz", req.Header.Get("Authorization"))
    })

    t.Run("returns error when token source fails", func(t *testing.T) {
        cfg := VertexConfig{
            Name:      "test-vertex",
            ProjectID: "my-project",
            Region:    "us-central1",
        }
        ts := &mockTokenSource{err: assert.AnError}
        p := NewVertexProviderWithTokenSource(cfg, ts)

        req := httptest.NewRequest(http.MethodPost, "/v1/messages", nil)
        err := p.Authenticate(req, "")

        assert.Error(t, err)
        assert.Contains(t, err.Error(), "failed to get token")
    })

    t.Run("returns error when no token source configured", func(t *testing.T) {
        cfg := VertexConfig{
            Name:      "test-vertex",
            ProjectID: "my-project",
            Region:    "us-central1",
        }
        p := NewVertexProviderWithTokenSource(cfg, nil)

        req := httptest.NewRequest(http.MethodPost, "/v1/messages", nil)
        err := p.Authenticate(req, "")

        assert.Error(t, err)
        assert.Contains(t, err.Error(), "no token source")
    })
}

func TestVertexProvider_ForwardHeaders(t *testing.T) {
    cfg := VertexConfig{
        Name:      "test-vertex",
        ProjectID: "my-project",
        Region:    "us-central1",
    }
    ts := newMockTokenSource("test-token")
    p := NewVertexProviderWithTokenSource(cfg, ts)

    t.Run("removes anthropic-version header", func(t *testing.T) {
        origHeaders := http.Header{}
        origHeaders.Set("Anthropic-Version", "2023-06-01")
        headers := p.ForwardHeaders(origHeaders)

        // anthropic_version goes in body for Vertex, not header
        assert.Empty(t, headers.Get("Anthropic-Version"))
    })

    t.Run("preserves other anthropic headers", func(t *testing.T) {
        origHeaders := http.Header{}
        origHeaders.Set("Anthropic-Beta", "tools-2024-04-04")
        headers := p.ForwardHeaders(origHeaders)

        assert.Equal(t, "tools-2024-04-04", headers.Get("Anthropic-Beta"))
    })

    t.Run("sets Content-Type", func(t *testing.T) {
        origHeaders := http.Header{}
        headers := p.ForwardHeaders(origHeaders)

        assert.Equal(t, "application/json", headers.Get("Content-Type"))
    })
}

func TestVertexProvider_TransformRequest(t *testing.T) {
    cfg := VertexConfig{
        Name:      "test-vertex",
        ProjectID: "my-project",
        Region:    "us-central1",
    }
    ts := newMockTokenSource("test-token")
    p := NewVertexProviderWithTokenSource(cfg, ts)

    t.Run("removes model from body and adds anthropic_version", func(t *testing.T) {
        body := []byte(`{"model":"claude-sonnet-4-5@20250514","messages":[{"role":"user","content":"Hello"}]}`)

        newBody, _, err := p.TransformRequest(body, "/v1/messages")

        require.NoError(t, err)

        // Parse result to verify
        var result map[string]interface{}
        err = json.Unmarshal(newBody, &result)
        require.NoError(t, err)

        // Model should be removed
        _, hasModel := result["model"]
        assert.False(t, hasModel, "model should be removed from body")

        // anthropic_version should be added
        assert.Equal(t, VertexAnthropicVersion, result["anthropic_version"])

        // messages should be preserved
        assert.NotNil(t, result["messages"])
    })

    t.Run("constructs correct streaming URL with model in path", func(t *testing.T) {
        body := []byte(`{"model":"claude-sonnet-4-5@20250514","messages":[]}`)

        _, targetURL, err := p.TransformRequest(body, "/v1/messages")

        require.NoError(t, err)
        expected := "https://us-central1-aiplatform.googleapis.com/v1/projects/my-project/locations/us-central1/publishers/anthropic/models/claude-sonnet-4-5%4020250514:streamRawPredict"
        assert.Equal(t, expected, targetURL)
    })

    t.Run("applies model mapping", func(t *testing.T) {
        cfgWithMapping := VertexConfig{
            Name:      "test-vertex",
            ProjectID: "my-project",
            Region:    "us-central1",
            ModelMapping: map[string]string{
                "claude-4": "claude-sonnet-4-5@20250514",
            },
        }
        pWithMapping := NewVertexProviderWithTokenSource(cfgWithMapping, ts)

        body := []byte(`{"model":"claude-4","messages":[]}`)
        _, targetURL, err := pWithMapping.TransformRequest(body, "/v1/messages")

        require.NoError(t, err)
        assert.Contains(t, targetURL, "claude-sonnet-4-5%4020250514")
    })
}

func TestVertexProvider_RequiresBodyTransform(t *testing.T) {
    cfg := VertexConfig{
        Name:      "test-vertex",
        ProjectID: "my-project",
        Region:    "us-central1",
    }
    ts := newMockTokenSource("test-token")
    p := NewVertexProviderWithTokenSource(cfg, ts)

    assert.True(t, p.RequiresBodyTransform())
}

func TestVertexProvider_SupportsStreaming(t *testing.T) {
    cfg := VertexConfig{
        Name:      "test-vertex",
        ProjectID: "my-project",
        Region:    "us-central1",
    }
    ts := newMockTokenSource("test-token")
    p := NewVertexProviderWithTokenSource(cfg, ts)

    assert.True(t, p.SupportsStreaming())
}

func TestVertexProvider_StreamingContentType(t *testing.T) {
    cfg := VertexConfig{
        Name:      "test-vertex",
        ProjectID: "my-project",
        Region:    "us-central1",
    }
    ts := newMockTokenSource("test-token")
    p := NewVertexProviderWithTokenSource(cfg, ts)

    // Vertex uses standard SSE (unlike Bedrock)
    assert.Equal(t, "text/event-stream", p.StreamingContentType())
}

func TestVertexProvider_RefreshToken(t *testing.T) {
    t.Run("successfully refreshes token", func(t *testing.T) {
        cfg := VertexConfig{
            Name:      "test-vertex",
            ProjectID: "my-project",
            Region:    "us-central1",
        }
        ts := newMockTokenSource("refreshed-token")
        p := NewVertexProviderWithTokenSource(cfg, ts)

        err := p.RefreshToken(context.Background())
        require.NoError(t, err)
    })

    t.Run("returns error when no token source", func(t *testing.T) {
        cfg := VertexConfig{
            Name:      "test-vertex",
            ProjectID: "my-project",
            Region:    "us-central1",
        }
        p := NewVertexProviderWithTokenSource(cfg, nil)

        err := p.RefreshToken(context.Background())
        assert.Error(t, err)
    })
}

func TestVertexProvider_ModelMapping(t *testing.T) {
    cfg := VertexConfig{
        Name:      "test-vertex",
        ProjectID: "my-project",
        Region:    "us-central1",
        ModelMapping: map[string]string{
            "claude-4":     "claude-sonnet-4-5@20250514",
            "claude-opus":  "claude-opus-4-5@20250514",
        },
    }
    ts := newMockTokenSource("test-token")
    p := NewVertexProviderWithTokenSource(cfg, ts)

    t.Run("maps known model", func(t *testing.T) {
        assert.Equal(t, "claude-sonnet-4-5@20250514", p.MapModel("claude-4"))
    })

    t.Run("returns original for unknown model", func(t *testing.T) {
        assert.Equal(t, "unknown-model", p.MapModel("unknown-model"))
    })
}
```

Tests cover:
- Provider creation with various configs
- OAuth Bearer token authentication
- Token error handling
- Header forwarding (anthropic-version removal)
- Body transformation (model removal, anthropic_version addition)
- URL construction with model in path
- Model mapping
- Token refresh
  </action>
  <verify>
- `go test ./internal/providers/... -v -run Vertex` passes
- Test coverage for vertex.go > 80%
  </verify>
  <done>Comprehensive unit tests for VertexProvider with >80% coverage</done>
</task>

</tasks>

<verification>
After all tasks:
1. `go build ./internal/providers/...` succeeds
2. `go test ./internal/providers/... -v -run Vertex` passes all tests
3. `go test ./internal/providers/... -cover` shows vertex.go > 80%
4. `task lint` passes
5. Google OAuth libraries in go.mod
</verification>

<success_criteria>
- VertexProvider implements Provider interface with all transformation methods
- OAuth Bearer token authentication works with TokenSource
- Model removed from body and added to URL path
- anthropic_version "vertex-2023-10-16" added to body
- Tests verify all functionality including error cases
</success_criteria>

<output>
After completion, create `.planning/phases/06-cloud-providers/06-03-SUMMARY.md`
</output>
