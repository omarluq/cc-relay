---
phase: 06-cloud-providers
plan: 04
type: execute
wave: 3
depends_on: ["06-01"]
files_modified:
  - internal/providers/bedrock.go
  - internal/providers/bedrock_test.go
  - internal/providers/eventstream.go
  - internal/providers/eventstream_test.go
  - go.mod
  - go.sum
autonomous: true

must_haves:
  truths:
    - "Bedrock provider uses AWS SigV4 for authentication"
    - "Bedrock provider puts model in URL path"
    - "Bedrock provider converts Event Stream to SSE format"
    - "Bedrock provider adds anthropic_version to request body"
  artifacts:
    - path: "internal/providers/bedrock.go"
      provides: "BedrockProvider implementation with SigV4"
      exports: ["BedrockProvider", "NewBedrockProvider"]
    - path: "internal/providers/eventstream.go"
      provides: "AWS Event Stream to SSE converter"
      exports: ["EventStreamToSSE"]
    - path: "internal/providers/bedrock_test.go"
      provides: "Unit tests for Bedrock provider"
      min_lines: 200
  key_links:
    - from: "internal/providers/bedrock.go"
      to: "internal/providers/transform.go"
      via: "uses TransformBodyForCloudProvider"
      pattern: "TransformBodyForCloudProvider"
    - from: "internal/providers/bedrock.go"
      to: "internal/providers/eventstream.go"
      via: "streaming response conversion"
      pattern: "EventStreamToSSE"
    - from: "internal/providers/bedrock.go"
      to: "github.com/aws/aws-sdk-go-v2/aws/signer/v4"
      via: "AWS SigV4 signing"
      pattern: "signer/v4"
---

<objective>
Implement AWS Bedrock provider with SigV4 authentication, model-in-URL transformation, and Event Stream to SSE conversion.

Purpose: Bedrock is the most complex cloud provider, requiring SigV4 signing and binary Event Stream format conversion. Completing this validates the full transformer architecture.

Output: Working Bedrock provider with SigV4 auth, URL transformation, body modification, and streaming format conversion.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-cloud-providers/06-RESEARCH.md

# Prior plan output for interface extension
@.planning/phases/06-cloud-providers/06-01-SUMMARY.md

# Existing provider patterns
@internal/providers/base.go
@internal/providers/transform.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install AWS SDK dependencies</name>
  <files>go.mod, go.sum</files>
  <action>
Install the required AWS SDK v2 libraries:

```bash
go get github.com/aws/aws-sdk-go-v2
go get github.com/aws/aws-sdk-go-v2/config
go get github.com/aws/aws-sdk-go-v2/credentials
go get github.com/aws/aws-sdk-go-v2/aws/signer/v4
go get github.com/aws/aws-sdk-go-v2/service/bedrockruntime
```

These provide:
- AWS config and credential chain
- SigV4 signing for request authentication
- Bedrock runtime service client (for Event Stream parsing if needed)

Verify installation:
```bash
go mod tidy
grep "aws-sdk-go-v2" go.mod
```
  </action>
  <verify>
- `go mod tidy` succeeds
- `github.com/aws/aws-sdk-go-v2` appears in go.mod
- Multiple aws-sdk-go-v2 submodules installed
  </verify>
  <done>AWS SDK v2 dependencies installed</done>
</task>

<task type="auto">
  <name>Task 2: Create Event Stream to SSE converter</name>
  <files>internal/providers/eventstream.go, internal/providers/eventstream_test.go</files>
  <action>
Create the Event Stream to SSE format converter. Bedrock returns `application/vnd.amazon.eventstream` which must be converted to standard SSE for Claude Code.

```go
// Package providers provides Event Stream to SSE conversion for AWS Bedrock.
package providers

import (
    "bytes"
    "encoding/binary"
    "encoding/json"
    "fmt"
    "hash/crc32"
    "io"
    "net/http"
)

// EventStreamHeader represents a header in an AWS Event Stream message.
type EventStreamHeader struct {
    Name  string
    Type  byte
    Value []byte
}

// EventStreamMessage represents a parsed AWS Event Stream message.
type EventStreamMessage struct {
    Headers map[string]string
    Payload []byte
}

// EventStreamReader reads and parses AWS Event Stream format.
// AWS Event Stream format:
// - Total byte length (4 bytes, big-endian)
// - Headers byte length (4 bytes, big-endian)
// - Prelude CRC (4 bytes)
// - Headers (variable length)
// - Payload (variable length)
// - Message CRC (4 bytes)
type EventStreamReader struct {
    reader io.Reader
}

// NewEventStreamReader creates a new Event Stream reader.
func NewEventStreamReader(r io.Reader) *EventStreamReader {
    return &EventStreamReader{reader: r}
}

// ReadMessage reads the next message from the Event Stream.
// Returns io.EOF when stream is exhausted.
func (r *EventStreamReader) ReadMessage() (*EventStreamMessage, error) {
    // Read prelude (8 bytes: total length + headers length)
    prelude := make([]byte, 8)
    if _, err := io.ReadFull(r.reader, prelude); err != nil {
        return nil, err
    }

    totalLength := binary.BigEndian.Uint32(prelude[0:4])
    headersLength := binary.BigEndian.Uint32(prelude[4:8])

    // Read prelude CRC (4 bytes)
    preludeCRC := make([]byte, 4)
    if _, err := io.ReadFull(r.reader, preludeCRC); err != nil {
        return nil, fmt.Errorf("eventstream: failed to read prelude CRC: %w", err)
    }

    // Validate prelude CRC
    expectedCRC := crc32.ChecksumIEEE(prelude)
    actualCRC := binary.BigEndian.Uint32(preludeCRC)
    if expectedCRC != actualCRC {
        return nil, fmt.Errorf("eventstream: prelude CRC mismatch: expected %x, got %x", expectedCRC, actualCRC)
    }

    // Calculate payload length
    // totalLength includes: prelude (8) + preludeCRC (4) + headers + payload + messageCRC (4)
    payloadLength := totalLength - 8 - 4 - headersLength - 4

    // Read headers
    headersData := make([]byte, headersLength)
    if _, err := io.ReadFull(r.reader, headersData); err != nil {
        return nil, fmt.Errorf("eventstream: failed to read headers: %w", err)
    }

    // Parse headers
    headers, err := parseEventStreamHeaders(headersData)
    if err != nil {
        return nil, fmt.Errorf("eventstream: failed to parse headers: %w", err)
    }

    // Read payload
    payload := make([]byte, payloadLength)
    if _, err := io.ReadFull(r.reader, payload); err != nil {
        return nil, fmt.Errorf("eventstream: failed to read payload: %w", err)
    }

    // Read message CRC (4 bytes) - we validate but don't block on mismatch
    msgCRC := make([]byte, 4)
    if _, err := io.ReadFull(r.reader, msgCRC); err != nil {
        return nil, fmt.Errorf("eventstream: failed to read message CRC: %w", err)
    }

    return &EventStreamMessage{
        Headers: headers,
        Payload: payload,
    }, nil
}

// parseEventStreamHeaders parses the headers section of an Event Stream message.
func parseEventStreamHeaders(data []byte) (map[string]string, error) {
    headers := make(map[string]string)
    buf := bytes.NewReader(data)

    for buf.Len() > 0 {
        // Header name length (1 byte)
        nameLen, err := buf.ReadByte()
        if err != nil {
            return nil, err
        }

        // Header name
        name := make([]byte, nameLen)
        if _, err := io.ReadFull(buf, name); err != nil {
            return nil, err
        }

        // Header type (1 byte)
        headerType, err := buf.ReadByte()
        if err != nil {
            return nil, err
        }

        // Header value (type 7 = string, 2 bytes length + value)
        if headerType == 7 { // String type
            var valueLen uint16
            if err := binary.Read(buf, binary.BigEndian, &valueLen); err != nil {
                return nil, err
            }
            value := make([]byte, valueLen)
            if _, err := io.ReadFull(buf, value); err != nil {
                return nil, err
            }
            headers[string(name)] = string(value)
        } else {
            // Skip other header types for now (not used by Anthropic responses)
            // Type 0 = bool true (0 bytes)
            // Type 1 = bool false (0 bytes)
            // Type 2 = byte (1 byte)
            // Type 3 = short (2 bytes)
            // Type 4 = int (4 bytes)
            // Type 5 = long (8 bytes)
            // Type 6 = bytes (2 bytes length + value)
            // Type 8 = timestamp (8 bytes)
            // Type 9 = uuid (16 bytes)
            switch headerType {
            case 0, 1:
                // No value bytes
            case 2:
                buf.ReadByte()
            case 3:
                buf.Seek(2, io.SeekCurrent)
            case 4:
                buf.Seek(4, io.SeekCurrent)
            case 5, 8:
                buf.Seek(8, io.SeekCurrent)
            case 6:
                var l uint16
                binary.Read(buf, binary.BigEndian, &l)
                buf.Seek(int64(l), io.SeekCurrent)
            case 9:
                buf.Seek(16, io.SeekCurrent)
            }
        }
    }

    return headers, nil
}

// EventStreamToSSE converts AWS Event Stream format to SSE format.
// Reads from the Event Stream reader and writes SSE events to the ResponseWriter.
// Flushes after each event for real-time streaming.
func EventStreamToSSE(r io.Reader, w http.ResponseWriter) error {
    reader := NewEventStreamReader(r)
    flusher, canFlush := w.(http.Flusher)

    for {
        msg, err := reader.ReadMessage()
        if err == io.EOF {
            return nil
        }
        if err != nil {
            return fmt.Errorf("eventstream: read error: %w", err)
        }

        // Check message type from headers
        msgType := msg.Headers[":message-type"]
        eventType := msg.Headers[":event-type"]

        if msgType == "exception" {
            // Error event - extract and return error
            var errPayload struct {
                Message string `json:"message"`
            }
            if err := json.Unmarshal(msg.Payload, &errPayload); err == nil && errPayload.Message != "" {
                return fmt.Errorf("bedrock error: %s", errPayload.Message)
            }
            return fmt.Errorf("bedrock exception: %s", string(msg.Payload))
        }

        if msgType == "event" {
            // Map Bedrock event types to Anthropic SSE event types
            sseEvent := mapBedrockEventToSSE(eventType)

            // Write SSE event
            fmt.Fprintf(w, "event: %s\n", sseEvent)
            fmt.Fprintf(w, "data: %s\n\n", string(msg.Payload))

            if canFlush {
                flusher.Flush()
            }
        }
    }
}

// mapBedrockEventToSSE maps Bedrock event types to Anthropic SSE event types.
// Bedrock uses slightly different event naming.
func mapBedrockEventToSSE(bedrockEvent string) string {
    switch bedrockEvent {
    case "chunk":
        // Bedrock sends "chunk" for content deltas
        return "content_block_delta"
    case "message_start":
        return "message_start"
    case "content_block_start":
        return "content_block_start"
    case "content_block_delta":
        return "content_block_delta"
    case "content_block_stop":
        return "content_block_stop"
    case "message_delta":
        return "message_delta"
    case "message_stop":
        return "message_stop"
    default:
        // Pass through unknown events
        return bedrockEvent
    }
}

// SetSSEHeaders sets the standard SSE headers on the response.
func SetSSEHeaders(h http.Header) {
    h.Set("Content-Type", "text/event-stream")
    h.Set("Cache-Control", "no-cache, no-transform")
    h.Set("X-Accel-Buffering", "no")
    h.Set("Connection", "keep-alive")
}
```

Create comprehensive tests in eventstream_test.go:
- Test Event Stream message parsing
- Test header parsing for various types
- Test CRC validation
- Test SSE conversion output
- Test error handling
  </action>
  <verify>
- `go build ./internal/providers/...` succeeds
- `go test ./internal/providers/... -v -run EventStream` passes
- Test coverage for eventstream.go > 70%
  </verify>
  <done>Event Stream to SSE converter implemented with tests</done>
</task>

<task type="auto">
  <name>Task 3: Create BedrockProvider implementation</name>
  <files>internal/providers/bedrock.go</files>
  <action>
Create the Bedrock provider with SigV4 authentication and URL transformation:

```go
package providers

import (
    "bytes"
    "context"
    "crypto/sha256"
    "encoding/hex"
    "fmt"
    "io"
    "net/http"
    "net/url"
    "time"

    "github.com/aws/aws-sdk-go-v2/aws"
    v4 "github.com/aws/aws-sdk-go-v2/aws/signer/v4"
    "github.com/aws/aws-sdk-go-v2/config"
    "github.com/aws/aws-sdk-go-v2/credentials"
    "github.com/rs/zerolog/log"
)

const (
    // BedrockOwner is the owner identifier for AWS Bedrock provider.
    BedrockOwner = "aws"

    // BedrockAnthropicVersion is the anthropic_version for Bedrock requests.
    // Must be in request body (not header) for Bedrock.
    BedrockAnthropicVersion = "bedrock-2023-05-31"

    // bedrockService is the AWS service name for SigV4 signing.
    bedrockService = "bedrock"
)

// DefaultBedrockModels are the default models available from AWS Bedrock.
// Model IDs use Bedrock format: anthropic.model-name:version
var DefaultBedrockModels = []string{
    "anthropic.claude-sonnet-4-5-20250514-v1:0",
    "anthropic.claude-opus-4-5-20250514-v1:0",
    "anthropic.claude-haiku-3-5-20241022-v1:0",
}

// BedrockProvider implements the Provider interface for AWS Bedrock.
// Bedrock requires:
// - Model in URL path (not body)
// - anthropic_version in request body (not header)
// - AWS SigV4 signed requests
// - Event Stream format for streaming responses (converted to SSE)
type BedrockProvider struct {
    BaseProvider
    region    string
    awsConfig aws.Config
    signer    *v4.Signer
}

// BedrockConfig holds Bedrock-specific configuration.
type BedrockConfig struct {
    Name            string
    Region          string   // AWS region (e.g., "us-east-1")
    AccessKeyID     string   // Optional: explicit credentials
    SecretAccessKey string   // Optional: explicit credentials
    Models          []string
    ModelMapping    map[string]string
}

// NewBedrockProvider creates a new AWS Bedrock provider instance.
// Uses AWS SDK default credential chain unless explicit credentials provided.
func NewBedrockProvider(ctx context.Context, cfg BedrockConfig) (*BedrockProvider, error) {
    if cfg.Region == "" {
        return nil, fmt.Errorf("bedrock: region is required")
    }

    if len(cfg.Models) == 0 {
        cfg.Models = DefaultBedrockModels
    }

    // Construct base URL for Bedrock Runtime
    // Format: https://bedrock-runtime.{region}.amazonaws.com
    baseURL := fmt.Sprintf("https://bedrock-runtime.%s.amazonaws.com", cfg.Region)

    // Load AWS config with optional explicit credentials
    var awsOpts []func(*config.LoadOptions) error
    awsOpts = append(awsOpts, config.WithRegion(cfg.Region))

    if cfg.AccessKeyID != "" && cfg.SecretAccessKey != "" {
        awsOpts = append(awsOpts, config.WithCredentialsProvider(
            credentials.NewStaticCredentialsProvider(cfg.AccessKeyID, cfg.SecretAccessKey, ""),
        ))
    }

    awsCfg, err := config.LoadDefaultConfig(ctx, awsOpts...)
    if err != nil {
        return nil, fmt.Errorf("bedrock: failed to load AWS config: %w", err)
    }

    return &BedrockProvider{
        BaseProvider: NewBaseProviderWithMapping(cfg.Name, baseURL, BedrockOwner, cfg.Models, cfg.ModelMapping),
        region:       cfg.Region,
        awsConfig:    awsCfg,
        signer:       v4.NewSigner(),
    }, nil
}

// NewBedrockProviderWithConfig creates a Bedrock provider with an explicit AWS config.
// Useful for testing or when using custom credential providers.
func NewBedrockProviderWithConfig(cfg BedrockConfig, awsCfg aws.Config) *BedrockProvider {
    if len(cfg.Models) == 0 {
        cfg.Models = DefaultBedrockModels
    }

    baseURL := fmt.Sprintf("https://bedrock-runtime.%s.amazonaws.com", cfg.Region)

    return &BedrockProvider{
        BaseProvider: NewBaseProviderWithMapping(cfg.Name, baseURL, BedrockOwner, cfg.Models, cfg.ModelMapping),
        region:       cfg.Region,
        awsConfig:    awsCfg,
        signer:       v4.NewSigner(),
    }
}

// Authenticate signs the request with AWS SigV4.
// The key parameter is ignored - we use the AWS config credentials.
func (p *BedrockProvider) Authenticate(req *http.Request, _ string) error {
    ctx := req.Context()

    // Get credentials from config
    creds, err := p.awsConfig.Credentials.Retrieve(ctx)
    if err != nil {
        return fmt.Errorf("bedrock: failed to retrieve credentials: %w", err)
    }

    // Read and hash the body
    var body []byte
    if req.Body != nil {
        body, err = io.ReadAll(req.Body)
        if err != nil {
            return fmt.Errorf("bedrock: failed to read request body: %w", err)
        }
        // Restore body for the actual request
        req.Body = io.NopCloser(bytes.NewReader(body))
    }

    payloadHash := sha256.Sum256(body)
    payloadHashHex := hex.EncodeToString(payloadHash[:])

    // Sign the request with SigV4
    err = p.signer.SignHTTP(ctx, creds, req, payloadHashHex, bedrockService, p.region, time.Now())
    if err != nil {
        return fmt.Errorf("bedrock: SigV4 signing failed: %w", err)
    }

    log.Ctx(ctx).Debug().
        Str("provider", p.name).
        Str("region", p.region).
        Msg("signed Bedrock request with SigV4")

    return nil
}

// ForwardHeaders returns headers to forward to Bedrock.
// Note: anthropic_version goes in body for Bedrock, not header.
func (p *BedrockProvider) ForwardHeaders(originalHeaders http.Header) http.Header {
    headers := p.BaseProvider.ForwardHeaders(originalHeaders)

    // Remove anthropic-version from headers (it goes in body for Bedrock)
    headers.Del("Anthropic-Version")

    // Bedrock requires specific content type
    headers.Set("Content-Type", "application/json")

    return headers
}

// TransformRequest transforms the request for Bedrock:
// 1. Extracts model from body
// 2. Removes model from body
// 3. Adds anthropic_version to body
// 4. Constructs URL with model in path
func (p *BedrockProvider) TransformRequest(body []byte, endpoint string) ([]byte, string, error) {
    // Use shared transformation utility
    newBody, model, err := TransformBodyForCloudProvider(body, BedrockAnthropicVersion)
    if err != nil {
        return nil, "", fmt.Errorf("bedrock: transform failed: %w", err)
    }

    // Map model name to Bedrock format if needed
    model = p.MapModel(model)

    // Construct Bedrock URL with model in path
    // Format: /model/{model}/invoke or /model/{model}/invoke-with-response-stream
    action := "invoke"

    // Check if streaming is requested (presence of stream field or based on endpoint)
    // For now, default to streaming endpoint as most Claude Code requests are streaming
    action = "invoke-with-response-stream"

    targetURL := fmt.Sprintf("%s/model/%s/%s",
        p.baseURL,
        url.PathEscape(model),
        action)

    return newBody, targetURL, nil
}

// RequiresBodyTransform returns true for Bedrock.
// Model is removed from body and added to URL path.
func (p *BedrockProvider) RequiresBodyTransform() bool {
    return true
}

// StreamingContentType returns the Bedrock streaming content type.
// Bedrock uses Event Stream format, not standard SSE.
func (p *BedrockProvider) StreamingContentType() string {
    return "application/vnd.amazon.eventstream"
}

// TransformResponse converts Bedrock Event Stream to SSE format.
// This is called by the proxy handler for streaming responses.
func (p *BedrockProvider) TransformResponse(resp *http.Response, w http.ResponseWriter) error {
    contentType := resp.Header.Get("Content-Type")

    // Check if this is an Event Stream response that needs conversion
    if contentType != "application/vnd.amazon.eventstream" {
        // Non-streaming response, no transformation needed
        return nil
    }

    // Set SSE headers for the client
    SetSSEHeaders(w.Header())
    w.WriteHeader(http.StatusOK)

    // Convert Event Stream to SSE
    return EventStreamToSSE(resp.Body, w)
}

// GetRegion returns the configured AWS region.
func (p *BedrockProvider) GetRegion() string {
    return p.region
}
```

Key implementation details from research:
- anthropic_version "bedrock-2023-05-31" goes in body (not header)
- Model ID format: "anthropic.claude-sonnet-4-5-20250514-v1:0"
- URL uses /model/{model}/invoke-with-response-stream
- SigV4 signing requires reading body to compute hash
- Streaming returns Event Stream (needs conversion to SSE)
  </action>
  <verify>
- `go build ./internal/providers/...` succeeds
- BedrockProvider implements all Provider interface methods
  </verify>
  <done>BedrockProvider implementation complete with SigV4 and Event Stream support</done>
</task>

<task type="auto">
  <name>Task 4: Create comprehensive unit tests for BedrockProvider</name>
  <files>internal/providers/bedrock_test.go</files>
  <action>
Create thorough unit tests with mocked AWS config:

```go
package providers

import (
    "bytes"
    "context"
    "encoding/json"
    "io"
    "net/http"
    "net/http/httptest"
    "testing"

    "github.com/aws/aws-sdk-go-v2/aws"
    "github.com/aws/aws-sdk-go-v2/credentials"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

// mockAWSConfig creates a mock AWS config for testing.
func mockAWSConfig(region string) aws.Config {
    return aws.Config{
        Region: region,
        Credentials: credentials.NewStaticCredentialsProvider(
            "AKIAIOSFODNN7EXAMPLE",
            "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY",
            "",
        ),
    }
}

func TestNewBedrockProviderWithConfig(t *testing.T) {
    t.Run("creates provider with required config", func(t *testing.T) {
        cfg := BedrockConfig{
            Name:   "test-bedrock",
            Region: "us-east-1",
        }
        awsCfg := mockAWSConfig(cfg.Region)
        p := NewBedrockProviderWithConfig(cfg, awsCfg)

        assert.Equal(t, "test-bedrock", p.Name())
        assert.Equal(t, "https://bedrock-runtime.us-east-1.amazonaws.com", p.BaseURL())
        assert.Equal(t, BedrockOwner, p.Owner())
        assert.Equal(t, "us-east-1", p.GetRegion())
    })

    t.Run("uses default models when none specified", func(t *testing.T) {
        cfg := BedrockConfig{
            Name:   "test-bedrock",
            Region: "us-east-1",
        }
        awsCfg := mockAWSConfig(cfg.Region)
        p := NewBedrockProviderWithConfig(cfg, awsCfg)

        models := p.ListModels()
        assert.Len(t, models, len(DefaultBedrockModels))
    })

    t.Run("uses custom models when specified", func(t *testing.T) {
        cfg := BedrockConfig{
            Name:   "test-bedrock",
            Region: "us-east-1",
            Models: []string{"custom-model"},
        }
        awsCfg := mockAWSConfig(cfg.Region)
        p := NewBedrockProviderWithConfig(cfg, awsCfg)

        models := p.ListModels()
        assert.Len(t, models, 1)
        assert.Equal(t, "custom-model", models[0].ID)
    })

    t.Run("constructs correct URL for different regions", func(t *testing.T) {
        regions := []string{"us-east-1", "us-west-2", "eu-west-1"}
        for _, region := range regions {
            cfg := BedrockConfig{Name: "test", Region: region}
            awsCfg := mockAWSConfig(region)
            p := NewBedrockProviderWithConfig(cfg, awsCfg)

            expected := "https://bedrock-runtime." + region + ".amazonaws.com"
            assert.Equal(t, expected, p.BaseURL())
        }
    })
}

func TestBedrockProvider_Authenticate(t *testing.T) {
    t.Run("adds SigV4 authorization header", func(t *testing.T) {
        cfg := BedrockConfig{
            Name:   "test-bedrock",
            Region: "us-east-1",
        }
        awsCfg := mockAWSConfig(cfg.Region)
        p := NewBedrockProviderWithConfig(cfg, awsCfg)

        body := []byte(`{"messages":[]}`)
        req := httptest.NewRequest(http.MethodPost, "/model/test/invoke", bytes.NewReader(body))
        req.Header.Set("Content-Type", "application/json")

        err := p.Authenticate(req, "") // key param ignored

        require.NoError(t, err)
        auth := req.Header.Get("Authorization")
        assert.Contains(t, auth, "AWS4-HMAC-SHA256")
        assert.Contains(t, auth, "Credential=AKIAIOSFODNN7EXAMPLE")
        assert.Contains(t, auth, "/bedrock/") // service name in credential scope
    })

    t.Run("preserves request body after signing", func(t *testing.T) {
        cfg := BedrockConfig{
            Name:   "test-bedrock",
            Region: "us-east-1",
        }
        awsCfg := mockAWSConfig(cfg.Region)
        p := NewBedrockProviderWithConfig(cfg, awsCfg)

        body := []byte(`{"messages":[{"role":"user","content":"Hello"}]}`)
        req := httptest.NewRequest(http.MethodPost, "/model/test/invoke", bytes.NewReader(body))

        err := p.Authenticate(req, "")

        require.NoError(t, err)

        // Body should still be readable
        readBody, err := io.ReadAll(req.Body)
        require.NoError(t, err)
        assert.Equal(t, body, readBody)
    })

    t.Run("handles nil body", func(t *testing.T) {
        cfg := BedrockConfig{
            Name:   "test-bedrock",
            Region: "us-east-1",
        }
        awsCfg := mockAWSConfig(cfg.Region)
        p := NewBedrockProviderWithConfig(cfg, awsCfg)

        req := httptest.NewRequest(http.MethodGet, "/model/test/invoke", nil)
        err := p.Authenticate(req, "")

        require.NoError(t, err)
        assert.Contains(t, req.Header.Get("Authorization"), "AWS4-HMAC-SHA256")
    })
}

func TestBedrockProvider_ForwardHeaders(t *testing.T) {
    cfg := BedrockConfig{
        Name:   "test-bedrock",
        Region: "us-east-1",
    }
    awsCfg := mockAWSConfig(cfg.Region)
    p := NewBedrockProviderWithConfig(cfg, awsCfg)

    t.Run("removes anthropic-version header", func(t *testing.T) {
        origHeaders := http.Header{}
        origHeaders.Set("Anthropic-Version", "2023-06-01")
        headers := p.ForwardHeaders(origHeaders)

        // anthropic_version goes in body for Bedrock, not header
        assert.Empty(t, headers.Get("Anthropic-Version"))
    })

    t.Run("sets Content-Type to application/json", func(t *testing.T) {
        origHeaders := http.Header{}
        headers := p.ForwardHeaders(origHeaders)

        assert.Equal(t, "application/json", headers.Get("Content-Type"))
    })

    t.Run("preserves other anthropic headers", func(t *testing.T) {
        origHeaders := http.Header{}
        origHeaders.Set("Anthropic-Beta", "tools-2024-04-04")
        headers := p.ForwardHeaders(origHeaders)

        assert.Equal(t, "tools-2024-04-04", headers.Get("Anthropic-Beta"))
    })
}

func TestBedrockProvider_TransformRequest(t *testing.T) {
    cfg := BedrockConfig{
        Name:   "test-bedrock",
        Region: "us-east-1",
    }
    awsCfg := mockAWSConfig(cfg.Region)
    p := NewBedrockProviderWithConfig(cfg, awsCfg)

    t.Run("removes model from body and adds anthropic_version", func(t *testing.T) {
        body := []byte(`{"model":"anthropic.claude-sonnet-4-5-20250514-v1:0","messages":[{"role":"user","content":"Hello"}]}`)

        newBody, _, err := p.TransformRequest(body, "/v1/messages")

        require.NoError(t, err)

        // Parse result to verify
        var result map[string]interface{}
        err = json.Unmarshal(newBody, &result)
        require.NoError(t, err)

        // Model should be removed
        _, hasModel := result["model"]
        assert.False(t, hasModel, "model should be removed from body")

        // anthropic_version should be added
        assert.Equal(t, BedrockAnthropicVersion, result["anthropic_version"])

        // messages should be preserved
        assert.NotNil(t, result["messages"])
    })

    t.Run("constructs correct streaming URL with model in path", func(t *testing.T) {
        body := []byte(`{"model":"anthropic.claude-sonnet-4-5-20250514-v1:0","messages":[]}`)

        _, targetURL, err := p.TransformRequest(body, "/v1/messages")

        require.NoError(t, err)
        expected := "https://bedrock-runtime.us-east-1.amazonaws.com/model/anthropic.claude-sonnet-4-5-20250514-v1%3A0/invoke-with-response-stream"
        assert.Equal(t, expected, targetURL)
    })

    t.Run("applies model mapping", func(t *testing.T) {
        cfgWithMapping := BedrockConfig{
            Name:   "test-bedrock",
            Region: "us-east-1",
            ModelMapping: map[string]string{
                "claude-4": "anthropic.claude-sonnet-4-5-20250514-v1:0",
            },
        }
        pWithMapping := NewBedrockProviderWithConfig(cfgWithMapping, awsCfg)

        body := []byte(`{"model":"claude-4","messages":[]}`)
        _, targetURL, err := pWithMapping.TransformRequest(body, "/v1/messages")

        require.NoError(t, err)
        assert.Contains(t, targetURL, "anthropic.claude-sonnet-4-5-20250514-v1%3A0")
    })
}

func TestBedrockProvider_RequiresBodyTransform(t *testing.T) {
    cfg := BedrockConfig{
        Name:   "test-bedrock",
        Region: "us-east-1",
    }
    awsCfg := mockAWSConfig(cfg.Region)
    p := NewBedrockProviderWithConfig(cfg, awsCfg)

    assert.True(t, p.RequiresBodyTransform())
}

func TestBedrockProvider_SupportsStreaming(t *testing.T) {
    cfg := BedrockConfig{
        Name:   "test-bedrock",
        Region: "us-east-1",
    }
    awsCfg := mockAWSConfig(cfg.Region)
    p := NewBedrockProviderWithConfig(cfg, awsCfg)

    assert.True(t, p.SupportsStreaming())
}

func TestBedrockProvider_StreamingContentType(t *testing.T) {
    cfg := BedrockConfig{
        Name:   "test-bedrock",
        Region: "us-east-1",
    }
    awsCfg := mockAWSConfig(cfg.Region)
    p := NewBedrockProviderWithConfig(cfg, awsCfg)

    // Bedrock uses Event Stream, not SSE
    assert.Equal(t, "application/vnd.amazon.eventstream", p.StreamingContentType())
}

func TestBedrockProvider_TransformResponse(t *testing.T) {
    cfg := BedrockConfig{
        Name:   "test-bedrock",
        Region: "us-east-1",
    }
    awsCfg := mockAWSConfig(cfg.Region)
    p := NewBedrockProviderWithConfig(cfg, awsCfg)

    t.Run("no-op for non-eventstream content type", func(t *testing.T) {
        resp := &http.Response{
            Header: http.Header{"Content-Type": []string{"application/json"}},
        }
        w := httptest.NewRecorder()

        err := p.TransformResponse(resp, w)

        require.NoError(t, err)
        // No headers set, no transformation
        assert.Empty(t, w.Header().Get("Content-Type"))
    })
}

func TestBedrockProvider_ModelMapping(t *testing.T) {
    cfg := BedrockConfig{
        Name:   "test-bedrock",
        Region: "us-east-1",
        ModelMapping: map[string]string{
            "claude-4":    "anthropic.claude-sonnet-4-5-20250514-v1:0",
            "claude-opus": "anthropic.claude-opus-4-5-20250514-v1:0",
        },
    }
    awsCfg := mockAWSConfig(cfg.Region)
    p := NewBedrockProviderWithConfig(cfg, awsCfg)

    t.Run("maps known model", func(t *testing.T) {
        assert.Equal(t, "anthropic.claude-sonnet-4-5-20250514-v1:0", p.MapModel("claude-4"))
    })

    t.Run("returns original for unknown model", func(t *testing.T) {
        assert.Equal(t, "unknown-model", p.MapModel("unknown-model"))
    })
}
```

Tests cover:
- Provider creation with various configs
- SigV4 authentication header generation
- Body preservation after signing
- Header forwarding (anthropic-version removal)
- Body transformation (model removal, anthropic_version addition)
- URL construction with model in path and URL encoding
- Streaming content type
- Response transformation logic
- Model mapping
  </action>
  <verify>
- `go test ./internal/providers/... -v -run Bedrock` passes
- Test coverage for bedrock.go > 80%
  </verify>
  <done>Comprehensive unit tests for BedrockProvider with >80% coverage</done>
</task>

</tasks>

<verification>
After all tasks:
1. `go build ./internal/providers/...` succeeds
2. `go test ./internal/providers/... -v -run "Bedrock|EventStream"` passes all tests
3. `go test ./internal/providers/... -cover` shows bedrock.go > 80%, eventstream.go > 70%
4. `task lint` passes
5. AWS SDK v2 libraries in go.mod
</verification>

<success_criteria>
- BedrockProvider implements Provider interface with all transformation methods
- AWS SigV4 signing works correctly
- Model removed from body and added to URL path
- anthropic_version "bedrock-2023-05-31" added to body
- Event Stream to SSE conversion works for streaming responses
- Tests verify all functionality including error cases
</success_criteria>

<output>
After completion, create `.planning/phases/06-cloud-providers/06-04-SUMMARY.md`
</output>
