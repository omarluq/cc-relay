---
phase: 06-cloud-providers
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - internal/providers/azure.go
  - internal/providers/azure_test.go
autonomous: true

must_haves:
  truths:
    - "Azure Foundry provider authenticates with x-api-key header"
    - "Azure Foundry provider constructs correct endpoint URL"
    - "Azure Foundry provider supports both streaming and non-streaming"
  artifacts:
    - path: "internal/providers/azure.go"
      provides: "AzureProvider implementation"
      exports: ["AzureProvider", "NewAzureProvider"]
    - path: "internal/providers/azure_test.go"
      provides: "Unit tests for Azure provider"
      min_lines: 100
  key_links:
    - from: "internal/providers/azure.go"
      to: "internal/providers/base.go"
      via: "embeds BaseProvider"
      pattern: "AzureProvider struct.*BaseProvider"
---

<objective>
Implement Azure Foundry provider with API key authentication and standard Anthropic API format.

Purpose: Azure Foundry is the simplest cloud provider to implement (standard Anthropic format, x-api-key auth, no complex transformations), making it ideal to validate the transformer architecture before tackling more complex providers.

Output: Working Azure provider with authentication, URL construction, and full test coverage.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-cloud-providers/06-RESEARCH.md

# Prior plan output for interface extension
@.planning/phases/06-cloud-providers/06-01-SUMMARY.md

# Existing provider patterns
@internal/providers/base.go
@internal/providers/anthropic.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AzureProvider implementation</name>
  <files>internal/providers/azure.go</files>
  <action>
Create the Azure Foundry provider following the BaseProvider embedding pattern:

```go
package providers

import (
    "fmt"
    "net/http"

    "github.com/rs/zerolog/log"
)

const (
    // AzureOwner is the owner identifier for Azure Foundry provider.
    AzureOwner = "azure"

    // DefaultAzureAPIVersion is the default Azure API version.
    DefaultAzureAPIVersion = "2024-06-01"
)

// DefaultAzureModels are the default models available from Azure Foundry.
// These match Anthropic models available through Azure.
var DefaultAzureModels = []string{
    "claude-sonnet-4-5-20250514",
    "claude-opus-4-5-20250514",
    "claude-haiku-3-5-20241022",
}

// AzureProvider implements the Provider interface for Azure Foundry.
// Azure Foundry uses standard Anthropic API format with x-api-key authentication.
// The key difference is the URL structure: https://{resource}.services.ai.azure.com/models/chat/completions
type AzureProvider struct {
    BaseProvider
    resourceName  string
    deploymentID  string
    apiVersion    string
    authMethod    string // "api_key" or "entra_id"
}

// AzureConfig holds Azure-specific configuration.
type AzureConfig struct {
    Name           string
    ResourceName   string   // Azure resource name
    DeploymentID   string   // Deployment/model ID
    APIVersion     string   // API version (default: 2024-06-01)
    AuthMethod     string   // "api_key" (default) or "entra_id"
    Models         []string
    ModelMapping   map[string]string
}

// NewAzureProvider creates a new Azure Foundry provider instance.
func NewAzureProvider(cfg AzureConfig) *AzureProvider {
    if cfg.APIVersion == "" {
        cfg.APIVersion = DefaultAzureAPIVersion
    }
    if cfg.AuthMethod == "" {
        cfg.AuthMethod = "api_key"
    }
    if len(cfg.Models) == 0 {
        cfg.Models = DefaultAzureModels
    }

    // Construct base URL from resource name
    // Format: https://{resource-name}.services.ai.azure.com
    baseURL := fmt.Sprintf("https://%s.services.ai.azure.com", cfg.ResourceName)

    return &AzureProvider{
        BaseProvider:  NewBaseProviderWithMapping(cfg.Name, baseURL, AzureOwner, cfg.Models, cfg.ModelMapping),
        resourceName:  cfg.ResourceName,
        deploymentID:  cfg.DeploymentID,
        apiVersion:    cfg.APIVersion,
        authMethod:    cfg.AuthMethod,
    }
}

// Authenticate adds Azure-specific authentication to the request.
// Uses x-api-key header (same as Anthropic) for API key auth.
func (p *AzureProvider) Authenticate(req *http.Request, key string) error {
    if p.authMethod == "entra_id" {
        // Entra ID uses Bearer token
        req.Header.Set("Authorization", "Bearer "+key)
    } else {
        // API key uses x-api-key header (Anthropic-compatible)
        req.Header.Set("x-api-key", key)
    }

    log.Ctx(req.Context()).Debug().
        Str("provider", p.name).
        Str("auth_method", p.authMethod).
        Msg("added Azure authentication")

    return nil
}

// ForwardHeaders returns headers to forward to Azure.
// Includes anthropic-version header (required by Azure Foundry).
func (p *AzureProvider) ForwardHeaders(originalHeaders http.Header) http.Header {
    headers := p.BaseProvider.ForwardHeaders(originalHeaders)

    // Azure requires anthropic-version in header (unlike Bedrock/Vertex which use body)
    if headers.Get("Anthropic-Version") == "" {
        headers.Set("Anthropic-Version", "2023-06-01")
    }

    return headers
}

// TransformRequest constructs the Azure endpoint URL.
// Azure uses standard Anthropic body format (no model removal).
// URL format: https://{resource}.services.ai.azure.com/models/chat/completions?api-version={version}
func (p *AzureProvider) TransformRequest(body []byte, endpoint string) ([]byte, string, error) {
    // Azure keeps model in body (same as direct Anthropic)
    // Construct URL with api-version query parameter
    targetURL := fmt.Sprintf("%s/models/chat/completions?api-version=%s",
        p.baseURL, p.apiVersion)

    return body, targetURL, nil
}

// RequiresBodyTransform returns false for Azure.
// Azure uses standard Anthropic body format.
func (p *AzureProvider) RequiresBodyTransform() bool {
    return false
}
```

Key points from research:
- Azure Foundry uses x-api-key header (Anthropic-compatible)
- anthropic-version goes in HEADER (not body like Bedrock/Vertex)
- Model stays in body (not URL path)
- URL includes api-version query parameter
  </action>
  <verify>
- `go build ./internal/providers/...` succeeds
- File exists with expected exports
  </verify>
  <done>AzureProvider implementation complete with proper authentication and URL construction</done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive unit tests for AzureProvider</name>
  <files>internal/providers/azure_test.go</files>
  <action>
Create thorough unit tests covering all AzureProvider functionality:

```go
package providers

import (
    "net/http"
    "net/http/httptest"
    "testing"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestNewAzureProvider(t *testing.T) {
    t.Run("creates provider with required config", func(t *testing.T) {
        cfg := AzureConfig{
            Name:         "test-azure",
            ResourceName: "my-resource",
            DeploymentID: "claude-deployment",
        }
        p := NewAzureProvider(cfg)

        assert.Equal(t, "test-azure", p.Name())
        assert.Equal(t, "https://my-resource.services.ai.azure.com", p.BaseURL())
        assert.Equal(t, AzureOwner, p.Owner())
        assert.Equal(t, DefaultAzureAPIVersion, p.apiVersion)
        assert.Equal(t, "api_key", p.authMethod)
    })

    t.Run("uses custom API version", func(t *testing.T) {
        cfg := AzureConfig{
            Name:         "test-azure",
            ResourceName: "my-resource",
            APIVersion:   "2024-12-01",
        }
        p := NewAzureProvider(cfg)
        assert.Equal(t, "2024-12-01", p.apiVersion)
    })

    t.Run("uses default models when none specified", func(t *testing.T) {
        cfg := AzureConfig{
            Name:         "test-azure",
            ResourceName: "my-resource",
        }
        p := NewAzureProvider(cfg)
        models := p.ListModels()
        assert.Len(t, models, len(DefaultAzureModels))
    })

    t.Run("uses custom models when specified", func(t *testing.T) {
        cfg := AzureConfig{
            Name:         "test-azure",
            ResourceName: "my-resource",
            Models:       []string{"custom-model"},
        }
        p := NewAzureProvider(cfg)
        models := p.ListModels()
        assert.Len(t, models, 1)
        assert.Equal(t, "custom-model", models[0].ID)
    })
}

func TestAzureProvider_Authenticate(t *testing.T) {
    t.Run("uses x-api-key for api_key auth", func(t *testing.T) {
        cfg := AzureConfig{
            Name:         "test-azure",
            ResourceName: "my-resource",
            AuthMethod:   "api_key",
        }
        p := NewAzureProvider(cfg)

        req := httptest.NewRequest(http.MethodPost, "/v1/messages", nil)
        err := p.Authenticate(req, "test-key-123")

        require.NoError(t, err)
        assert.Equal(t, "test-key-123", req.Header.Get("x-api-key"))
        assert.Empty(t, req.Header.Get("Authorization"))
    })

    t.Run("uses Bearer token for entra_id auth", func(t *testing.T) {
        cfg := AzureConfig{
            Name:         "test-azure",
            ResourceName: "my-resource",
            AuthMethod:   "entra_id",
        }
        p := NewAzureProvider(cfg)

        req := httptest.NewRequest(http.MethodPost, "/v1/messages", nil)
        err := p.Authenticate(req, "entra-token-xyz")

        require.NoError(t, err)
        assert.Equal(t, "Bearer entra-token-xyz", req.Header.Get("Authorization"))
        assert.Empty(t, req.Header.Get("x-api-key"))
    })
}

func TestAzureProvider_ForwardHeaders(t *testing.T) {
    cfg := AzureConfig{
        Name:         "test-azure",
        ResourceName: "my-resource",
    }
    p := NewAzureProvider(cfg)

    t.Run("adds anthropic-version header if missing", func(t *testing.T) {
        origHeaders := http.Header{}
        headers := p.ForwardHeaders(origHeaders)

        assert.Equal(t, "2023-06-01", headers.Get("Anthropic-Version"))
        assert.Equal(t, "application/json", headers.Get("Content-Type"))
    })

    t.Run("preserves existing anthropic-version", func(t *testing.T) {
        origHeaders := http.Header{}
        origHeaders.Set("Anthropic-Version", "2024-01-01")
        headers := p.ForwardHeaders(origHeaders)

        assert.Equal(t, "2024-01-01", headers.Get("Anthropic-Version"))
    })

    t.Run("forwards other anthropic headers", func(t *testing.T) {
        origHeaders := http.Header{}
        origHeaders.Set("Anthropic-Beta", "tools-2024-04-04")
        headers := p.ForwardHeaders(origHeaders)

        assert.Equal(t, "tools-2024-04-04", headers.Get("Anthropic-Beta"))
    })
}

func TestAzureProvider_TransformRequest(t *testing.T) {
    cfg := AzureConfig{
        Name:         "test-azure",
        ResourceName: "my-resource",
        APIVersion:   "2024-06-01",
    }
    p := NewAzureProvider(cfg)

    t.Run("constructs correct URL with api-version", func(t *testing.T) {
        body := []byte(`{"model":"claude-sonnet-4-5-20250514","messages":[]}`)

        newBody, targetURL, err := p.TransformRequest(body, "/v1/messages")

        require.NoError(t, err)
        assert.Equal(t, body, newBody) // Body unchanged
        assert.Equal(t,
            "https://my-resource.services.ai.azure.com/models/chat/completions?api-version=2024-06-01",
            targetURL)
    })

    t.Run("body is unchanged", func(t *testing.T) {
        body := []byte(`{"model":"claude-sonnet-4-5-20250514","messages":[{"role":"user","content":"Hello"}]}`)

        newBody, _, err := p.TransformRequest(body, "/v1/messages")

        require.NoError(t, err)
        assert.JSONEq(t, string(body), string(newBody))
    })
}

func TestAzureProvider_RequiresBodyTransform(t *testing.T) {
    cfg := AzureConfig{
        Name:         "test-azure",
        ResourceName: "my-resource",
    }
    p := NewAzureProvider(cfg)

    assert.False(t, p.RequiresBodyTransform())
}

func TestAzureProvider_SupportsStreaming(t *testing.T) {
    cfg := AzureConfig{
        Name:         "test-azure",
        ResourceName: "my-resource",
    }
    p := NewAzureProvider(cfg)

    assert.True(t, p.SupportsStreaming())
}

func TestAzureProvider_StreamingContentType(t *testing.T) {
    cfg := AzureConfig{
        Name:         "test-azure",
        ResourceName: "my-resource",
    }
    p := NewAzureProvider(cfg)

    assert.Equal(t, "text/event-stream", p.StreamingContentType())
}

func TestAzureProvider_ModelMapping(t *testing.T) {
    cfg := AzureConfig{
        Name:         "test-azure",
        ResourceName: "my-resource",
        ModelMapping: map[string]string{
            "claude-4": "claude-sonnet-4-5-20250514",
        },
    }
    p := NewAzureProvider(cfg)

    t.Run("maps known model", func(t *testing.T) {
        assert.Equal(t, "claude-sonnet-4-5-20250514", p.MapModel("claude-4"))
    })

    t.Run("returns original for unknown model", func(t *testing.T) {
        assert.Equal(t, "unknown-model", p.MapModel("unknown-model"))
    })
}
```

Tests cover:
- Provider creation with various configs
- API key and Entra ID authentication
- Header forwarding with anthropic-version
- URL construction with api-version parameter
- Body preservation (no transformation)
- Streaming support
- Model mapping
  </action>
  <verify>
- `go test ./internal/providers/... -v -run Azure` passes
- Test coverage for azure.go > 80%
  </verify>
  <done>Comprehensive unit tests for AzureProvider with >80% coverage</done>
</task>

</tasks>

<verification>
After all tasks:
1. `go build ./internal/providers/...` succeeds
2. `go test ./internal/providers/... -v -run Azure` passes all tests
3. `go test ./internal/providers/... -cover` shows azure.go > 80%
4. `task lint` passes
</verification>

<success_criteria>
- AzureProvider implements Provider interface
- x-api-key and Entra ID authentication work correctly
- URL construction includes api-version parameter
- anthropic-version header added correctly
- Tests verify all functionality
</success_criteria>

<output>
After completion, create `.planning/phases/06-cloud-providers/06-02-SUMMARY.md`
</output>
